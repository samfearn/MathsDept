<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Sam Fearn Department of Mathematical Sciences, Durham University The notes for this term were originally written by Dr. Sophy Darwin and are based on a previous course developed by Rob de Jeu, Sophy Darwin, Fredrik Strömberg, and Emilie Dufresne Please send questions, comments or corrections to s.m.fearn@durham.ac.uk" />
  <title>MATH3401 Error-correcting Codes Epiphany term 2020</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
  </style>
  <link rel="stylesheet" href="https://samfearn.github.io/latex.min.css" />
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML" type="text/javascript"></script>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
  <script type="text/x-mathjax-config">
  	MathJax.Hub.Config({ TeX: { equationNumbers: {autoNumber: "ams"} } });
  	// I need to wait until MathJax has finished before running the numbering script
  	MathJax.Hub.Register.StartupHook("End",function(){doNumbering()});
  </script>
</head>
<body>
<header id="title-block-header">
<h1 class="title"><span>MATH3401</span><br />
<span>Error-correcting Codes</span><br />
<span>Epiphany term 2020</span></h1>
<p class="author">Sam Fearn<br />
<span>Department of Mathematical Sciences, Durham University</span><br />
<span>The notes for this term were originally written by Dr. Sophy Darwin</span><br />
<span>and are based on a previous course developed by</span><br />
Rob de Jeu, Sophy Darwin, Fredrik Strömberg, and Emilie Dufresne<br />
<span>Please send questions, comments or corrections to</span><br />
<code>s.m.fearn@durham.ac.uk</code></p>
</header>
<nav id="TOC" role="doc-toc">
<ul>
<li><a href="#cha:basiccodingtheory"><span class="toc-section-number">1</span> Basic Coding Theory</a>
<ul>
<li><a href="#sec:firstdefinitions"><span class="toc-section-number">1.1</span> First Definitions</a></li>
<li><a href="#sec:nearestneighbourdecoding"><span class="toc-section-number">1.2</span> Nearest-Neighbour Decoding</a></li>
<li><a href="#sec:probabilities"><span class="toc-section-number">1.3</span> Probabilities</a></li>
<li><a href="#sec:boundsoncodes"><span class="toc-section-number">1.4</span> Bounds on Codes</a></li>
</ul></li>
<li><a href="#cha:linearcodes"><span class="toc-section-number">2</span> Linear Codes</a>
<ul>
<li><a href="#sec:finitefields"><span class="toc-section-number">2.1</span> Finite Fields</a></li>
<li><a href="#finite-vector-spaces"><span class="toc-section-number">2.2</span> Finite Vector Spaces</a></li>
<li><a href="#sec:arraydecoding"><span class="toc-section-number">2.3</span> Array Decoding</a></li>
</ul></li>
<li><a href="#cha:codesasimages"><span class="toc-section-number">3</span> Codes as Images</a>
<ul>
<li><a href="#mappings-and-matrices"><span class="toc-section-number">3.1</span> Mappings and Matrices</a></li>
<li><a href="#generator-matrices"><span class="toc-section-number">3.2</span> Generator-matrices</a></li>
<li><a href="#sec:encodingandchanneldecoding"><span class="toc-section-number">3.3</span> Encoding and Channel Decoding</a></li>
<li><a href="#sec:equivalence"><span class="toc-section-number">3.4</span> Equivalence and Standard Form</a></li>
</ul></li>
<li><a href="#codes-as-kernels"><span class="toc-section-number">4</span> Codes as Kernels</a>
<ul>
<li><a href="#dual-codes"><span class="toc-section-number">4.1</span> Dual codes</a></li>
<li><a href="#check-matrices"><span class="toc-section-number">4.2</span> Check-matrices</a></li>
<li><a href="#syndrome-decoding"><span class="toc-section-number">4.3</span> Syndrome Decoding</a></li>
<li><a href="#minimum-distance-from-a-check-matrix"><span class="toc-section-number">4.4</span> Minimum distance from a check-matrix</a></li>
</ul></li>
<li><a href="#perfect-codes"><span class="toc-section-number">5</span> Perfect Codes</a>
<ul>
<li><a href="#hamming-codes"><span class="toc-section-number">5.1</span> Hamming codes</a></li>
<li><a href="#extending-and-puncturing"><span class="toc-section-number">5.2</span> Extending and Puncturing</a></li>
<li><a href="#sec:golay_codes"><span class="toc-section-number">5.3</span> Golay Codes</a></li>
</ul></li>

</ul>
</nav>
<section id="cha:basiccodingtheory" class="level1" data-number="1">
<h1 data-number="1"><span class="header-section-number">1</span> Basic Coding Theory</h1>
<p>Error-correcting codes use very abstract mathematics in very concrete applications. If we try to communicate information over some “channel” (e.g., by radio transmission, by storing data on tape and retrieving it later, or by writing music on a CD and playing it later) then there is usually a chance that some errors occur: what comes out of the channel is not identical to what went in. Various strategies have been developed to help with this, one of which is the theory of error-correcting codes. Using such a code, one hopes to decode any information in such a way that the errors that occurred in transmission are corrected and the original information is retrieved.</p>
<p>This is the basic situation:</p>
<p><span class="math inline">\(\boxed{SENDER} \overset{\rm message}{\longrightarrow\longrightarrow} \boxed{ENCODER} \overset{\rm codeword}{\longrightarrow\longrightarrow} \boxed{CHANNEL} \overset{\text{ received}}{\overset{\text{ word}}{\longrightarrow\longrightarrow}} 
\boxed{DECODER} \overset{\text{ decoded}}{\overset{\text{ message}}{\longrightarrow\longrightarrow}} \boxed{USER}\)</span></p>
<p>And here is an example of what might happen:</p>
<p><span class="math inline">\(\boxed{\substack{\text{Yes} \\ \text{ or No}}} \overset{\rm Yes}{\longrightarrow\longrightarrow}\; \boxed{\substack{\text{Yes } \rightarrow 000 \\ \text{No } \rightarrow 111}} \overset{000}{\longrightarrow\longrightarrow}\; \boxed{\substack{NOISE \\ \hookrightarrow 100}} \overset{100}{\longrightarrow\longrightarrow} \boxed{100 \sim 000 \rightarrow Yes} \overset{\text{Yes}}{\longrightarrow\longrightarrow} \boxed{USER}\)</span></p>
<p>The decoder does two things: first (<span class="math inline">\(\sim\)</span>) it makes a good guess as to what codeword was sent, and then (<span class="math inline">\(\rightarrow\)</span>) converts this back to a message. We shall be mostly concerned with the <span class="math inline">\(\sim\)</span> process, and how to encode so that <span class="math inline">\(\sim\)</span> works well.</p>
<p>There is no very good name for <span class="math inline">\(\sim\)</span> . It is often called “decoding", but this should really include <span class="math inline">\(\rightarrow\)</span> as well. We can also call it “error-correction", but this is not quite right either, as we can never be <span><em>sure</em></span> we have found the original codeword - only that we <span><em>probably</em></span> have.</p>
<section id="sec:firstdefinitions" class="level2" data-number="1.1">
<h2 data-number="1.1"><span class="header-section-number">1.1</span> First Definitions</h2>
<div class="definition">
<p>An <span><strong>alphabet</strong></span> is a finite set of symbols. If <span class="math inline">\(A\)</span> is an alphabet, then <span class="math inline">\(A^n\)</span> is the set of all lists of <span class="math inline">\(n\)</span> symbols from <span class="math inline">\(A\)</span>. (So <span class="math inline">\(|A^n| = |A|^n\)</span>.) We call these lists <span><strong>words</strong></span> of <span><strong>length</strong></span> <span class="math inline">\(n\)</span>. A <span><strong>code</strong></span> <span class="math inline">\(C\)</span> of <span><strong>block length</strong></span> <span class="math inline">\(n\)</span> on alphabet <span class="math inline">\(A\)</span> is a subset of <span class="math inline">\(A^n\)</span>. A <span><strong>codeword</strong></span> is an element of the code.</p>
</div>
<div class="exampleqed">
<p>If the alphabet <span class="math inline">\(A= \{0,1\}\)</span>, then <span class="math inline">\(A^3 = \{000, 001, 010, 011, 100, 101, 110, 111\}\)</span>. Above, we used <span class="math inline">\(C_1 = \{000, 111\} \subseteq A^3\)</span>.</p>
<p>Now suppose <span class="math inline">\(C_2 = \{000,110, 101, 011\} \subseteq A^3\)</span>. We might have: <span class="math inline">\(\overset{000}{\longrightarrow\longrightarrow}
\boxed{\substack{NOISE \\ 001\hookleftarrow }}
\stackrel{001}{\longrightarrow\longrightarrow}
\boxed{001 \sim \left\{\begin{matrix}
0 0 0  \\1 0 1 \\0 1 1 
\end{matrix} \right\} \;\;? }
\overset{???}{\longrightarrow\longrightarrow}\;\)</span></p>
<p>We detect an error, but it is not clear how to correct it.</p>
</div>
<div class="definition">
<p>If <span class="math inline">\(|A|=2\)</span> then <span class="math inline">\(C\)</span> is a <span><strong>binary</strong></span> code. If <span class="math inline">\(|A|=3\)</span> then <span class="math inline">\(C\)</span> is a <span><strong>ternary</strong></span> code. If <span class="math inline">\(|A|=q\)</span> then <span class="math inline">\(C\)</span> is a <span class="math inline">\(q\)</span><span><strong>-ary</strong></span> code. (We usually use <span class="math inline">\(A = \{0,1,2,\ldots ,q-1\}\)</span>.)</p>
</div>
<div class="definition">
<p>For some alphabet <span class="math inline">\(A\)</span>, let <span class="math inline">\(x\)</span> and <span class="math inline">\(y\)</span> be words in <span class="math inline">\(A^n\)</span>. The <span><strong>Hamming distance</strong></span> between <span class="math inline">\(x\)</span> and <span class="math inline">\(y\)</span>, written <span class="math inline">\(d(x, y)\)</span>, is the number of places in which <span class="math inline">\(x\)</span> and <span class="math inline">\(y\)</span> differ. So <span class="math inline">\(d(x,y)\)</span> is also the (minimum) number of changes of a symbol needed to turn <span class="math inline">\(x\)</span> into <span class="math inline">\(y\)</span>. If <span class="math inline">\(x\)</span> was transmitted, but <span class="math inline">\(y\)</span> is received, then <span class="math inline">\(d(x,y)\)</span> <span><strong>symbol-errors</strong></span> have occurred.</p>
</div>
<div class="exampleqed">
<p>If <span class="math inline">\(x=0102\)</span> and <span class="math inline">\(y=2111\)</span> in <span class="math inline">\(\{0,1,2\}^4\)</span>, then <span class="math inline">\(d(x,y) = 3.\)</span></p>
</div>
<p>Formally <span class="math inline">\(d\)</span> is a function, <span class="math inline">\(d:A^n \times A^n \longrightarrow \{0,1,2,\ldots\}\)</span>. We call it a distance because in certain important ways it behaves like ordinary Euclidean distance, measured between two points in <span class="math inline">\({{\mathbb R}}^n\)</span>. In fact, because of properties ii), iii) and iv) of the following proposition, <span class="math inline">\(d\)</span> qualifies as a ‘metric’.</p>
<div class="proposition">
<p>For words <span class="math inline">\(x\)</span> and <span class="math inline">\(y\)</span> of length <span class="math inline">\(n\)</span>, the Hamming distance <span class="math inline">\(d(x,y)\)</span> satisfies:</p>
<ul>
<li><p><span class="math inline">\(0 \leq d(x,y) \leq n\)</span></p></li>
<li><p><span class="math inline">\(d(x,y)= 0 \Leftrightarrow x=y\)</span></p></li>
<li><p><span class="math inline">\(d(x,y) = d(y, x)\)</span></p></li>
<li><p><span class="math inline">\(d(x,y) \leq d(x,z) + d(z,y)\)</span></p></li>
</ul>
</div>
<div class="proof">
<p>The first three are obvious. For iv), the triangle inequality, we use the second meaning of <span class="math inline">\(d(x,y)\)</span>: the RHS is</p>
<p>the number of changes required to turn <span class="math inline">\(x\)</span> into <span class="math inline">\(z\)</span></p>
<p><span class="math inline">\(\;\;+\;\;\)</span></p>
<p>the number of changes required to turn <span class="math inline">\(z\)</span> into <span class="math inline">\(y\)</span>.</p>
<p>All these changes would certainly change <span class="math inline">\(x\)</span> into <span class="math inline">\(y\)</span>, so the RHS must be at least the minimum number of changes to do so, which is <span class="math inline">\(d(x,y)\)</span>.</p>
</div>
<div class="definition">
<p>For a code <span class="math inline">\(C\)</span>, its <span><strong>minimum distance</strong></span> <span class="math inline">\(d(C)\)</span> is min<span class="math inline">\(\{d(x,y)\;|\;x\in C, y \in C, x \neq y\}\)</span>. So <span class="math inline">\(d(C) \in \{1,2,3,\ldots\}\)</span> A code of block length <span class="math inline">\(n\)</span> with <span class="math inline">\(M\)</span> codewords and minimum distance <span class="math inline">\(d\)</span> is called an <span class="math inline">\((n, M, d)\)</span> code (or sometimes an <span class="math inline">\((n, M)\)</span> code).</p>
</div>
<p>We sometimes also refer to a <span class="math inline">\(q\)</span>-ary <span class="math inline">\((n,M,d)\)</span> code as an <span class="math inline">\((n,M,d)_q\)</span> code.</p>
<div class="exampleqed">
<p>C=<span class="math inline">\(\{0001, 2200,0031\} \subseteq\{0, 1, 2, \ldots,6\}^4\)</span> is a 7-ary (4,3,1) code.</p>
</div>
<div class="definition">
<p>If <span class="math inline">\(C \subseteq A^n\)</span> is a code, and <span class="math inline">\(x\)</span> is a word in <span class="math inline">\(A^n\)</span>, then a <span><strong>nearest neighbour</strong></span> of <span class="math inline">\(x\)</span> is a codeword <span class="math inline">\(c \in C\)</span> such that <span class="math inline">\(d(x,c) =\)</span> min<span class="math inline">\(\{d(x,y)\; | \; y \in C\}\)</span>. A word may have several nearest neighbours. A codeword’s nearest neighbour is itself.</p>
</div>
<div class="exampleqed">
<p>If <span class="math inline">\(C = \{000,111,110,011\} \subseteq \{0,1\}^3\)</span>, and <span class="math inline">\(x= 100\)</span>, then <span class="math inline">\(d(x,000) =1\)</span>, <span class="math inline">\(d(x,111) =2\)</span>, <span class="math inline">\(d(x,110)= 1\)</span>, <span class="math inline">\(d(x,011) =3\)</span>. So <span class="math inline">\(x\)</span> has two nearest neighbours, 000 and 110.</p>
</div>
</section>
<section id="sec:nearestneighbourdecoding" class="level2" data-number="1.2">
<h2 data-number="1.2"><span class="header-section-number">1.2</span> Nearest-Neighbour Decoding</h2>
<p>In this course, we shall be using <span><strong>nearest-neighbour decoding</strong></span>: if a word <span class="math inline">\(x\)</span> is received, we shall decode it to a nearest neighbour of <span class="math inline">\(x\)</span> in our code <span class="math inline">\(C\)</span>. This can always be done by finding <span class="math inline">\(d(x,c)\)</span> for every <span class="math inline">\(c \in C\)</span>, though soon we’ll have better methods.</p>
<div class="exampleqed">
<p>Let <span class="math inline">\(C_1\)</span> be our original (3,2,3) code, <span class="math inline">\(C= \{000,111\} \subseteq \{0,1\}^3\)</span>. Then we would decode 000, 100, 010, and 001 to 000. We would decode 111, 110, 101, and 011 to 111.</p>
</div>
<div class="exampleqed">
<p>Let <span class="math inline">\(C_2\)</span> be the (2,2,2) code <span class="math inline">\(C_2 = \{00,11\} \subseteq \{0,1\}^2\)</span>. Then clearly we would decode 00 to 00, and 11 to 11. But 01 and 10 each have two nearest neighbours, both 00 and 11.</p>
</div>
<p>So we can deal with <span class="math inline">\(C_2\)</span> in two different ways:</p>
<ul>
<li><p>We decide which nearest neighbour to use, for example <span class="math inline">\(01\)</span> to <span class="math inline">\(00\)</span>, <span class="math inline">\(10\)</span> to <span class="math inline">\(11\)</span>. Or perhaps both <span class="math inline">\(01\)</span> and 10 go to 00. Both of these are nearest-neighbour decoding. (Later, our algorithm for finding a nearest neighbour may decide this for us.)</p></li>
<li><p>“Incomplete decoding": we do not decode 10 and 01 at all. Possibly we ask for retransmission.</p></li>
</ul>
<p><span><strong>Notation:</strong></span> The “floor function" <span class="math inline">\(\lfloor x
\rfloor\)</span> means the largest integer <span class="math inline">\(\leq x\)</span>. So <span class="math inline">\(\lfloor 3.7 \rfloor = 3\)</span>, <span class="math inline">\(\lfloor 6 \rfloor =6\)</span>, <span class="math inline">\(\lfloor -1/2 \rfloor = -1\)</span>.</p>
<div id="prop:correctdetect" class="proposition">
<p> For a code with minimum distance <span class="math inline">\(d\)</span>, if a word has:</p>
<ul>
<li><p><span class="math inline">\(\leq d-1\)</span> symbol-errors, we will detect that it has some errors.</p></li>
<li><p><span class="math inline">\(\leq \lfloor \frac{d-1}{2} \rfloor\)</span> symbol-errors, nearest-neighbour decoding will correct them.</p></li>
</ul>
</div>
<p>Notice that, even with more symbol-errors than this, we <span><em>may</em></span> be able to detect or correct. But this is our guaranteed minimum performance.</p>
<div class="proof">
<p>Suppose codeword <span class="math inline">\(c\)</span> is sent, but <span class="math inline">\(t &gt;0\)</span> symbol-errors occur, and and word <span class="math inline">\(x\)</span> is received. So <span class="math inline">\(d(c,x) = t\)</span>.</p>
<ul>
<li><p>If <span class="math inline">\(c&#39;\)</span> is another codeword, we know <span class="math inline">\(d(c,c&#39;) \geq d\)</span>. So if <span class="math inline">\(0 &lt; t = d(c,x)\leq d-1\)</span>, then <span class="math inline">\(x\)</span> is not a codeword. We notice this, so we detect that symbol-errors have occurred (though we cannot be sure which symbols have been affected).</p></li>
<li><p>We must show that, if <span class="math inline">\(t \leq \lfloor \frac{d-1}{2} \rfloor\)</span>, then <span class="math inline">\(c\)</span> is the <span><em>unique</em></span> nearest neighbour of <span class="math inline">\(x\)</span>; that is, if <span class="math inline">\(c&#39;\)</span> is any other codeword, then <span class="math inline">\(d(x,c) &lt; d(x,c&#39;)\)</span>. Suppose not. Then <span class="math inline">\(d(x,c&#39;) \leq d(x,c) \leq\lfloor \frac{d-1}{2} \rfloor\)</span>. But then by the triangle inequality we have <span class="math display">\[d(c,c&#39;) \leq d(c,x) + d(x,c&#39;) \leq2 \left\lfloor \frac{d-1}{2} \right\rfloor \leq d-1.\]</span> This contradicts that <span class="math inline">\(d\)</span> was minimum distance.</p></li>
</ul>
</div>
<p>Draw your own pictures for these proofs: For i), you need a circle of radius <span class="math inline">\(d - 1\)</span> centred on <span class="math inline">\(c\)</span>. For ii), draw the “suppose" part: a triangle with vertices <span class="math inline">\(c\)</span>, <span class="math inline">\(x\)</span>, and <span class="math inline">\(c&#39;\)</span>.</p>
<p>Informally, we often say the code <span class="math inline">\(C\)</span> “detects" or “corrects" so many symbol-errors, when we really mean that our decoding procedure, used with this code, detects or corrects them.</p>
<div class="exampleqed">
<p>Let <span class="math inline">\(C\)</span> have <span class="math inline">\(d = 5\)</span>. Then <span class="math inline">\(\lfloor \frac{d-1}{2}\rfloor = 2\)</span>, and so this code can detect up to 4 symbol errors and correct up to 2 symbol errors.</p>
</div>
<div class="exampleqed">
<p>The code <span class="math inline">\(C_2 = \{00,11\} \subseteq \{0,1\}^2\)</span> has <span class="math inline">\(d=2\)</span>. So it detects up to 2 - 1 = 1 symbol-errors, but corrects <span class="math inline">\(\lfloor \frac{2-1}{2}\rfloor = 0\)</span>, as we found.</p>
<p>The code <span class="math inline">\(C_1 = \{000,111\} \subseteq \{0,1\}^3\)</span> has <span class="math inline">\(d=3\)</span>. So it detects up to 3 - 1 = 2 symbol-errors, but corrects <span class="math inline">\(\lfloor \frac{3-1}{2}\rfloor = 1\)</span>. Suppose that <span class="math inline">\(c=000\)</span> is sent, but we receive <span class="math inline">\(x= 101\)</span>, so we have 2 symbol-errors. Then we detect that symbol-errors have occurred, because <span class="math inline">\(x\)</span> is not a codeword. But nearest-neighbour decoding gives 111, so we fail to correct them.</p>
</div>
</section>
<section id="sec:probabilities" class="level2" data-number="1.3">
<h2 data-number="1.3"><span class="header-section-number">1.3</span> Probabilities</h2>
<p>So far we have tacitly assumed that a codeword is more likely to suffer a small number of symbol-errors, than a larger number. This is why Proposition <a href="#prop:correctdetect" data-reference-type="ref" data-reference="prop:correctdetect">[prop:correctdetect]</a>, which talks about being able to detect or correct symbol-errors <span><em>up to</em></span> a certain number, is useful. Now we must make our assumptions explicit, and calculate the probabilities of different outcomes. We start by defining a certain kind of channel, in which all symbol-errors are equally likely.</p>
<div id="def:symmetricchannel" class="definition">
<p> A <span><strong><span class="math inline">\(q\)</span>-ary symmetric channel with symbol-error probability <span class="math inline">\(p\)</span></strong></span> is a channel for a <span class="math inline">\(q\)</span>-ary alphabet <span class="math inline">\(A\)</span> such that:</p>
<ul>
<li><p>For any <span class="math inline">\(a \in A\)</span>, the chance that it is changed in the channel is <span class="math inline">\(p\)</span>.</p></li>
<li><p>For any <span class="math inline">\(a, b \in A, a\neq b\)</span>, the chance that <span class="math inline">\(a\)</span> is changed to <span class="math inline">\(b\)</span> in the channel, written <span class="math inline">\(P(b\; {\rm received}\;|\; a \;{\rm sent})\)</span>, is <span class="math inline">\(\frac{p}{q-1}\)</span>.</p></li>
</ul>
</div>
<p>Symmetric channels are easy to work with, but many real-life channels are not strictly symmetric. Part ii) of the definition says that <span class="math inline">\(p\)</span>, the chance of change, is split equally among all <span class="math inline">\(q-1\)</span> other symbols: each wrong symbol is equally likely. So the symbol 6 would be equally likely to become 5, 0, or 9. But in fact 5 and 7 are more likely if someone is typing, 0 if copying by hand, and 9 if arranging plastic numbers on the fridge!</p>
<p>Part i) says that the chance of change is not affected by which symbol is sent, or its position in the codeword, or which other symbols are nearby, or whether other symbols are changed. So for example, in a symmetric channel, 12234 is equally likely to become 12334 or 12134. In fact, if someone tries to remember or copy 12234, 12334 (repeating the wrong symbol) is much more likely than 12134. Similarly, with two symbol-errors occurring, in a symmetric channel 12234 is equally likely to become 12243 or 14233. But for human error, 12243 (swapping two adjacent symbols) is the more likely.</p>
<p>(For many types of mechanical channel, also, 12234 is more likely to become 12243 than 14233, but this is because the physical cause of a symbol-error (a scratch on a CD, or a surge of electricity, for example) is likely also to affect adjacent symbols. So symbol-errors in the last two positions is more likely than symbol-errors in the second position and the last. There are ways to adapt nearest-neighbour decoding to help with the fact that, in real life, symbol-errors may tend to come in “bursts".)</p>
<p>In the language of probability, i) implies that in a symmetric channel, symbol-errors in different positions are <span><em>independent</em></span> events. This makes for easy calculations.</p>
<div id="prop:receivedgivensentprobability" class="proposition">
<p> Let <span class="math inline">\(c\)</span> be a codeword in a <span class="math inline">\(q\)</span>-ary code of block-length <span class="math inline">\(n\)</span>, sent over a <span class="math inline">\(q\)</span>-ary symmetric channel with symbol-error probability <span class="math inline">\(p\)</span>. Then <span class="math display">\[P( x \;{\rm received} \;| \;  c \;{\rm sent}) = \left( \frac{p}{q-1}\right)^t(1-p)^{n-t},\;\; {\rm where}\;\; t = d(c,x).\]</span></p>
</div>
<div class="proof">
<p>First we note that, from the definition of of a symmetric channel, the chance of a symbol remaining correct is <span class="math inline">\(1-p\)</span>.</p>
<p>To change <span class="math inline">\(c\)</span> to <span class="math inline">\(x\)</span>, the channel must make the “right" change in each of the “right" <span class="math inline">\(t\)</span> positions. From Definition <a href="#def:symmetricchannel" data-reference-type="ref" data-reference="def:symmetricchannel">[def:symmetricchannel]</a>, the chance of each of these events is <span class="math inline">\(\frac{p}{q-1}\)</span>. Since they are independent, the chance of all of them occurring is <span class="math inline">\(\left( \frac{p}{q-1}\right)^t\)</span>. But the symbols in the other <span class="math inline">\(n-t\)</span> positions must remain correct, and the chance of this is <span class="math inline">\((1-p)^{n-t}\)</span>. Again using independence, we multiply to get the result.</p>
</div>
<p>In the case <span class="math inline">\(t =0\)</span>, we have <span class="math inline">\(x=c\)</span>. So the chance of <span class="math inline">\(c\)</span> being correctly received is <span class="math inline">\((1-p)^n\)</span>.</p>
<div class="exampleqed">
<p>Using the code <span class="math inline">\(C_2 = \{000,111\} \subseteq \{0,1\}^3\)</span>, so <span class="math inline">\(q=2\)</span>, suppose 000 is sent. Then the chance of receiving 001 is <span class="math inline">\(p(1-p)^2\)</span>. There is the same chance of receiving 010. In fact, we can complete the following table:</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: center;"><span class="math inline">\(x\)</span></td>
<td style="text-align: center;"><span class="math inline">\(t=d(000,x)\)</span></td>
<td style="text-align: center;">chance 000</td>
<td style="text-align: center;">chance if <span class="math inline">\(p=0.01\)</span></td>
<td style="text-align: center;">n-n decodes</td>
</tr>
<tr class="even">
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;">received as <span class="math inline">\(x\)</span></td>
<td style="text-align: center;"></td>
<td style="text-align: center;">correctly?</td>
</tr>
<tr class="odd">
<td style="text-align: center;">000</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;"><span class="math inline">\((1-p)^3\)</span></td>
<td style="text-align: center;">0.970299</td>
<td style="text-align: center;">yes</td>
</tr>
<tr class="even">
<td style="text-align: center;">100</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;">010</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;"><span class="math inline">\(p(1-p)^2\)</span></td>
<td style="text-align: center;">0.009801</td>
<td style="text-align: center;">yes</td>
</tr>
<tr class="even">
<td style="text-align: center;">001</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;">110</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;">101</td>
<td style="text-align: center;">2</td>
<td style="text-align: center;"><span class="math inline">\(p^2(1-p)\)</span></td>
<td style="text-align: center;">0.000099</td>
<td style="text-align: center;">no</td>
</tr>
<tr class="odd">
<td style="text-align: center;">011</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;">111</td>
<td style="text-align: center;">3</td>
<td style="text-align: center;"><span class="math inline">\(p^3\)</span></td>
<td style="text-align: center;">0.000001</td>
<td style="text-align: center;">no</td>
</tr>
</tbody>
</table>
</div>
<p>Note that nearest-neighbour decoding corrects 000, 100, 010, and 001 all to 000. So, if <span class="math inline">\(p=.01\)</span>, then the chance of success is: <span class="math display">\[\begin{aligned}
P(\text{we decode back to 000}) &amp; = &amp; P(\text{we receive 000, 001, 010, or 100})\\
 &amp; = &amp;  0.99^3 + 3 \times 0.01 \times 0.99^2 =  0.999702\\ \end{aligned}\]</span> We can also see in the table that because <span class="math inline">\(p&lt; 1-p\)</span>, smaller <span class="math inline">\(d(000,x)\)</span> gives a larger chance. A closer <span class="math inline">\(x\)</span> is more likely to be received. More generally, we have:</p>
<p><span id="cor:receivedwordlikelyneighbour" label="cor:receivedwordlikelyneighbour">[cor:receivedwordlikelyneighbour]</span> If <span class="math inline">\(p &lt; (q-1)/q\)</span> then <span class="math inline">\(P(x \;{\rm received}\;|\;c \;\rm{sent})\)</span> increases as <span class="math inline">\(d(x,c)\)</span> decreases.</p>
<p>Before we prove this, consider a channel so noisy that all information is lost: whatever symbol is sent, there is an equal chance, <span class="math inline">\(1/q\)</span>, of each symbol being received. In a ‘random’ channel like this, the chance that a symbol is changed is <span class="math inline">\((q-1)/q\)</span>. So the corollary is considering channels which are better than random.</p>
<div class="proof">
<p>If <span class="math inline">\(p &lt; (q-1)/q\)</span> then it is easy to show that <span class="math inline">\(1-p &gt;1/q\)</span> (the chance that a symbol remains unchanged is more than random), and also that <span class="math inline">\(p/(q-1)&lt;1/q\)</span> (the chance that a specified wrong symbol is received is less than random). Putting these together, we have <span class="math inline">\((1-p) &gt; p/(q-1)\)</span> (so the most likely symbol to be received is the correct one) and it follow that <span class="math inline">\((1-p)^{n-t}\left( \frac{p}{q-1}\right)^t\)</span> is larger for smaller <span class="math inline">\(t\)</span>.</p>
</div>
<div class="exampleqed">
<p>For the (3,3,3) code <span class="math inline">\(C=\{ 111, 202, 020 \} \subseteq \{0, 1, 2\}^3\)</span>, there are more words to consider. Suppose we send codeword <span class="math inline">\(c=111\)</span> through a ternary symmetric channel with symbol-error probability <span class="math inline">\(p\)</span>. The following table shows the probability of different <span class="math inline">\(d(x,c)\)</span>, when <span class="math inline">\(p=1/4\)</span> and when <span class="math inline">\(p= 1/2\)</span>, calculated using Proposition <a href="#prop:receivedgivensentprobability" data-reference-type="ref" data-reference="prop:receivedgivensentprobability">[prop:receivedgivensentprobability]</a>:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;"></th>
<th style="text-align: center;"><span><span class="math inline">\(p= 1/4\)</span></span></th>
<th style="text-align: center;"><span><span class="math inline">\(p= 1/2\)</span></span></th>
<th style="text-align: center;"></th>
<th style="text-align: center;"></th>
<th style="text-align: center;"></th>
<th style="text-align: center;"></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><span class="math inline">\(t=\)</span></td>
<td style="text-align: center;">ex.s of</td>
<td style="text-align: center;"># of</td>
<td style="text-align: center;">for each such <span class="math inline">\(x\)</span>,</td>
<td style="text-align: center;">prob. of</td>
<td style="text-align: center;">for each such <span class="math inline">\(x\)</span>,</td>
<td style="text-align: center;">prob. of</td>
</tr>
<tr class="even">
<td style="text-align: center;"><span class="math inline">\(d(x,c)\)</span></td>
<td style="text-align: center;">such <span class="math inline">\(x\)</span></td>
<td style="text-align: center;">such <span class="math inline">\(x\)</span></td>
<td style="text-align: center;">prob. received</td>
<td style="text-align: center;">this <span class="math inline">\(t\)</span></td>
<td style="text-align: center;">prob. received</td>
<td style="text-align: center;">this <span class="math inline">\(t\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;">0</td>
<td style="text-align: center;">111</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;"><span class="math inline">\(\left(1-\frac{1}{4}\right)^3\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\frac{27}{64}\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\left(1-\frac{1}{2}\right)^3\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\frac{1}{8}\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"><span class="math inline">\(= \frac{27}{64}\)</span></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"><span class="math inline">\(= \frac{1}{8}\)</span></td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;"></td>
<td style="text-align: center;">110</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;">1</td>
<td style="text-align: center;">112</td>
<td style="text-align: center;">6</td>
<td style="text-align: center;"><span class="math inline">\(\left(1-\frac{1}{4}\right)^2 \cdot\frac{1/4}{2}\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\frac{27}{64}\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\left(1-\frac{1}{2}\right)^2 \cdot\frac{1/2}{2}\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\frac{3}{8}\)</span></td>
</tr>
<tr class="even">
<td style="text-align: center;"></td>
<td style="text-align: center;">101</td>
<td style="text-align: center;">= <span class="math inline">\(\binom{3}{1} \times 2\)</span></td>
<td style="text-align: center;"><span class="math inline">\(= \frac{9}{128}\)</span></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"><span class="math inline">\(= \frac{1}{16}\)</span></td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;"></td>
<td style="text-align: center;">⋮</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;"></td>
<td style="text-align: center;">100</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;"></td>
<td style="text-align: center;">102</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;">2</td>
<td style="text-align: center;">120</td>
<td style="text-align: center;">12</td>
<td style="text-align: center;"><span class="math inline">\(\left(1-\frac{1}{4}\right) \left(\frac{1/4}{2}\right)^2\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\frac{9}{64}\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\left(1-\frac{1}{2}\right) \left(\frac{1/2}{2}\right)^2\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\frac{3}{8}\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: center;"></td>
<td style="text-align: center;">122</td>
<td style="text-align: center;">= <span class="math inline">\(\binom{3}{2}\times 2^2\)</span></td>
<td style="text-align: center;"><span class="math inline">\(= \frac{3}{256}\)</span></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"><span class="math inline">\(= \frac{1}{32}\)</span></td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;"></td>
<td style="text-align: center;">⋮</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;"></td>
<td style="text-align: center;">000</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;">3</td>
<td style="text-align: center;">002</td>
<td style="text-align: center;">8</td>
<td style="text-align: center;"><span class="math inline">\(\left(\frac{1/4}{2}\right)^3\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\frac{1}{64}\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\left(\frac{1/2}{2}\right)^3\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\frac{1}{8}\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: center;"></td>
<td style="text-align: center;">⋮</td>
<td style="text-align: center;"><span class="math inline">\(=\binom{3}{3}\times 2^3\)</span></td>
<td style="text-align: center;"><span class="math inline">\(= \frac{1}{512}\)</span></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"><span class="math inline">\(= \frac{1}{64}\)</span></td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;"></td>
<td style="text-align: center;">222</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
</tbody>
</table>
<p>Both <span class="math inline">\(p=1/4\)</span> and <span class="math inline">\(p=1/2\)</span> are quite large, but we have <span class="math inline">\(p&lt; (3-1)/3\)</span>, so Corollary <a href="#cor:receivedwordlikelyneighbour" data-reference-type="ref" data-reference="cor:receivedwordlikelyneighbour">[cor:receivedwordlikelyneighbour]</a> applies, and we can see the probabilities increase as we go up the fourth or sixth column.</p>
<p>As <span class="math inline">\(d(C)\)</span> is 3 , <span class="math inline">\(C\)</span> can correct one symbol-error and detect two. A word with <span class="math inline">\(\geq 2\)</span> symbol-errors may have the the wrong nearest neighbour (102 has nearest neighbour 202), or it may have several nearest neighbours (100 has all three codeword as nearest neighbours).</p>
<p>So suppose now we only decode when the nearest neighbour is unique. Then for <span class="math inline">\(d(x,c) =0\)</span> or 1 we will always decode correctly. For <span class="math inline">\(d(x,c) =2\)</span> or 3 we will sometimes decode incorrectly (e.g.102 to 202), and sometime not at all (e.g. 100). So, <span class="math inline">\(P(x \;{\rm correctly  \; decoded}) = P( d(x,c) = 0 \;{\rm or}\; 1)\)</span>. Thus, for <span class="math inline">\(p=1/4\)</span>, <span class="math inline">\(P(x \;{\rm correctly  \; decoded})  = \frac{27}{64} +\frac{27}{64} = \frac{27}{32}\)</span>, and for <span class="math inline">\(p=1/2\)</span> this is <span class="math inline">\(\frac{1}{8} +  \frac{3}{8} = \frac{1}{2}\)</span>.</p>
<p>How does this compare to using the trivial (1, 3, 1) code <span class="math inline">\(C_0 = \{0,1,2\}\)</span>? Here we simply send one symbol and the chance of it being received correctly is <span class="math inline">\(1-p\)</span>. For <span class="math inline">\(p=1/4\)</span>, <span class="math inline">\(\frac{27}{32} &gt; \frac{3}{4}\)</span>, so <span class="math inline">\(C\)</span> with nearest-neighbour decoding is a little more reliable than <span class="math inline">\(C_0\)</span>. But for <span class="math inline">\(p= 1/2\)</span> we gain nothing.</p>
</div>
<p>Both Proposition <a href="#prop:receivedgivensentprobability" data-reference-type="ref" data-reference="prop:receivedgivensentprobability">[prop:receivedgivensentprobability]</a> and Corollary <a href="#cor:receivedwordlikelyneighbour" data-reference-type="ref" data-reference="cor:receivedwordlikelyneighbour">[cor:receivedwordlikelyneighbour]</a> are from the sender’s point of view: they assume we know which codeword <span class="math inline">\(c\)</span> was sent, and tell us about <span class="math inline">\(P(x \;{\rm received}\;|\;c \;\rm{sent})\)</span> for different possible <span class="math inline">\(x\)</span>s. But the receivers know only that word <span class="math inline">\(x\)</span> has arrived. What <span><em>they</em></span> want to know is, which word is most likely to have been sent? They must compare, for all codewords <span class="math inline">\(c\)</span>, <span class="math inline">\(P(c \;{\rm sent}\;|\;x \;{\rm received})\)</span>. The following proposition, closely related to Cor. 1.4, may seem obvious. To prove it, we use Bayes’ theorem, which allows us to ‘reverse’ the conditional probabilities.</p>
<div id="prop:nearestneighbourslikely" class="proposition">
<p>Suppose that a <span class="math inline">\(q\)</span>-ary <span class="math inline">\((n,M,d)\)</span> code <span class="math inline">\(C\)</span> is sent over a <span class="math inline">\(q\)</span>-ary symmetric channel with symbol-error probability <span class="math inline">\(p\)</span>, where <span class="math inline">\(p &lt; (q-1)/q\)</span>, and each codeword <span class="math inline">\(c \in C\)</span> is equally likely to be sent. Then for any word <span class="math inline">\(x\)</span> received, <span class="math inline">\(P(c \;{\rm sent}\;|\;x \;{\rm received})\)</span> increases as <span class="math inline">\(d(x,c)\)</span> decreases.</p>
</div>
<div class="proof">
<p><span class="math display">\[\begin{aligned}
			P(c \;{\rm sent}\;|\;x \;{\rm received})
			&amp; = \frac{P(c \;{\rm sent \; and }\;x \;{\rm received})}{P(x \;{\rm received})}\\
			&amp; = \frac{P(c \; {\rm sent})P(x \;{\rm received}\;|\;c \;{\rm sent})}{P(x \;{\rm received})}\\
			&amp;= \frac{P(x \;{\rm received}\;|\;c \;{\rm sent})}{M \cdot P(x \;{\rm received})},
		\end{aligned}\]</span> since we assumed that for any <span class="math inline">\(c \in C\)</span>, <span class="math inline">\(P(c \; {\rm sent})= 1/M\)</span>.</p>
<p>Also, by the law of total probability (also known as the partition theorem), if <span class="math inline">\(C= \{c_1, c_2, \ldots,c_M\}\)</span>, then <span class="math inline">\(P(x \;{\rm received}) = 
 \sum_{i=1}^M P(c_i \; {\rm sent})P(x \;{\rm received}\;|\;c_i \;{\rm sent})\)</span>. This is independent of the <span class="math inline">\(c\)</span> which was sent, since we sum over all possible sent codewords.</p>
<p>Now the receiver knows <span class="math inline">\(x\)</span>, and is considering different possible <span class="math inline">\(c\)</span>’s. But in <span class="math display">\[P(c \;{\rm sent}\;|\;x \;{\rm received}) = \frac{P(x \;{\rm received}\;|\;c \;{\rm sent})}{M \cdot P(x \;{\rm received})},\]</span> the denominator is independent of <span class="math inline">\(c\)</span>. Hence <span class="math inline">\(P(c \;{\rm sent}\;|\;x \;{\rm received})\)</span> increases as <span class="math inline">\(P(x \;{\rm received}\;|\;c \;{\rm sent})\)</span> increases; that is, by Cor. 1.4, as <span class="math inline">\(d(x,c)\)</span> decreases.</p>
</div>
<p>So the nearest neighbours of <span class="math inline">\(x\)</span> are indeed the most likely codewords to have been sent. If we have the conditions described in Proposition <a href="#prop:nearestneighbourslikely" data-reference-type="ref" data-reference="prop:nearestneighbourslikely">[prop:nearestneighbourslikely]</a>, we are justified in using nearest-neighbour decoding.</p>
<p>(The assumption that each codeword is equally likely to be sent is important. If this were not the case, it would obviously affect our conclusions. This is like the well-known problem in medical testing for rare diseases, when a false positive may be more likely than an actual case.)</p>
</section>
<section id="sec:boundsoncodes" class="level2" data-number="1.4">
<h2 data-number="1.4"><span class="header-section-number">1.4</span> Bounds on Codes</h2>
<p>What makes a good <span class="math inline">\((n,M,d)\)</span> code? Small <span class="math inline">\(n\)</span> will make transmission faster. Large <span class="math inline">\(M\)</span> will provide many words, to convey many different messages. Large <span class="math inline">\(d\)</span> will allow us to detect and correct more symbol-errors, and so make communication more reliable. But these parameters are related, so we have to make trade-offs. The following is known as the <span><strong>Singleton Bound</strong></span>.</p>
<div class="proposition">
<p>For a <span class="math inline">\(q\)</span>-ary (n,M,d) code, we have <span class="math inline">\(M\leq q^{n-d+1}\)</span>.</p>
</div>
<p>Thus, for fixed <span class="math inline">\(q\)</span>, small <span class="math inline">\(n\)</span> and large <span class="math inline">\(d\)</span> will make <span class="math inline">\(M\)</span> small. This makes sense intuitively: small <span class="math inline">\(n\)</span> makes the space of possible words small, and large <span class="math inline">\(d\)</span> makes the codewords far apart. So we can’t fit in very many of them! The proof involves a ‘projection’ map which simply ‘forgets’ the last <span class="math inline">\(d-1\)</span> symbols of the codeword. (You draw the picture.)</p>
<div class="proof">
<p>Let <span class="math inline">\(C \subseteq A^n\)</span>, where <span class="math inline">\(|A|=q\)</span>. For <span class="math inline">\(d=1\)</span> the proposition is trivial. For <span class="math inline">\(d&gt;1\)</span>, define a map <span class="math inline">\(f:A^n \rightarrow A^{n-d+1}\)</span> by <span class="math inline">\(f(a_1a_2\ldots a_n) =  a_1a_2\ldots a_{n-d+1}\)</span>. Clearly <span class="math inline">\(f\)</span> is not injective on <span class="math inline">\(A^n\)</span>: if two words <span class="math inline">\(x\)</span> and <span class="math inline">\(y\)</span> differ only in the last position, then <span class="math inline">\(f(x) = f(y)\)</span>. But if <span class="math inline">\(x\)</span> and <span class="math inline">\(y\)</span> are distinct codewords in <span class="math inline">\(C\)</span>, they must differ in <span class="math inline">\(\geq d\)</span> positions. So <span class="math inline">\(f\)</span> cannot ‘forget’ all these differences, so <span class="math inline">\(f(x) \neq f(y)\)</span>. Thus <span class="math inline">\(f\)</span> is injective on <span class="math inline">\(C\)</span>, and it follows that <span class="math inline">\(|f(C)| = |C|\)</span>. But <span class="math inline">\(f(C) \subseteq A^{n-d+1}\)</span>, so <span class="math display">\[M =|C|= |f(C)|\leq |A^{n-d+1}| = q^{n-d+1}\]</span> as required.</p>
</div>
<p>A code which saturates the Singleton bound is known as <em>Maximum Distance Separable</em> or MDS.</p>
<div id="eg:MDSbinaryrepatition" class="exampleqed">
<p> Let <span class="math inline">\(C_n\)</span> be the ‘binary repetition code’ of block length <span class="math inline">\(n\)</span>, <span class="math display">\[C_n := \{ \overbrace{00\ldots0}^n, \overbrace{11\ldots1}^n \} \subset \{0,1\}^n.\]</span></p>
<p><span class="math inline">\(C_n\)</span> is a <span class="math inline">\((n,2,n)_2\)</span> code, and since <span class="math inline">\(2 = 2^{n-n+1}\)</span>, <span class="math inline">\(C_n\)</span> is an MDS code.</p>
</div>
<div class="definition">
<p>Let <span class="math inline">\(A\)</span> be an alphabet, <span class="math inline">\(|A| = q\)</span>. Let <span class="math inline">\(n\geq 1\)</span> and <span class="math inline">\(0 \leq t \leq n\)</span> be integers, and <span class="math inline">\(x\)</span> a word in <span class="math inline">\(A^n\)</span>. Then</p>
<ul>
<li><p>The <span><strong>sphere of radius <span class="math inline">\(t\)</span> around <span class="math inline">\(x\)</span></strong></span> is <span class="math inline">\(S(x,t) = \{y \in A^n \;|\; d(y,x) \leq t \}\)</span>.</p></li>
<li><p>A code <span class="math inline">\(C \subseteq A^n\)</span> is <span><strong>perfect</strong></span> if there is some <span class="math inline">\(t\)</span> such that <span class="math inline">\(A^n\)</span> is the disjoint union of all the <span class="math inline">\(S(c,t)\)</span> as <span class="math inline">\(c\)</span> runs through <span class="math inline">\(C\)</span>.</p></li>
</ul>
</div>
<p>Because of the ‘ <span class="math inline">\(\leq\)</span>’, <span class="math inline">\(S(c,t)\)</span> is like a solid ball around <span class="math inline">\(c\)</span>, not just the surface of a sphere. (Of course, we use the Hamming distance, not ordinary Euclidean distance.) In a perfect code, the <span class="math inline">\(S(c,t)\)</span> partition <span class="math inline">\(A^n\)</span>. Thus any word <span class="math inline">\(x \in A^n\)</span> is in exactly one <span class="math inline">\(S(c,t)\)</span>, and that <span class="math inline">\(c\)</span> is <span class="math inline">\(x\)</span>’s unique nearest neighbour.</p>
<div class="exampleqed">
<p>For <span class="math inline">\(C_1 = \{000, 111\} \subseteq  \{0,1\}^3\)</span>, we have <span class="math inline">\(S(000,1) = \{ 000, 100, 010, 001\}\)</span> and <span class="math inline">\(S(111,1) = \{ 111, 011, 101, 110\}\)</span>. These are disjoint, and <span class="math inline">\(S(000,1) \cup S(111,1) =  \{0,1\}^3\)</span>. So <span class="math inline">\(C_1\)</span> is perfect. (You should draw a picture, with the words of <span class="math inline">\(A^n\)</span> labelling the vertices of a cube in the obvious way. Or even better, make a model.)</p>
</div>
<div class="exampleqed">
<p>Let <span class="math inline">\(C_2 = \{ 111, 020, 202\} \subseteq  \{0,1,2\}^3\)</span>. Then, for example, <span class="math inline">\(S(111,1) = \{111, 110, 112, 101, 121, 011, 211\}\)</span>. Is <span class="math inline">\(C_2\)</span> perfect? No, because for all <span class="math inline">\(c \in C\)</span>, we have <span class="math inline">\(d(c,012) = 2\)</span>. So 012 is not in any <span class="math inline">\(S(c,1)\)</span>, but is in every <span class="math inline">\(S(c,2)\)</span>. Thus for <span class="math inline">\(t = 0\)</span> or 1 the <span class="math inline">\(S(c,t)\)</span> do not cover all of <span class="math inline">\(\{0,1,2\}^3\)</span>, and for <span class="math inline">\(t= 2\)</span> or 3 they are not disjoint.</p>
</div>
<p>To decide whether a code is perfect or not, we may not need to consider the actual codewords. We can look first at the sizes of spheres in the space. As we would expect, the size of a sphere in <span class="math inline">\(A^n\)</span> depends only on its ‘radius’, <span class="math inline">\(t\)</span>, not on its centre.</p>
<div class="lemma">
<p>If <span class="math inline">\(|A| = q\)</span>, <span class="math inline">\(n\geq 1\)</span>, and <span class="math inline">\(x \in A^n\)</span>, then <span class="math display">\[|S(x,t)| 
%%   =  1+ n(q-1) + \binom{n}{2}(q-1)^2 + \cdots + \binom{n}{t}(q-1)^t 
= \sum_{k=0}^t\binom{n}{k} (q-1)^k.\]</span></p>
</div>
<div class="proof">
<p>How many <span class="math inline">\(y \in A^n\)</span> have <span class="math inline">\(d(x,y) = k\)</span>? To make such a <span class="math inline">\(y\)</span> from <span class="math inline">\(x\)</span>, we must first choose <span class="math inline">\(k\)</span> positions to change: <span class="math inline">\(\binom{n}{k}\)</span> ways to do this. Then for each chosen position, we choose one of the <span class="math inline">\(q-1\)</span> other symbols: <span class="math inline">\((q-1)^k\)</span> ways. So there are <span class="math inline">\(\binom{n}{k}(q-1)^k\)</span> such <span class="math inline">\(y\)</span>. Now we build up the sphere in layers, by letting <span class="math inline">\(k\)</span> go from 0 to <span class="math inline">\(t\)</span>.</p>
</div>
<div class="exampleqed">
<p>For the code <span class="math inline">\(C_2\)</span> above, we have, <span class="math inline">\(q=3\)</span>, <span class="math inline">\(n=3\)</span>. So <span class="math inline">\(|S(x, 1)| = \binom{3}{0} + \binom{3}{1}(3-1) = 1+6 = 7\)</span> , as we saw, and <span class="math inline">\(|S(x, 2)| = \binom{3}{0} + \binom{3}{1}(3-1) + \binom{3}{2}(3-1)^2 = 1+6+12 = 19\)</span>. Since <span class="math inline">\(|\{0,1,2\}^3|=27\)</span>, and neither 7 nor 19 divides 27, clearly this space cannot be partitioned by spheres of either size. Three spheres containing 7 words each cannot fill the space, and three containing 19 must overlap, just as we saw by considering the word 012.</p>
<p>Of course, <span class="math inline">\(|S(x, 3)|=27\)</span>, and <span class="math inline">\(|S(x, 0)|\)</span> is always 1, and these do divide 27. But to use these spheres to make a perfect code, we would have to have, respectively, just one codeword, or <span class="math inline">\(C = A^n\)</span>. These ‘trivial’ codes are no use to us.</p>
</div>
<p>We can use spheres to give us another bound on the size of a code. This is known as the <span><strong>Hamming Bound</strong></span> or the <span><strong>Sphere-packing Bound</strong></span>:</p>
<div id="prop:hammingbound" class="proposition">
<p>A <span class="math inline">\(q\)</span>-ary <span class="math inline">\((n,M,d)\)</span> code satisfies: <span class="math display">\[M \cdot \sum_{k=0}^t\binom{n}{k} (q-1)^k  \leq q^n, \;\; {\rm where} \; t = \left\lfloor\frac{d-1}{2}\right\rfloor.\]</span></p>
</div>
<p>Notice that we are relating the radius of the sphere to the minimum distance of the code; in fact, we must have <span class="math inline">\(d = 2t+1\)</span> or <span class="math inline">\(2t+2\)</span>. The first part of the proof is really the same as that of the second part of Proposition <a href="#prop:correctdetect" data-reference-type="ref" data-reference="prop:correctdetect">[prop:correctdetect]</a>. The notation is different, but the picture is the same.</p>
<div class="proof">
<p>Let the code be <span class="math inline">\(C \subseteq A^n\)</span>. First we must show that the <span class="math inline">\(S(c,t)\)</span> for codewords <span class="math inline">\(c \in C\)</span> are disjoint. Suppose not, so there is some <span class="math inline">\(x \in A^n\)</span> such that <span class="math inline">\(x \in S(c_1,t)\)</span> and <span class="math inline">\(x \in S(c_2,t)\)</span>, where <span class="math inline">\(c_1 \neq c_2\)</span>. This means that <span class="math inline">\(d(x,c_1)\)</span> and <span class="math inline">\(d(x,c_2)\)</span> are both <span class="math inline">\(\leq t\)</span>. So by the triangle inequality we have <span class="math inline">\(d(c_1,c_2) \leq d(x,c_1) +d(x,c_2) \leq 2t\)</span>. But this contradicts <span class="math inline">\(d(c_1,c_2) \geq d(C) \geq 2t+1\)</span>.</p>
<p>Now <span class="math display">\[\bigcup_{c \in C} S(c,t) \subseteq A^n, \;\; {\rm so}\;\; \left|\bigcup_{c \in C} S(c,t)\right| \leq q^n.\]</span> But since the <span class="math inline">\(S(c,t)\)</span> are disjoint, we have <span class="math display">\[\left|\bigcup_{c \in C} S(c,t)\right| = \sum_{c \in C} |S(c,t)| = M|S(c,t)|.\]</span> Thus <span class="math inline">\(M|S(c,t)|\leq q^n\)</span>, which by Lemma 1.7 proves the proposition.</p>
</div>
<p>We have equality in the Hamming Bound if and only if the code is perfect; in this case the spheres <span class="math inline">\(S(c,t)\)</span>, which are as large as they can be without overlapping, will fill <span class="math inline">\(A^n\)</span>. Thus for a perfect code, <span class="math inline">\(M\)</span> must divide <span class="math inline">\(q^n\)</span>, and so must <span class="math inline">\(|S(c,t)| = \sum_{k=0}^t\binom{n}{k} (q-1)^k\)</span> for some <span class="math inline">\(t\)</span>. We used this idea in the example above. It is also not hard to show that a perfect code must have <span class="math inline">\(d\)</span> odd (see Q16).</p>
</section>
</section>
<section id="cha:linearcodes" class="level1" data-number="2">
<h1 data-number="2"><span class="header-section-number">2</span> Linear Codes</h1>
<p>In Chapter 1, we used <span class="math inline">\(0, 1, 2, \ldots\)</span> purely as symbols in an alphabet <span class="math inline">\(A\)</span>, and our code could be any subset of <span class="math inline">\(A^n\)</span>. To make progress we now want to do arithmetic with our symbols, so our alphabet must be a field <span class="math inline">\(F\)</span>. Then we can regard our words in <span class="math inline">\(A^n\)</span> as vectors in <span class="math inline">\(F^n\)</span>, which is a vector space over <span class="math inline">\(F\)</span>. Moreover, we shall require that our code <span class="math inline">\(C\)</span> is a subspace of <span class="math inline">\(F^n\)</span>.</p>
<section id="sec:finitefields" class="level2" data-number="2.1">
<h2 data-number="2.1"><span class="header-section-number">2.1</span> Finite Fields</h2>
<p>A field is a set with two binary operations, which obey the standard rules of arithmetic.</p>
<div class="definition">
<p>A non-empty set <span class="math inline">\(F\)</span> with addition <span class="math inline">\(F \times F \rightarrow F\)</span>, mapping <span class="math inline">\((a,b)\)</span> to <span class="math inline">\(a+b\)</span>, and multiplication <span class="math inline">\(F \times F \rightarrow F\)</span>, mapping <span class="math inline">\((a,b)\)</span> to <span class="math inline">\(ab\)</span>, is called a <span><strong>field</strong></span> if the following axioms hold.</p>
<ul>
<li><p>Associativity of addition: For every <span class="math inline">\(a\)</span>, <span class="math inline">\(b\)</span>, and <span class="math inline">\(c\)</span> in <span class="math inline">\(F\)</span>, <span class="math inline">\((a+b)+c = a+(b+c)\)</span></p></li>
<li><p>Additive identity: There exists 0 in <span class="math inline">\(F\)</span> such that for every <span class="math inline">\(a \in F\)</span>, <span class="math inline">\(a+0 = a = 0+a\)</span></p></li>
<li><p>Additive inverse: For every <span class="math inline">\(a \in F\)</span>, there exists <span class="math inline">\(b \in F\)</span> such that <span class="math inline">\(a+b = 0 = b+a\)</span></p></li>
<li><p>Commutative addition: For every <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span> in <span class="math inline">\(F\)</span>, <span class="math inline">\(a+b = b+a\)</span></p></li>
<li><p>Associativity of multiplication: For every <span class="math inline">\(a\)</span>, <span class="math inline">\(b\)</span>, and <span class="math inline">\(c\)</span> in <span class="math inline">\(F\)</span>, <span class="math inline">\((a\cdot b)\cdot c = a\cdot (b\cdot c)\)</span></p></li>
<li><p>Multiplicative identity: There exists 1 in <span class="math inline">\(F\)</span> such that, for every <span class="math inline">\(a \in F\)</span>, <span class="math inline">\(1\cdot a = a = a \cdot 1\)</span></p></li>
<li><p>Multiplicative inverse: For every <span class="math inline">\(a \in F\)</span>, <span class="math inline">\(a \neq 0\)</span>, there exists <span class="math inline">\(b \in F\)</span> such that <span class="math inline">\(a\cdot b = 1 = b \cdot a\)</span></p></li>
<li><p>Commutative multiplication: For every <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span> in <span class="math inline">\(F\)</span>, <span class="math inline">\(a \cdot b =b \cdot a\)</span></p></li>
<li><p>Distributivity: For every <span class="math inline">\(a\)</span>, <span class="math inline">\(b\)</span>, and <span class="math inline">\(c\)</span> in <span class="math inline">\(F\)</span>, <span class="math inline">\((a+b)\cdot c = a\cdot c + b\cdot c\)</span> and <span class="math inline">\(a\cdot (b+c) = a\cdot b + a\cdot c\)</span></p></li>
<li><p>Multiplicative and additive inverses are different: <span class="math inline">\(0 \neq 1\)</span></p></li>
</ul>
</div>
<p>Axioms i - iv make <span class="math inline">\((F, +)\)</span> into an abelian (or commutative) group; axioms v - viii make <span class="math inline">\((F-\{0\}, \cdot)\)</span> into another abelian group; axioms i - vi &amp; ix make <span class="math inline">\((F,+,\cdot)\)</span> a ring. Note that the definitions of addition and multiplication as maps <span class="math inline">\(F \times F \rightarrow F\)</span> imply that these operations are closed. It is easy to show that the identities 0 and 1 are unique, and that for each <span class="math inline">\(a \in F\)</span>, the additive inverse <span class="math inline">\(-a\)</span> and the multiplicative inverse <span class="math inline">\(a^{-1}\)</span> are unique. We also have some convenient notations: for <span class="math inline">\(m\)</span> a non-negative integer, we write <span class="math inline">\(m\cdot a\)</span> for adding, and <span class="math inline">\(a^m\)</span> for multiplying, <span class="math inline">\(m\)</span> copies of <span class="math inline">\(a\)</span>. It’s all very familiar.</p>
<p>However, the fields you know best are the reals <span class="math inline">\({\mathbb R}\)</span>, the complex numbers <span class="math inline">\({\mathbb C}\)</span>, and the rationals <span class="math inline">\({\mathbb Q}\)</span>, and these are no good as alphabets, because they are infinite.</p>
<p>To find finite fields, we start from arithmetic modulo <span class="math inline">\(n\)</span>. Here the set <span class="math inline">\({\mathbb Z}/n\)</span> (or <span class="math inline">\({\mathbb Z}_n\)</span>, or <span class="math inline">\({\mathbb Z}/n{\mathbb Z}\)</span>) is the congruence classes <span class="math inline">\(\{[0]_n, [1]_n,\ldots,[n-1]_n\}\)</span> (or <span class="math inline">\(\{\overline{0}, \overline{1},\ldots,\overline{n-1}\}\)</span>), and we add or multiply by using any representative of that class. It is easy to check that every axiom except for vii will hold for any <span class="math inline">\(n\)</span>. But vii holds (that is, <span class="math inline">\({\mathbb Z}/n\)</span> has multiplicative inverses for all non-zero elements) if and only if <span class="math inline">\(n\)</span> is prime.</p>
<p>For <span class="math inline">\(n\)</span> prime we have a field, and to make this clear (and also to be able to use <span class="math inline">\(n\)</span> for block-length, as in Chapter <a href="#cha:basiccodingtheory" data-reference-type="ref" data-reference="cha:basiccodingtheory">1</a>) we shall write <span class="math inline">\({\mathbb F}_p\)</span> instead of <span class="math inline">\({\mathbb Z}/n\)</span>. Once we have specified <span class="math inline">\(p\)</span>, we can write simply <span class="math inline">\(0, 1, 2,\ldots p-1\)</span> rather than <span class="math inline">\([0]_p, [1]_p,\ldots,[p-1]_p\)</span> (or <span class="math inline">\(\overline{0}, \overline{1},\ldots,\overline{p-1}\)</span>).</p>
<p>Are there finite fields with a non-prime number <span class="math inline">\(q\)</span> of elements? The answer is yes if and only if <span class="math inline">\(q\)</span> is a prime power, <span class="math inline">\(q = p^r, r \in {\mathbb Z}_+\)</span>. But of course <span class="math inline">\({\mathbb F}_{3^2} = {\mathbb F}_9 \neq {\mathbb Z}/9\)</span>, because <span class="math inline">\({\mathbb Z}/9\)</span> is not a field. We shall construct and use such non-prime fields <span class="math inline">\({\mathbb F}_q\)</span> in Chapter <a href="#cha:polynomialsandcodes" data-reference-type="ref" data-reference="cha:polynomialsandcodes">6</a>.</p>
<p>The notation <span class="math inline">\({\mathbb F}_q\)</span> is justified, because it can be shown that any two fields with the same number of elements are isomorphic. For general statements we shall call our field <span class="math inline">\({\mathbb F}_q\)</span>, but <span><em>until we reach Chapter <a href="#cha:polynomialsandcodes" data-reference-type="ref" data-reference="cha:polynomialsandcodes">6</a> <span class="math inline">\(q\)</span> will always be prime</em></span> (that is, <span class="math inline">\(r = 1\)</span>). This allows us to keep ‘<span class="math inline">\(p\)</span>’ for the symbol-error probability.</p>
</section>
<section id="finite-vector-spaces" class="level2" data-number="2.2">
<h2 data-number="2.2"><span class="header-section-number">2.2</span> Finite Vector Spaces</h2>
<p>Just as <span class="math inline">\({\mathbb R}^n\)</span> is a vector space over <span class="math inline">\({\mathbb R}\)</span>, <span class="math inline">\({\mathbb F}_q^n =({\mathbb F}_q)^n\)</span> is a vector space over <span class="math inline">\({\mathbb F}_q\)</span>. Everything you have learned about vector spaces (and most of your ideas about <span class="math inline">\({\mathbb R}^n\)</span>) will still work. These notes gives only a quick, informal reminder of the main definitions and ideas from linear algebra which we shall use. Formal definitions, results and examples will be written in terms of finite fields, and spaces and codes over them. The main difference is that we can now count the vectors in a space: to start with, <span class="math inline">\(|{\mathbb F}_q^n|= q^n\)</span>. We can even write a complete list of them.</p>
<p>We shall still sometimes call our vectors ‘words’, and some of them will be our codewords. Because words (in English) are horizontal, we will usually write vectors as rows (rather than columns): <span class="math inline">\({\bf x} = (x_1, x_2, \ldots,x_n) \in {\mathbb F}_q^n\)</span>, where the <span class="math inline">\(x_i\)</span> are in <span class="math inline">\({\mathbb F}_q\)</span>. You need to know which field <span class="math inline">\({\mathbb F}_q\)</span> you are working over, because all arithmetic must be done mod <span class="math inline">\(q\)</span>.</p>
<div class="exampleqed">
<p>The vectors <span class="math inline">\({\bf x} = (0,1,2,0)\)</span> and <span class="math inline">\({\bf y} = (1,1,1,1)\)</span> could be vectors in <span class="math inline">\({\mathbb F}_3^4\)</span>, but they could also be vectors in <span class="math inline">\({\mathbb F}_7^4\)</span>. In <span class="math inline">\({\mathbb F}_3^4\)</span>, we would have <span class="math inline">\({\bf x} + {\bf y} = (1, 2, 0, 1)\)</span>, and <span class="math inline">\(2{\bf x} = (0,2,1,0)\)</span>. But in <span class="math inline">\({\mathbb F}_7^4\)</span>, it would be <span class="math inline">\({\bf x} + {\bf y} = (1, 2, 3, 1)\)</span>, <span class="math inline">\(2{\bf x} = (0,2,4,0)\)</span> and <span class="math inline">\(4{\bf x} = (0,4,1,0)\)</span>.</p>
</div>
<p>In Chapter 1, a code could be any subset of <span class="math inline">\(A^n\)</span>. But we now make a more restrictive definition.</p>
<div class="definition">
<p>A <span><strong>linear code</strong></span> is a subspace of the vector space <span class="math inline">\({\mathbb F}_q^n\)</span>, for some finite field <span class="math inline">\({\mathbb F}_q\)</span> and non-negative integer <span class="math inline">\(n\)</span>.</p>
</div>
<p>Recall that a <span><strong>subspace</strong></span> of a vector space is a subset which is closed under vector addition and scalar multiplication. Thus, if we are given a subset of <span class="math inline">\({\mathbb F}_q^n\)</span> as a list, it is straightforward (if tedious) to check whether it is a linear code or not.</p>
<div class="exampleqed">
<p>Let <span class="math inline">\({\bf x} = (0,1,2,0)\)</span>, and <span class="math inline">\({\bf y} = (1,1,1,1,)\)</span>, <span class="math inline">\({\bf z} = (0,2,1,0)\)</span> and <span class="math inline">\({\bf 0} = (0,0,0,0)\)</span> be vectors in <span class="math inline">\({\mathbb F}_3^4\)</span>. Then <span class="math inline">\(C_1 = \{{\bf x},{\bf y}\}\)</span> is not a linear code since <span class="math inline">\({\bf x}+{\bf y} = (1,2,0,1)\not\in C_1\)</span>. But <span class="math inline">\(C_2 = \{{\bf x},{\bf z},{\bf 0}\}\)</span> is a linear code, as adding any combination of these vectors (which also includes multiplying them by 0, 1 or 2) gives one of them.</p>
</div>
<p>If the subset S is not closed, we can keep adding in vectors as necessary until it is. The resulting space is the <span><strong>span</strong></span> of the set, written <span class="math inline">\(\langle S \rangle\)</span>, and is by construction a linear code.</p>
<div class="exampleqed">
<p>The span of <span class="math inline">\(C_1\)</span> is the linear code <span class="math inline">\(C_3 =\langle C_1 \rangle 
= \langle\{{\bf x},{\bf y}\}\rangle =\)</span> <span class="math display">\[\{(0,0,0,0), (0,1,2,0),  (0,2,1,0),
  (1,1,1,1),  (1,2,0,1), (1,0,2,1), 
  (2,2,2,2),  (2,0,1,2), (2,1,0,2) \}.\]</span></p>
<p>We could also notice that <span class="math inline">\(C_2 = \{0{\bf x},1{\bf x},2{\bf x}\} = \langle\{{\bf x}\}\rangle\)</span>, so in fact <span class="math inline">\(\langle C_2 \rangle = C_2\)</span>.</p>
</div>
<p>If <span class="math inline">\(\langle S \rangle = C\)</span> then we say <span class="math inline">\(S\)</span> is a <span><strong>spanning set</strong></span> for <span class="math inline">\(C\)</span>. There are usually many possible spanning set for a subspace.</p>
<p>A set of vectors <span class="math inline">\(S = \{ {\bf x_1}, {\bf x_2}, \ldots {\bf x_k}\}\)</span> in <span class="math inline">\({\mathbb F}_q^n\)</span> is <span><strong>linearly independent</strong></span> if and only if no non-trivial linear combination of them equals the zero-vector <span class="math inline">\({\bf 0}\)</span>; that is, for <span class="math inline">\(\lambda_i \in {\mathbb F}_q\)</span>, iff:</p>
<p><span class="math display">\[\lambda_1{\bf x_1} +\lambda_2{\bf x_2} + \ldots +\lambda_k{\bf x_k} = {\bf 0} \;\; \Longrightarrow \;\; \lambda_1 =
\lambda_2 = \ldots =\lambda_k = 0.\]</span></p>
<p>A linearly independent spanning set for a linear code <span class="math inline">\(C\)</span> is a <span><strong>basis</strong></span> for <span class="math inline">\(C\)</span>. While there may still be many possible bases, these will all have the same number of vectors, and this number is the <span><strong>dimension</strong></span> of <span class="math inline">\(C\)</span>, written dim(<span class="math inline">\(C\)</span>).</p>
<div class="exampleqed">
<p>The spanning sets of the code listed above, <span class="math inline">\(C_3 \subseteq {\mathbb F}_3^4\)</span>, include <span class="math inline">\(S_1 =\{(0,1,2,0),(1,1,1,1)\}\)</span>, <span class="math inline">\(S_2 =\{(0,1,2,0),(2,2,2,2)\}\)</span>, and <span class="math inline">\(S_3 =\{(0,1,2,0),(1,1,1,1),(2,0,1,2)\}\)</span>.</p>
<p><span class="math inline">\(S_3\)</span> is not a basis, because <span class="math inline">\(1(0,1,2,0)+ 2(1,1,1,1)+ 2(2,0,1,2) = (6,3,6,6)=(0,0,0,0)\)</span>. But both <span class="math inline">\(S_1\)</span> and <span class="math inline">\(S_2\)</span> are linearly independent sets, and thus bases for <span class="math inline">\(C_3\)</span>. So dim<span class="math inline">\((C_3) =2\)</span>.</p>
<p>To prove the linear independence of <span class="math inline">\(S_1\)</span>, we can note that if <span class="math inline">\(\lambda_1(0,1,2,0)+ \lambda_2(1,1,1,1) = (0,0,0,0)\)</span>, then by the first position <span class="math inline">\(\lambda_2 = 0\)</span>, and so then by the second position <span class="math inline">\(\lambda_1 = 0\)</span> also.</p>
</div>
<div class="exampleqed">
<p>For the whole space <span class="math inline">\({\mathbb F}_q^n\)</span>, the ‘standard basis’ is <span class="math inline">\(B = \{ {\bf e_1}, {\bf e_2}, \ldots {\bf e_k}\}\)</span>, where <span class="math inline">\(e_i\)</span> has 1 in the <span class="math inline">\(i^{th}\)</span> position and 0 elsewhere.</p>
</div>
<p>A basis <span class="math inline">\(B\)</span> for a linear code <span class="math inline">\(C\)</span> is “just right" for making every vector <span class="math inline">\({\bf c} \in C\)</span> as a linear combination of vectors from <span class="math inline">\(B\)</span>: a spanning set can make each <span class="math inline">\({\bf c}\)</span> <span><em>at least</em></span> one way, a linearly independent set can make each <span class="math inline">\({\bf c}\)</span> <span><em>at most</em></span> one way, but a basis can make each <span class="math inline">\({\bf c}\)</span> <span><em>exactly</em></span> one way. We use this property to prove the following:</p>
<div id="prop:dimlincode" class="proposition">
<p> If a linear code <span class="math inline">\(C \subseteq {\mathbb F}_q^n\)</span> has dimension <span class="math inline">\(k\)</span>, then <span class="math inline">\(|C| = q^k\)</span>.</p>
</div>
<div class="proof">
<p>Let <span class="math inline">\(B = \{ {\bf x_1}, {\bf x_2}, \ldots {\bf x_k}\}\)</span> be any basis for <span class="math inline">\(C\)</span>. There is a one-to-one correspondence between codewords <span class="math inline">\({\bf c} \in C\)</span> and linear combinations <span class="math inline">\(\lambda_1{\bf x_1} +\lambda_2{\bf x_2} + \ldots +\lambda_k{\bf x_k}\)</span>, with <span class="math inline">\(\lambda_i \in {\mathbb F}_q\)</span>. Each <span class="math inline">\(\lambda_i\)</span> can take any of <span class="math inline">\(q\)</span> values.</p>
</div>
<div class="exampleqed">
<p>For <span class="math inline">\(C_3 \subseteq {\mathbb F}_3^4\)</span> listed above, dim<span class="math inline">\((C_3)=2\)</span>, and <span class="math inline">\(|C_3| = 9 = 3^2\)</span>.</p>
</div>
<p>We can now update our <span class="math inline">\((n, M, d)\)</span> notation for the parameters of a code:</p>
<div class="definition">
<p>A <span class="math inline">\(q\)</span>-ary <span class="math inline">\([n,k,d]\)</span> code is a linear code, a subspace of <span class="math inline">\({\mathbb F}_q^n\)</span> of dimension <span class="math inline">\(k\)</span> with minimum distance <span class="math inline">\(d\)</span>.</p>
</div>
<p>The square or round brackets prevent ambiguity: any <span class="math inline">\(q\)</span>-ary <span class="math inline">\([n, k, d]\)</span> code is also a <span class="math inline">\(q\)</span>-ary <span class="math inline">\((n, q^k,d)\)</span> code, but not vice-versa. From now on, almost all codes will be linear, so I will write “code" for “linear code"</p>
</section>
<section id="sec:arraydecoding" class="level2" data-number="2.3">
<h2 data-number="2.3"><span class="header-section-number">2.3</span> Array Decoding</h2>
<p>The zero element 0 plays a very special role in <span class="math inline">\({\mathbb F}_q\)</span>, and so does the zero vector <span class="math inline">\({\bf 0}\)</span> in <span class="math inline">\({\mathbb F}_q^n\)</span>. We are also interested in how many entries of a general vector <span class="math inline">\({\bf x} \in {\mathbb F}_q^n\)</span> are (or are not) zero.</p>
<div class="definition">
<p>For <span class="math inline">\({\bf x} \in {\mathbb F}_q^n\)</span>, the <span><strong>weight</strong></span> of <span class="math inline">\({\bf x}\)</span>, written <span class="math inline">\(w({\bf x})\)</span>, is the number of non-zero entries in <span class="math inline">\({\bf x}\)</span>.</p>
</div>
<p>Weights are closely related to Hamming distances. To show this, we must first define the difference between two vectors, using several properties of our vector space. Notice that by axioms vi and iii any field has a <span class="math inline">\(-1\)</span>, the additive inverse of 1. (For <span class="math inline">\(q\)</span> prime we could also write this as <span class="math inline">\(q -1\)</span>.) Then since we can multiply vectors by scalars, we can write <span class="math inline">\(-{\bf y}\)</span> for <span class="math inline">\(-1 \cdot {\bf y}\)</span>, and <span class="math inline">\({\bf x}-{\bf y}\)</span> for <span class="math inline">\({\bf x}+ (-{\bf y})\)</span>.</p>
<div class="lemma">
<p>For <span class="math inline">\({\bf x}\)</span> and <span class="math inline">\({\bf y}\)</span> in <span class="math inline">\({\mathbb F}_q^n\)</span>, we have <span class="math inline">\(d({\bf x},{\bf y}) = w({\bf x}-{\bf y})\)</span>.</p>
</div>
<div class="proof">
<p>The vector <span class="math inline">\({\bf x}- {\bf y}\)</span> has non-zero entries exactly where <span class="math inline">\({\bf x}\)</span> and <span class="math inline">\({\bf y}\)</span> differ.</p>
</div>
<p>So any Hamming distance can be written as a weight. But also, since <span class="math inline">\(w({\bf x})= w({\bf x}- {\bf 0}) = d({\bf x},{\bf 0})\)</span>, any weight can be written as a Hamming distance. This allows us to prove the following useful fact:</p>
<div id="prop:mindminw" class="proposition">
<p>For the code <span class="math inline">\(C \subseteq {\mathbb F}_q^n\)</span>, <span class="math inline">\(d(C)\)</span> is the minimum weight of any non-zero codeword in <span class="math inline">\(C\)</span>.</p>
</div>
<div class="proof">
<p>First we define two sets of non-negative integers: <span class="math display">\[W = \{ w({\bf x}) \;|\; {\bf x}\in C, {\bf x}\neq {\bf 0}\}\;\;{\rm and}
\;\; D = \{ d({\bf x},{\bf y}) \;|\; {\bf x},{\bf y}\in C, {\bf x}\neq {\bf y}\}.\]</span> Then the proposition says that min<span class="math inline">\((D) =\)</span> min<span class="math inline">\((W)\)</span>. We can show more: that <span class="math inline">\(D = W\)</span>. For any <span class="math inline">\(w({\bf x})\in W\)</span>, we know that both <span class="math inline">\({\bf x}\)</span> and <span class="math inline">\({\bf 0}\)</span> are in <span class="math inline">\(C\)</span>, so <span class="math inline">\(w({\bf x})= d({\bf x},{\bf 0}) \in D\)</span>. Conversely, for any <span class="math inline">\(d({\bf x},{\bf y}) \in D\)</span>, we know <span class="math inline">\({\bf x}\)</span> and <span class="math inline">\({\bf y}\)</span> are both in <span class="math inline">\(C\)</span>. Because <span class="math inline">\(C\)</span> is a subspace, <span class="math inline">\({\bf x}- {\bf y}\)</span> must also be in <span class="math inline">\(C\)</span>, so <span class="math inline">\(d({\bf x},{\bf y}) = w({\bf x}-{\bf y}) \in W\)</span>.</p>
</div>
<p>This proposition means that to find <span class="math inline">\(d(C)\)</span> for a linear code with <span class="math inline">\(q^k\)</span> words, we need to consider only <span class="math inline">\(q^k\)</span> weights , rather than <span class="math inline">\(\binom{q^k}{2} = \frac{q^k(q^k-1)}{2}\)</span> distances.</p>
<div class="exampleqed">
<p>For code <span class="math inline">\(C_3\)</span> listed in Section 2.2, we can see that <span class="math inline">\(d(C) = 2\)</span>, without finding <span class="math inline">\(\binom{9}{2} = 36\)</span> distances. But note that <span class="math inline">\(C_3\)</span> can also be written as <span class="math inline">\(\langle\{(1,1,1,1),(1,2,0,1)\}\rangle\)</span>; <span class="math inline">\(d(C)\)</span> is not always obvious from a basis.</p>
</div>
<p>For linear codes we have a much better way to talk about errors.</p>
<div class="definition">
<p>Suppose that a codeword <span class="math inline">\({\bf c}\in C \subseteq {\mathbb F}_q^n\)</span> is sent, and <span class="math inline">\({\bf y}\in {\mathbb F}_q^n\)</span> is received. Then the <span><strong>error-vector</strong></span> is <span class="math inline">\({\bf e}= {\bf y}- {\bf c}\)</span>.</p>
</div>
<p>We can think of the channel as adding <span class="math inline">\({\bf e}\)</span> to <span class="math inline">\({\bf c}\)</span>, and the decoding process aims to subtract it again. But of course the receiver does not know which error-vector was added, and can only choose a <span><em>likely</em></span> error-vector to subtract. Which error-vectors are likely? We know that <span class="math inline">\(d({\bf y},{\bf c}) =  w({\bf e})\)</span>; this is the number of symbol-errors which <span class="math inline">\({\bf c}\)</span> has suffered. This allows us to re-write Propositions <a href="#prop:receivedgivensentprobability" data-reference-type="ref" data-reference="prop:receivedgivensentprobability">[prop:receivedgivensentprobability]</a> and <a href="#prop:nearestneighbourslikely" data-reference-type="ref" data-reference="prop:nearestneighbourslikely">[prop:nearestneighbourslikely]</a> for linear codes.</p>
<div class="proposition">
<p>Let the code <span class="math inline">\(C\subseteq {\mathbb F}_q^n\)</span>, be sent over a <span class="math inline">\(q\)</span>-ary symmetric channel with symbol-error probability <span class="math inline">\(p\)</span>. For any <span class="math inline">\({\bf c}\in C\)</span>, <span class="math inline">\({\bf y}\in {\mathbb F}_q^n\)</span> , and <span class="math inline">\({\bf e}= {\bf y}-{\bf c}\)</span>, <span class="math display">\[P( {\bf y}\; {\rm received}\; |\; {\bf c}\; {\rm sent}) = P( {\bf e}\;{\rm added \; in \; channel})  = \left( \frac{p}{q-1}\right)^{w({\bf e})}  (1-p)^{n-w({\bf e})}.\]</span></p>
<p>If also <span class="math inline">\(p &lt; (q-1)/q\)</span>, and each codeword <span class="math inline">\(c \in C\)</span> is equally likely to be sent, then for any given <span class="math inline">\({\bf y}\)</span> <span class="math inline">\(P({\bf c}\;{\rm sent}\;|\;{\bf y}\;{\rm received})\)</span> increases as <span class="math inline">\(w({\bf e})\)</span> decreases.</p>
</div>
<p>The most likely error-vectors are those of least weight, or in other words those involving the fewest symbol-errors. So we should still use nearest-neighbour decoding: for a linear code, given a received word <span class="math inline">\({\bf y}\)</span> we must find a codeword <span class="math inline">\({\bf c}\)</span> such that <span class="math inline">\(w({\bf e}) = d({\bf y},{\bf c})\)</span> is as small as possible; as before this will be one of the most likely codewords to have been sent. We could do this by calculating <span class="math inline">\({\bf e}_i = {\bf y}-{\bf c}_i\)</span> for each <span class="math inline">\(c_i \in C\)</span>, and then comparing all the <span class="math inline">\(w({\bf e}_i)\)</span>. But it is much more efficient to make an array, as follows. (This is sometimes called a ‘Slepian’ or ‘Standard’ array.)</p>
<p><span><strong>Algorithm: Array Decoding</strong></span>Let <span class="math inline">\(C\)</span> be a code of dimension <span class="math inline">\(k\)</span> in <span class="math inline">\({\mathbb F}_q^n\)</span>. We construct an array as follows:</p>
<ol>
<li><p>Write the <span class="math inline">\(q^k\)</span> codewords as the top row, with <span class="math inline">\({\bf 0}\)</span> in the first column.</p></li>
<li><p>Consider the vectors of <span class="math inline">\({\mathbb F}_q^n\)</span> which are not yet in the array, and choose one of lowest available weight, <span class="math inline">\({\bf e}\)</span>.</p></li>
<li><p>Write <span class="math inline">\({\bf e}\)</span> into the first column, and then complete this new row by adding <span class="math inline">\({\bf e}\)</span> to each codeword in the top row.</p></li>
<li><p>If the array has <span class="math inline">\(q^{n-k}\)</span> rows, then STOP. Otherwise, go to 2.</p></li>
</ol>
<p>Now, decode any received word <span class="math inline">\({\bf y}\)</span> to the codeword at the top of its column.</p>
<div class="exampleqed">
<p>Let <span class="math inline">\(C\)</span> be the <span class="math inline">\([4, 2,2]\)</span> code <span class="math inline">\(\langle{(1,1,0,0),(0,0,1,1)}\rangle \subseteq {\mathbb F}_2^4\)</span>. Then one possible array is: <span class="math display">\[\begin{array}{c|ccc}
 (0,0,0,0) &amp; (1,1,0,0) &amp; (0,0,1,1) &amp; (1,1,1,1) \\ \hline
 (1,0,0,0) &amp; (0,1,0,0) &amp; (1,0,1,1) &amp; (0,1,1,1)  \\
 (0,0,1,0) &amp; (1,1,1,0) &amp; (0,0,0,1) &amp; (1,1,0,1)  \\
 (1,0,1,0) &amp; (0,1,1,0) &amp; (1,0,0,1) &amp; (0,1,0,1)  \\ 
\end{array}\]</span></p>
<p>This array decodes (0,0,0,1) to (0,0,1,1), and (0,1,1,0) to (1,1,0,0). In each case the word is decoded to a nearest neighbour, though this nearest neighbour is not unique.</p>
</div>
<p>For this method to be well defined, we require that every possible vector in <span class="math inline">\({\mathbb F}_q^n\)</span> appears exactly once in the array. (See Q22) We should also prove the following:</p>
<div id="prop:arraydecodingnearestneighbour" class="proposition">
<p> Array decoding is nearest-neighbour decoding.</p>
</div>
<div class="proof">
<p>Suppose that our received word <span class="math inline">\({\bf y}\)</span> is in the same row as <span class="math inline">\({\bf e}_1\)</span> in the first column, and in the same column as codeword <span class="math inline">\({\bf c}_1\)</span> in the top row. So we decode <span class="math inline">\({\bf y}\)</span> to <span class="math inline">\({\bf c}_1\)</span>; that is, we assume that error-vector <span class="math inline">\({\bf e}_1\)</span> was added in the channel, and now subtract it.</p>
<p><span class="math inline">\(\begin{array}{c|cccc}
{\bf 0} &amp;  &amp;  &amp; {\bf c}_1 &amp;  \\ \hline
   &amp;  &amp;  &amp;       &amp;   \\
 {\bf e}_1 &amp;   &amp;  &amp; {\bf y}&amp;  \\
    &amp;    &amp;   &amp;    &amp;   \\ 
\end{array}\)</span></p>
<p>We can show by contradiction that <span class="math inline">\({\bf c}_1\)</span> is a nearest neighbour of <span class="math inline">\({\bf y}\)</span>. Suppose not, that is, there is some <span class="math inline">\({\bf c}_2\)</span> such that <span class="math inline">\({\bf y}= {\bf c}_2 + {\bf e}_2\)</span>, with <span class="math inline">\(w({\bf e}_2) &lt; w({\bf e}_1)\)</span>. Then we have <span class="math inline">\({\bf c}_2 + {\bf e}_2 = {\bf y}={\bf c}_1 + {\bf e}_1\)</span>, so <span class="math inline">\({\bf e}_2 = {\bf e}_1 + ({\bf c}_1 -{\bf c}_2)\)</span>. Since <span class="math inline">\({\bf c}_1 -{\bf c}_2\)</span> must be a codeword in the top row, <span class="math inline">\({\bf e}_2\)</span> is in the same row as <span class="math inline">\({\bf e}_1\)</span>, so it is not in any row higher up. Thus when <span class="math inline">\({\bf e}_1\)</span> was picked by step 2. of the algorithm, <span class="math inline">\({\bf e}_2\)</span> was not yet in the array, it was available, so <span class="math inline">\({\bf e}_1\)</span> did not have least possible weight. Contradiction.</p>
</div>
<p>As we know, nearest-neighbour decoding does not always find the right codeword. If we use an array, what is the probability that, after transmission and array decoding, the receivers will have the correct word, the one that was sent? Effectively, decoding with an array subtracts one of the vectors <span class="math inline">\({\bf e}\)</span> in the first column from the received word <span class="math inline">\(y\)</span>. Thus decoding will be successful if and only if the channel added one of these vectors.</p>
<div class="proposition">
<p>Let <span class="math inline">\(C\)</span> be a code <span class="math inline">\(\subseteq {\mathbb F}_q^n\)</span>, sent over a <span class="math inline">\(q\)</span>-ary symmetric channel with symbol-error probability <span class="math inline">\(p\)</span>. Suppose the decoding array has <span class="math inline">\(\alpha_i\)</span> vectors of weight <span class="math inline">\(i\)</span> in its first column. Then for any codeword <span class="math inline">\(c\)</span> sent, the chance that it is successfully decoded is <span class="math display">\[\sum_{i = 0}^n\alpha_i\left( \frac{p}{q-1}\right)^i  (1-p)^{n-i}.\]</span></p>
</div>
<div class="exampleqed">
<p>For the array above, with <span class="math inline">\(q = 2\)</span>, we have <span class="math inline">\(\alpha_0 = 1,\;\alpha_1 = 2, \;\alpha_2 = 1, \;\alpha_3 = 0,\;\alpha_4 = 0\)</span>. So the chance of successful decoding is <span class="math inline">\((1-p)^4 +2 p(1-p)^3 + p^2((1-p)^2\)</span>.</p>
</div>
<div class="proof">
<p>The chance of successful decoding is the chance that one of the error-vectors in the first column occurred; since these are disjoint possibilities, we add their individual probabilities. (We include the zero error-vector - that is, the possibility that the codeword is received correctly.)</p>
</div>
<p>Steps 1 and 2 of the algorithm involve choice, so that many different arrays could be made for the same code. In general, some of these arrays would decode some received words differently. However, for a perfect code, all arrays will perform identical decoding. These ideas are explored in more detail in the homework (Q25-27).</p>
</section>
</section>
<section id="cha:codesasimages" class="level1" data-number="3">
<h1 data-number="3"><span class="header-section-number">3</span> Codes as Images</h1>
<p>So far we have only two ways to specify a (linear) code: we can list the codewords, or we can give a spanning set, which might also be a basis. But since codes are vector subspaces, we can also describe them as the image or the kernel of a suitable mapping between spaces. It turns out that these mappings are also helpful for the encoding and decoding processes.</p>
<section id="mappings-and-matrices" class="level2" data-number="3.1">
<h2 data-number="3.1"><span class="header-section-number">3.1</span> Mappings and Matrices</h2>
<p>Let <span class="math inline">\({\mathbb F}_q^k\)</span> and <span class="math inline">\({\mathbb F}_q^n\)</span> be two vector spaces, over the same field <span class="math inline">\({\mathbb F}_q\)</span> but of possibly different dimensions, and let <span class="math inline">\(f:{\mathbb F}_q^k \longrightarrow {\mathbb F}_q^n\)</span> be a linear mapping between them. This means that <span class="math inline">\(f\)</span> preserves the linear structure: if <span class="math inline">\({\bf x}\)</span> and <span class="math inline">\({\bf y}\)</span> are vectors in <span class="math inline">\({\mathbb F}_q^k\)</span>, and <span class="math inline">\(\lambda\)</span> is a scalar in <span class="math inline">\({\mathbb F}_q\)</span>, we have <span class="math inline">\(f({\bf x}+{\bf y}) = f({\bf x}) +f({\bf y})\)</span> and <span class="math inline">\(f(\lambda {\bf x}) = \lambda f({\bf x})\)</span>. Then we know that we can perform the mapping <span class="math inline">\(f\)</span> by multiplying by a suitable matrix <span class="math inline">\(A\)</span>, with entries from <span class="math inline">\({\mathbb F}_q\)</span>. We are writing our vectors as rows: <span class="math inline">\({\bf x}\in {\mathbb F}_q^k\)</span> is a <span class="math inline">\(1 \times k\)</span> ‘matrix’, and <span class="math inline">\(f({\bf x}) \in {\mathbb F}_q^n\)</span> is <span class="math inline">\(1 \times n\)</span>. So we need <span class="math inline">\(A\)</span> to be <span class="math inline">\(k \times n\)</span>; we can write that <span class="math inline">\(A \in M_{k,n}({\mathbb F}_q)\)</span>. And we must multiply <span class="math inline">\({\bf x}\)</span> by <span class="math inline">\(A\)</span> on the <span><em>right</em></span>.</p>
<div class="exampleqed">
<p>Let <span class="math inline">\(f:{\mathbb F}_5^3 \longrightarrow {\mathbb F}_5^4\)</span> such that <span class="math inline">\(f({\bf x}) = {\bf x}A\)</span>, where <span class="math inline">\(A =\left( \begin{array}{cccc} 
1&amp;0&amp;1&amp;3 \\
3&amp;2&amp;0&amp;1 \\
4&amp;2&amp;1&amp;4 \\
\end{array}\right) \in M_{3,4}({\mathbb F}_5).\)</span> Then, for example, if <span class="math inline">\({\bf x}= (0,1,2)\)</span>, <span class="math display">\[f({\bf x}) = {\bf x}A = (0,1,2)\left( \begin{array}{cccc} 
1&amp;0&amp;1&amp;3 \\
3&amp;2&amp;0&amp;1 \\
4&amp;2&amp;1&amp;4 \\
\end{array}\right) = (1, 1,2, 4).\]</span></p>
</div>
<p>This may look unfamiliar. In Linear Algebra 1 you mostly wrote vectors as columns, and multiplied by <span class="math inline">\(A\)</span> on the left. Of course, we could still do it that way, by taking the transpose of everything: if <span class="math inline">\({\bf x}A = {\bf y}\)</span>, then also <span class="math inline">\(A^t{\bf x}^t = ({\bf x}A)^t = y^t\)</span>. But coding theory always uses row vectors, and you will get used to it!</p>
<p>The <span><strong>image</strong></span> of the mapping <span class="math inline">\(f\)</span> is all the vectors in <span class="math inline">\({\mathbb F}_q^n\)</span> which can be written as <span class="math inline">\(f({\bf x})\)</span> for some <span class="math inline">\({\bf x}\)</span> in <span class="math inline">\({\mathbb F}_q^k\)</span>:</p>
<p><span class="math display">\[{\rm im}(f) = f({\mathbb F}_q^k) = \{ f({\bf x})\;|\; {\bf x}\in {\mathbb F}_q^k\} = \{ {\bf x}A\;|\; {\bf x}\in {\mathbb F}_q^k\}\subseteq {\mathbb F}_q^n\]</span></p>
<p>(Draw your own“fried egg" diagram.) Let us regard the rows of <span class="math inline">\(A\)</span> as vectors <span class="math inline">\({\bf a}_1, \ldots,{\bf a}_k \in {\mathbb F}_q^n\)</span>. Then since <span class="math inline">\({\bf x} = (x_1, \ldots,x_n)\)</span> can be any vector in <span class="math inline">\({\mathbb F}_q^k\)</span>, <span class="math inline">\({\rm im}(f)\)</span> is all the linear combinations <span class="math inline">\(x_1{\bf a}_1  +  \cdots + x_k{\bf a}_k\)</span> of the <span class="math inline">\({\bf a}_i\)</span>. This is the span of the <span class="math inline">\({\bf a}_i\)</span>, so we can say that <span class="math inline">\({\rm Im}(f)= \langle \{{\bf a}_1, \ldots,{\bf a}_k\}\rangle\)</span>, or that the rows of <span class="math inline">\(A\)</span> are a spanning set for the image.</p>
</section>
<section id="generator-matrices" class="level2" data-number="3.2">
<h2 data-number="3.2"><span class="header-section-number">3.2</span> Generator-matrices</h2>
<p>If the rows of <span class="math inline">\(A\)</span> are also linearly independent, then they are a basis for <span class="math inline">\({\rm Im}(f)\)</span>, and <span class="math inline">\(k\)</span>, the number of rows, is the dimension of this image.</p>
<div class="definition">
<p>For some matrix <span class="math inline">\(G \in M_{k,n}({\mathbb F}_q)\)</span>, let <span class="math inline">\(f:{\mathbb F}_q^k \longrightarrow {\mathbb F}_q^n\)</span> be defined by <span class="math inline">\(f({\bf x}) = {\bf x}G\)</span>, and let the linear code <span class="math inline">\(C = {\rm im}(f)  = \{ {\bf x}G\;|\; {\bf x}\in {\mathbb F}_q^k\}\subseteq {\mathbb F}_q^n\)</span>. Then if <span class="math inline">\(G\)</span> has linearly independent rows, G is a <span><strong>generator-matrix</strong></span> for C.</p>
</div>
<p>So if we are given a code as a span, <span class="math inline">\(C = \langle \{{\bf a}_1, \ldots, {\bf a}_m\}\rangle\)</span>, how can we find a generator-matrix for <span class="math inline">\(C\)</span>? We can easily make the matrix <span class="math inline">\(A\)</span> with rows <span class="math inline">\({\bf a}_i\)</span>, but we still need to determine whether these rows are linearly independent. If they are not, we must find another, smaller set of vectors which are independent, but span the same subspace of <span class="math inline">\({\mathbb F}_q^n\)</span>.</p>
<p>As you know, this can be done by row-reducing the matrix <span class="math inline">\(A\)</span>. This process, which takes linear combinations of the rows, does not change their span. Of course, the row-reduction must be done in <span class="math inline">\({\mathbb F}_q\)</span>, but this is easier than in <span class="math inline">\({\mathbb R}\)</span>. The numbers stay small, and you never need to subtract or divide: just use inverses, and add or multiply.</p>
<p>We obtain a matrix in reduced row echelon form (RREF). If there are any rows of zeros at the bottom, we remove them. Let the resulting matrix be <span class="math inline">\(B\)</span>, with rows <span class="math inline">\({\bf b}_1, \ldots {\bf b}_k ,\; k \leq m\)</span>, and consider the two possible cases:</p>
<ul>
<li><p><span><strong>If the rows of <span class="math inline">\(A\)</span> were independent</strong></span>, there were no rows of zeros, and <span class="math inline">\(k=m\)</span>. In this case both <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span> correspond to maps from <span class="math inline">\({\mathbb F}_q^k\)</span> to <span class="math inline">\({\mathbb F}_q^n\)</span>; <span class="math inline">\(f_A({\bf x}) = {\bf x}A\)</span> and <span class="math inline">\(f_B({\bf x}) = {\bf x}B\)</span>. Their images are the same, so we can let <span class="math display">\[C = {\rm im}(f_A) = {\rm im}(f_B) = \{{\bf x}A\;|\; {\bf x}\in {\mathbb F}_q^k\} = \{{\bf x}B\;| \;{\bf x}\in {\mathbb F}_q^k\}.\]</span> (But of course in general, for a given <span class="math inline">\({\bf x}\)</span>, <span class="math inline">\({\bf x}A \neq {\bf x}B\)</span>.)</p>
<p>Moreover, since the rows of <span class="math inline">\(A\)</span> are linearly independent, we know that <span class="math display">\[(x_1, \ldots,x_k)\left(\begin{array}{ccc} -&amp; {\bf a}_1 &amp; - \\ 
    &amp; \vdots  &amp;\\ 
    - &amp; {\bf a}_k &amp; - \end{array}\right) 
    = x_1 {\bf a}_1 + \cdots + x_k {\bf a}_k = {\bf 0}
    \Longrightarrow x_1 = \ldots = x_k = 0.\]</span> So<span class="math inline">\(f_A\)</span> is injective, and dim<span class="math inline">\(({\rm im}(f_A)) =\)</span> dim<span class="math inline">\(({\mathbb F}_q^k) = k\)</span>. (We know this already as the <span class="math inline">\({\bf a}_i\)</span> are a basis for <span class="math inline">\({\rm im}(f_A)\)</span>.) All this is equally true for <span class="math inline">\(B\)</span>. Both <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span> are generator matrices for <span class="math inline">\(C\)</span>.</p></li>
<li><p><span><strong>If the rows of <span class="math inline">\(A\)</span> were dependent</strong></span>, we had to remove at least one row of zeros, and <span class="math inline">\(k&lt;m\)</span>. Then for <span class="math inline">\(B\)</span> we can say, as above, that <span class="math inline">\(f_B: {\mathbb F}_q^k \longrightarrow {\mathbb F}_q^n\)</span> is injective, and dim<span class="math inline">\(({\rm im}(f_B)) = k\)</span>. But <span class="math inline">\(f_A: {\mathbb F}_q^m \longrightarrow {\mathbb F}_q^n\)</span> is not injective: We know there are some <span class="math inline">\(\lambda_i\)</span>, not all zero, such that <span class="math inline">\(\lambda_1{\bf a}_1 + \cdots + \lambda_m{\bf a}_m = {\bf 0}\)</span>. Then if <span class="math inline">\({\bf x}= ( \lambda_1, \ldots, \lambda_m)\)</span>, we have <span class="math inline">\({\bf x}\neq {\bf 0}\)</span> but <span class="math inline">\({\bf x}A = {\bf 0}\)</span>. The map <span class="math inline">\(f_A\)</span> maps a larger space onto a smaller, dimension <span class="math inline">\(m\)</span> to dimension <span class="math inline">\(k\)</span>. In this case, <span class="math inline">\(B\)</span> is a generator matrix for <span class="math inline">\(C = {\rm im}(f_B)\)</span>, but A is not.</p></li>
</ul>
<p>Thus a generator-matrix not only specifies a code, it also immediately tells us its dimension and so its size.</p>
<div class="exampleqed">
<p>Let <span class="math inline">\(C = \langle\{(0,0,3,1,4),(2,4,1,4,0),(5,3,0,1,6)\}\rangle \subseteq F_7^5\)</span>. To find <span class="math inline">\(|C|\)</span>, and a generator matrix for <span class="math inline">\(C\)</span>, we make <span class="math inline">\(A\)</span>, and row-reduce: <span class="math display">\[A = \left(\begin{matrix} 2&amp;4&amp;1&amp;4&amp;0 \\
                    5&amp;3&amp;0&amp;1&amp;6 \\
                    0&amp;0&amp;3&amp;1&amp;4\\
      \end{matrix}\right) 
      \stackrel{A_{12}}{\longrightarrow}
      \left(\begin{matrix} 2&amp;4&amp;1&amp;4&amp;0 \\
                    0&amp;0&amp;1&amp;5&amp;6 \\
                    0&amp;0&amp;3&amp;1&amp;4\\
      \end{matrix}\right) 
      \stackrel{M_1(4)}{\longrightarrow}
      \left(\begin{matrix} 1&amp;2&amp;4&amp;2&amp;0 \\
                    0&amp;0&amp;1&amp;5&amp;6 \\
                    0&amp;0&amp;3&amp;1&amp;4\\
      \end{matrix}\right) 
      \stackrel{A_{21}(3),A_{23}(4)}{\longrightarrow}
      \left(\begin{matrix} 1&amp;2&amp;0&amp;3&amp;4 \\
                    0&amp;0&amp;1&amp;5&amp;6 \\
                    0&amp;0&amp;0&amp;0&amp;0\\
      \end{matrix}\right)\]</span></p>
<p>Thus <span class="math inline">\(B = \left(\begin{matrix} 1&amp;2&amp;0&amp;3&amp;4 \\
                    0&amp;0&amp;1&amp;5&amp;6 \\
      \end{matrix}\right)\)</span> is a generator matrix for <span class="math inline">\(C\)</span> , and <span class="math inline">\(|C| = 7^2 = 49\)</span>.</p>
</div>
</section>
<section id="sec:encodingandchanneldecoding" class="level2" data-number="3.3">
<h2 data-number="3.3"><span class="header-section-number">3.3</span> Encoding and Channel Decoding</h2>
<p>Recall the basic situation described in Chapter 1. The generator-matrix provides a very easy way to encode messages to codewords: we let our messages be vectors in <span class="math inline">\({\mathbb F}_q^k\)</span>, and then multiply by the generator-matrix <span class="math inline">\(G\)</span> to to obtain codewords in <span class="math inline">\(C \subseteq {\mathbb F}_q^n\)</span>.</p>
<p><span class="math inline">\(\boxed{\text{SENDER}} \underset{{\bf x}\in {\mathbb F}_q^k}{\overset{ \text{message}   }{\longrightarrow\longrightarrow\longrightarrow}}
 \boxed{\substack{\text{ENCODER} \\ {\bf c}= {\bf x}G}}
 \underset{{\bf c}\in C \subseteq {\mathbb F}_q^n}{\overset{\text{codeword} }{\longrightarrow\longrightarrow\longrightarrow}}  \boxed{\text{CHANNEL} }\)</span></p>
<p>It is crucial that the rows of <span class="math inline">\(G\)</span> are independent, so that <span class="math inline">\(f_G\)</span> is injective; otherwise, two different messages would have the same codeword. Also, if the code is to enable us to correct (or even detect) any errors, then there must be some words in <span class="math inline">\({\mathbb F}_q^n\)</span> but not in <span class="math inline">\(C\)</span>, so <span class="math inline">\(k\)</span> must be strictly <span class="math inline">\(&lt;n\)</span>. Thus a generator-matrix is always ‘landscape’ in shape.</p>
<p>The codeword <span class="math inline">\({\bf c}\)</span> then travels through the channel, where it may or may not be changed, and is received as <span class="math inline">\({\bf y}\in {\mathbb F}_q^n\)</span>. The receivers do their best to correct any error, finding a codeword <span class="math inline">\({\bf c}&#39;\)</span> which is the (or one of the) most likely to have been sent. (In Chapter 4 we will look again at this process.) And finally, they must find the message corresponding to this codeword, <span class="math inline">\({\bf x}&#39;\)</span> such that <span class="math inline">\({\bf x}&#39; G = {\bf c}&#39;\)</span>. This last process is called “channel decoding", to distinguish it from the “decoding" which attempts to correct errors. ( In the first pictures in Chapter 1, ‘<span class="math inline">\(\sim\)</span>’ is decoding, and ‘<span class="math inline">\(\rightarrow\)</span>’ is channel decoding.) So at the receiver’s end we have:</p>
<p><span class="math inline">\(\boxed{\text{CHANNEL}} \underset{{\bf y}\in {\mathbb F}_q^n}{\overset{\text{received word}}{\longrightarrow\longrightarrow\longrightarrow}} 
\boxed{\substack{\text{DECODER} \\ \text{error correction?}}} 
\underset{{\bf c}&#39; \in C}{\overset{ \text{codeword} }{\longrightarrow\longrightarrow\longrightarrow}}
\boxed{\text{CHANNEL DECODER}}
\underset{{\bf x}&#39; \in {\mathbb F}_q^k}{\overset{\text{message?}}{\longrightarrow\longrightarrow\longrightarrow}}
\boxed{USER}\)</span></p>
<p>But how can we find <span class="math inline">\({\bf x}&#39;\)</span> from <span class="math inline">\({\bf c}&#39;\)</span>? Our <span class="math inline">\(G\)</span> is not invertible; it is not even square. Let <span class="math inline">\({\bf x}&#39; = (x_1&#39;, \ldots x_k&#39;)\)</span>, <span class="math inline">\({\bf c}&#39; = (c_1&#39;, \ldots c_k&#39;)\)</span>, and <span class="math inline">\(G\)</span> have <span><em>columns</em></span> <span class="math inline">\({\bf g}_1,\ldots {\bf g}_n\)</span>. Then <span class="math display">\[{\bf x}&#39; G = (x_1, \ldots,x_k)
\left(\begin{array}{ccc}
 |    &amp;      &amp; |     \\
 {\bf g}_1 &amp;\cdots&amp; {\bf g}_n  \\
 |    &amp;      &amp; |     \\                  
      \end{array}\right) = (c_1&#39;, \ldots,c_k&#39;) = {\bf c}&#39;\]</span> So, using the usual dot product (or scalar product), we have <span class="math inline">\(n\)</span> equations <span class="math inline">\({\bf x}&#39; \cdot {\bf g}_i = c_i&#39;\)</span>, each in <span class="math inline">\(k\)</span> unknowns, the <span class="math inline">\(x_i\)</span>. It is because <span class="math inline">\({\bf c}&#39;\)</span> is a codeword that these equations are consistent and we can find such an <span class="math inline">\({\bf x}&#39;\)</span>, and because the map <span class="math inline">\(f_G: {\mathbb F}_q^k \longrightarrow {\mathbb F}_q^n\)</span> is injective that there is only one solution.</p>
<p>You can solve these equations by any method you like; you might prefer to think about <span class="math inline">\(G^t ({\bf x}&#39;)^t = ({\bf c}&#39;)^t\)</span>, and row-reduce the augmented matrix <span class="math inline">\((G^t \;| \; ({\bf c}&#39;)^t)\)</span>. But by picking the right generator-matrix for <span class="math inline">\(C\)</span> in the first place, we can make this much easier. Suppose that <span class="math inline">\(G\)</span> is in RREF. Then <span class="math inline">\(G\)</span> has <span class="math inline">\(k\)</span> columns, <span class="math inline">\({\bf g}_{i_1}, \ldots, {\bf g}_{i_k}\)</span>, which have a leading 1 and zeros elsewhere. Each of these picks out one coordinate of <span class="math inline">\({\bf x}&#39;\)</span>, so <span class="math inline">\(c&#39;_{i_j} = {\bf x}&#39; \cdot {\bf g}_{i_j} = x_j&#39;\)</span>. So in this case we can read off <span class="math inline">\({\bf x}&#39;\)</span> from <span class="math inline">\({\bf c}&#39;\)</span> without any calculation.</p>
<div class="exampleqed">
<p>Let <span class="math inline">\(C \subseteq {\mathbb F}_7^5\)</span> have generator matrix <span class="math inline">\(G = \left(\begin{matrix} 1&amp;2&amp;0&amp;3&amp;4 \\
                    0&amp;0&amp;1&amp;5&amp;6 \\
      \end{matrix}\right)\)</span>, and suppose we have corrected some received word to the codeword (6,5,3,5,0). Then to channel decode, we must find <span class="math inline">\({\bf x}&#39; = (x_i &#39;,x_2 &#39;)\)</span> such that <span class="math display">\[(x_i &#39;,x_2 &#39;) \left(\begin{matrix} 1&amp;2&amp;0&amp;3&amp;4 \\
                    0&amp;0&amp;1&amp;5&amp;6 \\
      \end{matrix}\right) = (6,5,3,5,0).\]</span> Clearly <span class="math inline">\({\bf x}&#39; = (6,3)\)</span>.</p>
</div>
</section>
<section id="sec:equivalence" class="level2" data-number="3.4">
<h2 data-number="3.4"><span class="header-section-number">3.4</span> Equivalence and Standard Form</h2>
<p>Sometimes two codes have different codewords, but are the same in all the ways that matter.</p>
<div id="def:equiv" class="definition">
<p> Two codes <span class="math inline">\(C_1,\ C_2\)</span> are <em>equivalent</em> if we can transform one to the other by applying a sequence of changes of two kinds to all the codewords:</p>
<ul>
<li><p>permuting the <span class="math inline">\(n\)</span> positions.</p></li>
<li><p>in a particular position, permuting the <span class="math inline">\(|A|=q\)</span> symbols.</p></li>
</ul>
</div>
<div id="equivsamenmd" class="proposition">
<p> Two codes which are equivalent have the same parameters <span class="math inline">\((n,M,d)\)</span>.</p>
</div>
<div id="def:permutationequiv" class="definition">
<p> Two linear codes <span class="math inline">\(\subseteq {\mathbb F}_q^n\)</span> are <span><strong>permutation equivalent</strong></span> if we can transform one to the other by applying a sequence of permutations to all of the codewords.</p>
</div>
<div id="def:monomialequiv" class="definition">
<p> Two linear codes <span class="math inline">\(\subseteq {\mathbb F}_q^n\)</span> are <em>monomially equivalent</em> if we can transform one to the other by applying a sequence of permutations to all of the codewords of the following form:</p>
<ul>
<li><p>permuting the <span class="math inline">\(n\)</span> positions.</p></li>
<li><p>in a particular position, multiplying by <span class="math inline">\(\lambda \in {\mathbb F}_q, \lambda \neq 0\)</span> .</p></li>
</ul>
</div>
<p>Clearly if two codes are permutation equivalent, then they are monomially equivalent, and we will simply never need to use a transformation of type ii) from the definition of monomial equivalence. Also, since <span class="math inline">\({\mathbb F}_q\)</span> is a field, multiplying by <span class="math inline">\(\lambda \neq 0\)</span> will permute the elements of <span class="math inline">\({\mathbb F}_q\)</span>, but not all permutations of <span class="math inline">\({\mathbb F}_q\)</span> can be obtained in this way. So if two codes are monomially equivalent, then they are also equivalent, but not vice-versa.</p>
<p>A change of either type is a bijective map <span class="math inline">\(\pi:{\mathbb F}_q^n \longrightarrow {\mathbb F}_q^n\)</span>; it just permutes the vectors of <span class="math inline">\({\mathbb F}_q^n\)</span>. Let us write <span class="math inline">\(\Pi\)</span> for a sequence of such changes, so <span class="math inline">\(\Pi = \pi_s \circ \cdots \circ \pi_1\)</span>. If there exists such a <span class="math inline">\(\Pi\)</span> with <span class="math inline">\(\Pi(C_1) = C_2\)</span>, then <span class="math inline">\(C_1\)</span> and <span class="math inline">\(C_2\)</span> are equivalent, and we write <span class="math inline">\(C_1 \equiv C_2\)</span> if the type of equivalence being considered is clear.</p>
<p>It is also quite easy to see that any such <span class="math inline">\(\pi\)</span> will preserve the linear structure: <span class="math inline">\(\pi({\bf x}+{\bf y}) = \pi({\bf x}) + \pi({\bf y})\)</span> and <span class="math inline">\(\pi( \lambda {\bf x}) = \lambda\pi({\bf x})\)</span>, and so the same is true for any <span class="math inline">\(\Pi\)</span>. Since <span class="math inline">\(C_1\)</span> and <span class="math inline">\(C_2\)</span> must have the same dimension (as they are both linear codes over the same field with the same number of codewords), then as a consequence of the rank-nullity theorem it follows that <span class="math inline">\(\Pi(C_1) = C_2\)</span> if and only if <span class="math inline">\(\Pi\)</span> changes a basis for <span class="math inline">\(C_1\)</span> into a basis for <span class="math inline">\(C_2\)</span>. We can therefore define equivalence in terms of generator-matrices.</p>
<div id="def:permutationmatrix" class="definition">
<p> An <span class="math inline">\(m\times m\)</span> matrix <span class="math inline">\(P\in M_{m,m}(\mathbb{Z}_2)\)</span> is a <em>permutation matrix</em> if it has a single 1 in each row and column, and zeros elsewhere. Note that any permutation can be written as a permutation matrix of an appropriate size.</p>
</div>
<p>Those of you studying Representation Theory III will probably recognise such matrices as those found when considering representations of the symmetric group.</p>
<div id="prop:permutationequivalencegeneratormatrix" class="proposition">
<p> Let <span class="math inline">\(C_1\)</span> and <span class="math inline">\(C_2\)</span> be codes in <span class="math inline">\({\mathbb F}_q^n\)</span> with generator-matrices <span class="math inline">\(G_1\)</span> and <span class="math inline">\(G_2\)</span> respectively. Then if <span class="math inline">\(G_2=G_1 P\)</span> for some permutation matrix <span class="math inline">\(P\)</span>, then <span class="math inline">\(C_1\)</span> and <span class="math inline">\(C_2\)</span> are permutation equivalent.</p>
</div>
<div id="eg:permutationmatrix" class="exampleqed">
<p> Let <span class="math inline">\(C_1,C_2 \subseteq \mathbb{F}_q^3\)</span>, and let <span class="math inline">\(C_1\)</span> have generator matrix <span class="math inline">\(G_1\)</span> where <span class="math display">\[G_1 = \left(\begin{array}{ccc}
 |    &amp;   |   &amp; |    \\
 {\bf g}_1 &amp; {\bf g}_2 &amp; {\bf g}_3  \\
 |    &amp;   |   &amp; |     \\                  
      \end{array}\right).\]</span></p>
<p>If <span class="math display">\[G_2 =  \left(\begin{array}{ccc}
 |    &amp;   |   &amp; |    \\
 {\bf g}_1 &amp; {\bf g}_2 &amp; {\bf g}_3  \\
 |    &amp;   |   &amp; |     \\                  
      \end{array}\right)\left( \begin{array}{ccc}
      	0 &amp; 1 &amp; 0 \\
		0 &amp; 0 &amp; 1 \\
		1 &amp; 0 &amp; 0
      \end{array} \right) = \left(\begin{array}{ccc}
 |    &amp;   |   &amp; |    \\
 {\bf g}_3 &amp; {\bf g}_1 &amp; {\bf g}_2  \\
 |    &amp;   |   &amp; |     \\                  
      \end{array}\right),\]</span> is a generator matrix for <span class="math inline">\(C_2\)</span>, then by linearity every <span class="math inline">\(c_2\in C_2\)</span> is the image of a <span class="math inline">\(c_1 \in C_1\)</span> under the permutation given in cycle form as <span class="math inline">\((123)\)</span>.</p>
</div>
<div id="def:monomialmatrix" class="definition">
<p> An <span class="math inline">\(m\times m\)</span> matrix <span class="math inline">\(M\in M_{m,m}(\mathbb{F}_q)\)</span> is a <em>monomial matrix</em> if it has exactly one non-zero element in each row and column.</p>
<p>A monomial matrix <span class="math inline">\(M\)</span> can always be written as <span class="math inline">\(M=DP\)</span> or <span class="math inline">\(M=PD&#39;\)</span>, for <span class="math inline">\(P\)</span> a permutation matrix, and <span class="math inline">\(D,D&#39;\)</span> diagonal matrices. We call <span class="math inline">\(P\)</span> the <em>permutation part</em> and <span class="math inline">\(D,D&#39;\)</span> the <em>diagonal part</em> of <span class="math inline">\(M\)</span> respectively.</p>
</div>
<div id="eg:monomialmatrix" class="exampleqed">
<p> <span class="math display">\[\underset{D}{\left( \begin{array}{ccc}
	      	2 &amp; 0 &amp; 0 \\
			0 &amp; 3 &amp; 0 \\
			0 &amp; 0 &amp; 1
	      \end{array} \right)}
		  \underset{P}{\left( \begin{array}{ccc}
	      	0 &amp; 1 &amp; 0 \\
			0 &amp; 0 &amp; 1 \\
			1 &amp; 0 &amp; 0
	      \end{array} \right)}
		  =
		  \underset{M}{\left( \begin{array}{ccc}
	      	0 &amp; 2 &amp; 0 \\
			0 &amp; 0 &amp; 3 \\
			1 &amp; 0 &amp; 0
	      \end{array} \right)}
		  =
		  \underset{P}{\left( \begin{array}{ccc}
	      	0 &amp; 1 &amp; 0 \\
			0 &amp; 0 &amp; 1 \\
			1 &amp; 0 &amp; 0
	      \end{array} \right)}
		  \underset{D&#39;}{\left( \begin{array}{ccc}
	      	1 &amp; 0 &amp; 0 \\
			0 &amp; 2 &amp; 0 \\
			0 &amp; 0 &amp; 3
	      \end{array} \right)}\]</span></p>
<p>If we apply <span class="math inline">\(M\)</span> to the generator matrix <span class="math inline">\(G_1\)</span> of a code <span class="math inline">\(C_1\subseteq \mathbb{F}_5^3\)</span>, as <span class="math inline">\(G_2=GM\)</span>, then this consists of first multiplying all codewords by 2 in the first position, and by three in the second position, and then by applying the permutation <span class="math inline">\((123)\)</span>. Equivalently, we could apply the permutation first, and then multiply all words by 2 in the second position and by 3 in the third position.</p>
<p>The matrix <span class="math inline">\(G_2\)</span> is then the generator matrix for a monomially equivalent code to <span class="math inline">\(C_1\)</span>.</p>
</div>
<div id="prop:monomialequivalencegeneratormatrix" class="proposition">
<p> Let <span class="math inline">\(C_1\)</span> and <span class="math inline">\(C_2\)</span> be codes in <span class="math inline">\({\mathbb F}_q^n\)</span> with generator-matrices <span class="math inline">\(G_1\)</span> and <span class="math inline">\(G_2\)</span> respectively. Then if <span class="math inline">\(G_2=G_1 M\)</span> for some monomial matrix <span class="math inline">\(M\)</span>, then <span class="math inline">\(C_1\)</span> and <span class="math inline">\(C_2\)</span> are monomially equivalent.</p>
</div>
<p>Note that Propositions <a href="#prop:permutationequivalencegeneratormatrix" data-reference-type="ref" data-reference="prop:permutationequivalencegeneratormatrix">[prop:permutationequivalencegeneratormatrix]</a> and <a href="#prop:monomialequivalencegeneratormatrix" data-reference-type="ref" data-reference="prop:monomialequivalencegeneratormatrix">[prop:monomialequivalencegeneratormatrix]</a> do not say “if and only if". This is because most codes have many possible generator-matrices: if <span class="math inline">\(C_1\)</span> and <span class="math inline">\(C_2\)</span> are linearly equivalent, there must be a <span class="math inline">\(\Pi\)</span> taking <span class="math inline">\(G_1\)</span> to <span><em>some</em></span> generator-matrix for <span class="math inline">\(C_2\)</span> - but it might not be <span class="math inline">\(G_2\)</span>. However, if <span class="math inline">\(C_1\)</span> and <span class="math inline">\(C_2\)</span> are equivalent, and <span class="math inline">\(C_1\)</span> has generator matrix <span class="math inline">\(G_1\)</span>, then <span class="math inline">\(G_2=G_1 H\)</span> (for <span class="math inline">\(H\)</span> either a monomial matrix or permutation matrix as appropriate) is a generator matrix for <span class="math inline">\(G_2\)</span>.</p>
<p>If we let <span class="math inline">\(S\)</span> be the set of all codes of length <span class="math inline">\(n\)</span> over <span class="math inline">\({\mathbb F}_q\)</span>, then both permutation equivalence and monomial equivalence are <em>equivalence relations</em>, meaning that they satisfy the following conditions:</p>
<ul>
<li><p><span class="math inline">\(C \sim C\)</span>, <span class="math inline">\(\forall\ C \in S \quad\)</span> (Reflexive)</p></li>
<li><p>If <span class="math inline">\(C_1 \sim C_2\)</span>, then <span class="math inline">\(C_2 \sim C_1 \quad\)</span> (Symmetric)</p></li>
<li><p>If <span class="math inline">\(C_1 \sim C_2\)</span> and <span class="math inline">\(C_2 \sim C_3\)</span>, then <span class="math inline">\(C_1 \sim C_3 \quad\)</span> (Transitive)</p></li>
</ul>
<p>We can therefore partition the set of all codes of length <span class="math inline">\(n\)</span> over <span class="math inline">\({\mathbb F}_q\)</span> into equivalence classes (using either permutation equivalence or monomial equivalence). For those of you who have done Algebra II, this is the <em>orbit</em> of the code under the symmetric group.</p>
<p>However, there may be some permutations which don’t just send the code to another element of its equivalence class, but rather send the code to itself. In the language of algebra, these are stabilisers of the code, and the set of all stabilisers forms a group under composition.</p>
<div id="def:permutationautomorphismgroup" class="definition">
<p> The set of permutations sending a code to itself forms a group under composition, with the trivial permutation acting as the identity. This group is known as the <em>permutation automorphism group</em> of <span class="math inline">\(C\)</span>, and is written as <span class="math inline">\(\operatorname{PAut}(C)\)</span>.</p>
<p>In practice, we may think of these permutations either as matrices, or in their cycle form. The two are equivalent as demonstrated in Example <a href="#eg:permutationmatrix" data-reference-type="ref" data-reference="eg:permutationmatrix">[eg:permutationmatrix]</a>.</p>
<p>For a code <span class="math inline">\(C\)</span> of block length <span class="math inline">\(n\)</span>, <span class="math inline">\(\operatorname{PAut}(C)\)</span> is a subgroup of the symmetric group on <span class="math inline">\(n\)</span> symbols <span class="math inline">\(S_n\)</span>, <span class="math inline">\(\operatorname{PAut}(C)\subseteq S_n\)</span>.</p>
</div>
<p><strong>Aside:</strong> If you didn’t study Algebra II, you may not have seen the definition of a subgroup, so I’ll repeat it here.</p>
<p><span id="def:subgroup" label="def:subgroup">[def:subgroup]</span> Given a group <span class="math inline">\(G\)</span>, a subset <span class="math inline">\(H\subseteq G\)</span> is said to be a <em>subgroup</em> if:</p>
<ol>
<li><p>The identity <span class="math inline">\(e \in H\)</span>,</p></li>
<li><p>For any <span class="math inline">\(h_1,\ h_2 \in H\)</span>, we have <span class="math inline">\(h_1 h_2 \in H\)</span>,</p></li>
<li><p>For any <span class="math inline">\(h \in H\)</span>, we have that the inverse <span class="math inline">\(h^{-1}\in H\)</span>.</p></li>
</ol>
<p>Similarly, the set of all monomial matrices which sends a code to itself also forms a group.</p>
<div id="def:monomialautomorphismgroup" class="definition">
<p> The set of monomial matrices sending a code to itself forms a group under composition. This group is known as the <em>monomial automorphism group</em> of <span class="math inline">\(C\)</span>, and is written as <span class="math inline">\(\operatorname{MAut}(C)\)</span>.</p>
</div>
<p>For a binary code we have that <span class="math inline">\(\operatorname{PAut}(C)=\operatorname{MAut}(C)\)</span>, but more generally we have <span class="math inline">\(\operatorname{PAut}(C)\subseteq\operatorname{MAut}(C)\)</span>.</p>
<p>The idea of equivalence allows us to work with particularly convenient generator-matrices:</p>
<div class="definition">
<p>For <span class="math inline">\(k \leq n\)</span>, if a <span class="math inline">\(k \times n\)</span> generator-matrix is of the form <span class="math inline">\((I_k \;|\; A)\)</span>, we say that it is in <span><strong>standard form</strong></span>.</p>
</div>
<p>Here <span class="math inline">\(I_k\)</span> is the <span class="math inline">\(k\times k\)</span> identity matrix, and <span class="math inline">\(A\)</span> some <span class="math inline">\(k \times (n-k)\)</span> matrix.</p>
<div class="proposition">
<p>Any linear code is linearly equivalent to one with a generator-matrix in standard form.</p>
</div>
<div class="proof">
<p>For any code <span class="math inline">\(C_1  \subseteq {\mathbb F}_q^n\)</span> we can find a generator-matrix <span class="math inline">\(G_1\)</span> which is in RREF. Then by permuting columns we can obtain <span class="math inline">\(G_2\)</span> of form <span class="math inline">\((I \; |\; A)\)</span>, and this is the generator-matrix of an equivalent code <span class="math inline">\(C_2\)</span>.</p>
</div>
<p>One advantage of standard form is that it makes channel decoding even easier. The first <span class="math inline">\(k\)</span> digits of the codeword are the corresponding message.</p>
<div class="exampleqed">
<p>Let <span class="math inline">\(C_1 \subseteq {\mathbb F}_7^5\)</span> have generator matrix <span class="math inline">\(G_1 = \left(\begin{matrix} 1&amp;2&amp;0&amp;3&amp;4 \\
                    0&amp;0&amp;1&amp;5&amp;6 \\
      \end{matrix}\right)\)</span> as above. By swapping columns 2 and 3, we obtain <span class="math inline">\(G_2 = \left(\begin{matrix} 
                    1&amp;0&amp;2&amp;3&amp;4 \\
                    0&amp;1&amp;0&amp;5&amp;6 \\
      \end{matrix}\right)\)</span>, which is in standard form. Then using the equivalent code <span class="math inline">\(C_2\)</span> which has this generator matrix, a sender would encode message (1,5) as <span class="math display">\[(1,5) \left(\begin{matrix} 1&amp;0&amp;2&amp;3&amp;4 \\
                    0&amp;1&amp;0&amp;5&amp;6 \\
      \end{matrix}\right)= (1,5,2,0,6),\]</span> and a receiver would channel decode (6,3,5,5,0) to (6,3).</p>
</div>
<p>To end this chapter I will briefly introduce some terminology which we will not stress, but you may meet in other sources.</p>
<p>Suppose we encode using a generator-matrix in standard form. Then the first <span class="math inline">\(k\)</span> digits of the codeword are the message, and the remaining <span class="math inline">\(n-k\)</span> digits, calculated from the message using the <span class="math inline">\(A\)</span> part of the generator-matrix, are sometimes called <span><strong>check-digits</strong></span>. Their role is to show up symbol-errors in the message digits: if only a message-digit is changed, the result will not be a codeword. Syndrome decoding (Section 4.3) exploits this kind of idea.</p>
<p>The <span><strong>rank</strong></span> of a code is its dimension, <span class="math inline">\(k\)</span>. (This is also the rank, in the linear algebra sense, of its generator-matrix.) Its <span><strong>redundancy</strong></span> is <span class="math inline">\(n-k\)</span>, the number of check-digits. These are “redundant" in the sense that they are not the message, though they are certainly not useless. And the <span><strong>rate</strong></span> of the code is <span class="math inline">\(k/n\)</span>, the fraction of the stream of symbols which is the actual messages. Redundancy and rate are most easily explained for a code with generator-matrix in standard form, but these names can be used for the parameters <span class="math inline">\(n-k\)</span> and <span class="math inline">\(k/n\)</span> of any linear code.</p>
</section>
</section>
<section id="codes-as-kernels" class="level1" data-number="4">
<h1 data-number="4"><span class="header-section-number">4</span> Codes as Kernels</h1>
<p>In <span class="math inline">\({\mathbb F}_q^n\)</span>, just as in <span class="math inline">\({\mathbb R}^n\)</span>, we can calculate the <span><strong>dot</strong></span> (or scalar) <span><strong>product</strong></span> of two vectors: <span class="math inline">\({\bf x}\cdot {\bf y}= x_1y_1 + \cdots x_ny_n\)</span>, and if <span class="math inline">\({\bf x}\cdot {\bf y}= 0\)</span> we say that <span class="math inline">\({\bf x}\)</span> and <span class="math inline">\({\bf y}\)</span> are <span><strong>orthogonal</strong></span>. (But since we multiply and add mod <span class="math inline">\(q\)</span>, a non-zero vector <span class="math inline">\({\bf x}\)</span> can easily have <span class="math inline">\({\bf x}\cdot {\bf x}= 0\)</span>, and so be orthogonal to itself. <a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>)</p>
<p>The <span><strong>kernel</strong></span> of a linear map <span class="math inline">\(f:{\mathbb F}_q^n \longrightarrow {\mathbb F}_q^m\)</span> is the vectors which it sends to <span class="math inline">\({\bf 0}\)</span>: <span class="math inline">\({\rm ker}(f) = \{ {\bf x}\in {\mathbb F}_q^n\;|\; f({\bf x}) = {\bf 0}\}\)</span>.</p>
<p>By combining these two ideas we get a new way to specify a code, and to find its minimum distance. We also find a much better algorithm for detecting (and sometimes correcting) errors.</p>
<section id="dual-codes" class="level2" data-number="4.1">
<h2 data-number="4.1"><span class="header-section-number">4.1</span> Dual codes</h2>
<p>If <span class="math inline">\(C\)</span> is a code in <span class="math inline">\({\mathbb F}_q^n\)</span>, then ‘<span class="math inline">\(C\)</span> dual’, written <span class="math inline">\(C ^\perp\)</span>, is the space of all vectors in <span class="math inline">\({\mathbb F}_q^n\)</span> which are orthogonal to every codeword in <span class="math inline">\(C\)</span>.</p>
<div class="definition">
<p>Let <span class="math inline">\(C\)</span> be a code in <span class="math inline">\({\mathbb F}_q^n\)</span>. Then its <span><strong>dual</strong></span> <span class="math inline">\(C ^\perp = \{{\bf v}\in {\mathbb F}_q^n \;|\; {\bf v}\cdot {\bf u}= 0 \; {\rm for}\;{\rm all}\; {\bf u}\in C \}\)</span>.</p>
</div>
<p>But we do not have to check <span class="math inline">\({\bf v}\)</span> against <span><em>every</em></span> <span class="math inline">\({\bf u}\)</span> in <span class="math inline">\(C\)</span>, one by one.</p>
<div class="proposition">
<p>If <span class="math inline">\(C\)</span> has generator matrix <span class="math inline">\(G\)</span>, then <span class="math inline">\(C ^\perp = \{{\bf v}\in {\mathbb F}_q^n \;|\; {\bf v}G^t =  {\bf 0} \}\)</span>.</p>
</div>
<div class="proof">
<p>The rows of <span class="math inline">\(G\)</span> are a basis for <span class="math inline">\(C\)</span>, say <span class="math inline">\(\{ {\bf b}_1,\ldots,{\bf b}_k\}\)</span>. Then certainly we require <span class="math inline">\({\bf v}\cdot {\bf b}_i = 0\)</span> for every <span class="math inline">\(1 \leq i \leq k\)</span>. But also, since the dot product is linear in the second input (in fact, in both), then if <span class="math inline">\({\bf u}= u_1 {\bf b}_1 + \cdots +u_k {\bf b}_k\)</span>, we have <span class="math inline">\({\bf v}\cdot {\bf u}= u_1 {\bf v}\cdot {\bf b}_1 + \cdots + u_k {\bf v}\cdot {\bf b}_k\)</span>. Thus it is enough to check that <span class="math inline">\({\bf v}\cdot{\bf b}_i = 0\)</span> for all the <span class="math inline">\({\bf b}_i\)</span>. We can do this by checking that <span class="math display">\[{\bf v}\cdot G^t = (v_1, \ldots,v_n)
    \left(\begin{array}{ccc}
 |    &amp;      &amp; |     \\
 {\bf b}_1 &amp;\cdots&amp; {\bf b}_k  \\
 |    &amp;      &amp; |     \\                  
      \end{array}\right) = (0, \ldots, 0) = {\bf 0} .\]</span></p>
</div>
<p>Multiplying by <span class="math inline">\(G^t\)</span> is of course a linear map <span class="math inline">\(f_{G^t}: {\mathbb F}_q^n \longrightarrow{\mathbb F}_q^k\)</span>, and the <span class="math inline">\({\bf v}\)</span>s we want are exactly ker<span class="math inline">\((f_{G^t})\)</span>, or the nullspace of <span class="math inline">\(G^t\)</span>. Draw a picture of these spaces and maps: <span class="math inline">\(C\)</span> and <span class="math inline">\(C^\perp\)</span> are both in <span class="math inline">\({\mathbb F}_q^n\)</span>. They will intersect, at least in <span class="math inline">\({\bf 0}\)</span>. <span class="math inline">\(C\)</span> is the image of the map <span class="math inline">\(f_G\)</span> coming from <span class="math inline">\({\mathbb F}_q^k\)</span>; <span class="math inline">\(C^\perp\)</span> is the kernel of the map <span class="math inline">\(f_{G^t}\)</span> going to <span class="math inline">\({\mathbb F}_q^k\)</span>.</p>
<div id="prop:dualdimension" class="proposition">
<p> Let <span class="math inline">\(C\)</span> be a code in <span class="math inline">\({\mathbb F}_q^n\)</span>. Then <span class="math inline">\(C^\perp\)</span> is a code, and if <span class="math inline">\(\operatorname{dim}(C) =k\)</span>, then <span class="math inline">\(\operatorname{dim}(C^\perp) = n-k\)</span>.</p>
</div>
<div class="proof">
<p>Since <span class="math inline">\(f_{G^t}\)</span> is a linear map, its kernel is a (linear) subspace, and so a (linear) code. The dimension of the kernel is the ‘nullity’ of the map, and we know<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a> that for the linear map <span class="math inline">\(f_{G^t}:{\mathbb F}_q^n\longrightarrow{\mathbb F}_q^k\)</span>, we have rank + nullity = <span class="math inline">\(\operatorname{dim}({\mathbb F}_q^n)=n\)</span>. The rank of the map is the row-rank of <span class="math inline">\(G^t\)</span>; in fact row- or column-rank of <span class="math inline">\(G\)</span> or <span class="math inline">\(G^t\)</span> are all four equal to <span class="math inline">\(k\)</span>. So the nullity is <span class="math inline">\(n-k\)</span>.</p>
</div>
<p>The ‘dual’ idea appears in many different areas of mathematics, but it is usually, as in this case, a ‘self-inverse’ operation:</p>
<div class="proposition">
<p>For <span class="math inline">\(C \subseteq {\mathbb F}_q^n\)</span>, <span class="math inline">\((C^\perp)^\perp = C\)</span>.</p>
</div>
<div class="proof">
<p>If <span class="math inline">\(C\)</span> has basis <span class="math inline">\(\{{\bf u}_1, \ldots,{\bf u}_k\}\)</span> and <span class="math inline">\(C^\perp\)</span> has basis <span class="math inline">\(\{{\bf v}_1, \ldots,{\bf v}_{n-k}\}\)</span>, then we know that for any <span class="math inline">\({\bf u}_i\)</span> and <span class="math inline">\({\bf v}_j\)</span> we have <span class="math inline">\({\bf v}_j \cdot {\bf u}_i = 0\)</span>. But this also shows that every <span class="math inline">\({\bf u}_i \in (C^\perp)^\perp\)</span>, so <span class="math inline">\(C \subseteq (C^\perp)^\perp\)</span>. By Proposition <a href="#prop:dualdimension" data-reference-type="ref" data-reference="prop:dualdimension">[prop:dualdimension]</a> we know that dim<span class="math inline">\((C^\perp)^\perp =n-(n-k)= k =\)</span> dim<span class="math inline">\((C)\)</span>, so they must be equal.</p>
</div>
<p>Suppose <span class="math inline">\(C\)</span> has generator matrix <span class="math inline">\(G\)</span> with rows <span class="math inline">\({\bf u}_1 \ldots {\bf u}_k\)</span>, how can we find out more about <span class="math inline">\(C^\perp\)</span>? We would like to find a basis, and thus a generator matrix for it. The vectors in <span class="math inline">\(C^\perp\)</span> are those <span class="math inline">\({\bf v}\)</span> such that <span class="math inline">\({\bf v}G^t  = (v_1, \ldots,v_n)
\left(\begin{array}{ccc}
 |    &amp;      &amp; |     \\
 {\bf u}_1 &amp;\cdots&amp; {\bf u}_k  \\
 |    &amp;      &amp; |     \\                  
      \end{array}\right)={\bf 0}\)</span>. As in Section <a href="#sec:encodingandchanneldecoding" data-reference-type="ref" data-reference="sec:encodingandchanneldecoding">3.3</a>, <span class="math inline">\(G^t\)</span> is not invertible, but we can solve the <span class="math inline">\(k\)</span> equations <span class="math inline">\({\bf v}\cdot {\bf u}_i = 0\)</span>. Again, one way to do this is to take transposes, <span class="math inline">\((G^t)^t {\bf v}^t = G{\bf v}^t = {\bf 0}\)</span>, and then row-reduce the augmented matrix <span class="math inline">\((G  \;|\; {\bf 0})\)</span>. Once we have <span class="math inline">\(G\)</span> in RREF, we can find a basis for <span class="math inline">\(C^\perp\)</span> from the new, simpler equations.</p>
<p>The following algorithm “automates" this process, working straight from <span class="math inline">\(G\)</span> in RREF to the basis for <span class="math inline">\(C^\perp\)</span>.</p>
<p><span><strong>Algorithm: Finding a basis for a dual code</strong></span> Suppose that <span class="math inline">\(C\)</span> has a generator matrix <span class="math inline">\(G=(g_{ij}) \in M_{k,n}({\mathbb F}_q)\)</span>, and <span class="math inline">\(G\)</span> is in RREF.</p>
<ul>
<li><p>Let <span class="math inline">\(L=\{1 \leq j \leq n \;|\; G\; \text{has a leading 1 in column} \;j\}\)</span>.</p></li>
<li><p>For each <span class="math inline">\(1 \leq j \leq n\)</span>, <span class="math inline">\(j \not\in L\)</span>, make a vector <span class="math inline">\({\bf v}_j\)</span> as follows: * for <span class="math inline">\(m \not\in L:\)</span> the <span class="math inline">\(m^{th}\)</span> entry of <span class="math inline">\({\bf v}_j\)</span> is 1 if <span class="math inline">\(m = j\)</span>, 0 otherwise. ** Fill in the other entries of <span class="math inline">\({\bf v}_j\)</span> (left to right) as <span class="math inline">\(-g_{1j},\ldots , -g_{kj}\)</span>.</p></li>
<li><p>These <span class="math inline">\(n-k\)</span> vectors <span class="math inline">\({\bf v}_j\)</span> are a basis for <span class="math inline">\(C^\perp\)</span>.</p></li>
</ul>
<div class="exampleqed">
<p>Let <span class="math inline">\(C\)</span> be the code in <span class="math inline">\({\mathbb F}_5^7\)</span> with generator matrix <span class="math display">\[G = \left(\begin{matrix} 
1 &amp; 2 &amp; 0 &amp; 3 &amp; 4 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 1 &amp; 1 &amp; 2 &amp; 0 &amp; 3 \\
0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 4 \\
      \end{matrix}\right)\]</span> To find a basis for <span class="math inline">\(C^\perp\)</span> we first note that <span class="math inline">\(G\)</span> is already in RREF, and the leading 1s are in columns 1, 3, and 6. Thus <span class="math inline">\(L = \{1, 3, 6\}\)</span>, and we make vectors for a basis <span class="math inline">\(\{{\bf v}_2,{\bf v}_4, {\bf v}_5, {\bf v}_7\}\)</span>. Step * fills in the “non-<span class="math inline">\(L\)</span>" entries, so that the incomplete vectors look a bit like a standard basis: <span class="math display">\[{\bf v}_2 = ( \;\;, 1, \;\;,0,0,\;\;,0)\;\;\;{\bf v}_4 = ( \;\;, 0, \;\;,1,0,\;\;,0)\;\]</span> <span class="math display">\[{\bf v}_5 = ( \;\;, 0, \;\;,0,1,\;\;,0)\;\;\;{\bf v}_7 = ( \;\;, 0, \;\;,0,0,\;\;,1)\]</span></p>
<p>Then step ** uses the corresponding columns to complete the vectors. For example, since column 7 is (0,3,4), we complete <span class="math inline">\({\bf v}_7\)</span> with the additive inverses of these: 0, 2, and 1. So we have</p>
<p><span class="math display">\[{\bf v}_2 = ( 3, 1, 0,0,0,0,0)\;\;\;{\bf v}_4 = ( 2, 0, 4,1,0,0,0)\;\]</span> <span class="math display">\[{\bf v}_5 = ( 1, 0, 3,0,1,0,0)\;\;\;{\bf v}_7 = ( 0, 0, 2,0,0,1,1)\]</span></p>
</div>
<p>Notice that, since <span class="math inline">\(G\)</span> is in RREF, in column <span class="math inline">\(j\)</span> all the entries after the <span class="math inline">\(j^{th}\)</span> will be 0. This is why, in step **, we find that <span class="math inline">\({\bf v}_j\)</span> is all zeros after the <span class="math inline">\(j^{th}\)</span> entry (which is the the 1 from step *).</p>
<p>We will not write out a formal proof that this algorithm works: it is a straightforward calculation but involves a lot of notation. But, having found your <span class="math inline">\({\bf v}_j\)</span>, it is easy to check they are indeed a basis: Firstly, step * ensures that each <span class="math inline">\({\bf v}_j\)</span> has a 1 in column <span class="math inline">\(j\)</span>, where all the others have 0, so the vectors are linearly independent. Secondly, to see they are in ker<span class="math inline">\((f_{G^t})\)</span>, check that each <span class="math inline">\({\bf v}_jG^t = {\bf 0}\)</span>. This shows why we do step **: everything cancels out just right. Since we know that dim(ker<span class="math inline">\((f_{G^t})) = n-k\)</span>, this proves we have a basis.</p>
<p>We can now make a generator-matrix <span class="math inline">\(H\)</span> for <span class="math inline">\(C^\perp\)</span>, by taking the <span class="math inline">\({\bf v}_j\)</span>, in order, as rows. In general, <span class="math inline">\(H\)</span> is not in RREF, but we can row-reduce it if necessary. As in Section <a href="#sec:equivalence" data-reference-type="ref" data-reference="sec:equivalence">3.4</a>, if <span class="math inline">\(G\)</span> is in standard form, the process is even easier:</p>
<div id="prop:dualstandardform" class="proposition">
<p> If <span class="math inline">\(C \subseteq {\mathbb F}_q^n\)</span> has generator-matrix <span class="math inline">\(G = (I_k\;|\; A)\)</span>, then a generator-matrix for <span class="math inline">\(C^\perp\)</span> is <span class="math inline">\(H= (-A^t \;|\;I_{n-k})\)</span>.</p>
</div>
<p>Again this is fiddly to prove in general, but becomes obvious with examples; this <span class="math inline">\(H\)</span> is exactly the generator-matrix for <span class="math inline">\(C^\perp\)</span> produced by the algorithm above. Again, <span class="math inline">\(H\)</span> can be row-reduced to RREF, but not necessarily to standard form.</p>
</section>
<section id="check-matrices" class="level2" data-number="4.2">
<h2 data-number="4.2"><span class="header-section-number">4.2</span> Check-matrices</h2>
<p>In the last section we showed that <span class="math inline">\(C^\perp = \{{\bf v}\in {\mathbb F}_q^n \;|\; {\bf v}G^t = {\bf 0} \}\)</span>, where <span class="math inline">\(G\)</span> is a generator-matrix for <span class="math inline">\(C\)</span>. But if we then find <span class="math inline">\(H\)</span>, a generator-matrix for <span class="math inline">\(C^\perp\)</span>, it is also true that <span class="math inline">\(C = (C^\perp)^\perp = \{{\bf v}\in {\mathbb F}_q^n \;|\; {\bf v}H^t = {\bf 0} \}\)</span>. This is a very useful new way to specify any linear code.</p>
<div class="definition">
<p>Let <span class="math inline">\(H \in M_{n-k, n}({\mathbb F}_q)\)</span> have linearly independent rows, and let <span class="math inline">\(C = \{{\bf v}\in {\mathbb F}_q^n \;|\; {\bf v}H^t = {\bf 0} \}\)</span>. Then <span class="math inline">\(H\)</span> is a <span><strong>check-matrix</strong></span> for <span class="math inline">\(C\)</span>.</p>
</div>
<p>The name makes sense: we use <span class="math inline">\(H\)</span> (or, in practice, its transpose) to ‘check’ whether <span class="math inline">\({\bf v}\)</span> is in <span class="math inline">\(C\)</span> or not. Notice that the rank of the map <span class="math inline">\(f_{H^t}\)</span> is the rank of the matrix <span class="math inline">\(H^t\)</span>, which is <span class="math inline">\(n-k\)</span>. So the dimension of the code <span class="math inline">\(C\)</span> defined in this way, which is the nullity of <span class="math inline">\(f_{H^t}\)</span>, is <span class="math inline">\(n-(n-k) = k\)</span>.</p>
<div class="proposition">
<p>If the code <span class="math inline">\(C\)</span> has generator-matrix <span class="math inline">\(G\)</span> and check-matrix <span class="math inline">\(H\)</span>, then <span class="math inline">\(C^{\perp}\)</span> has check-matrix <span class="math inline">\(G\)</span> and generator-matrix <span class="math inline">\(H\)</span>.</p>
</div>
<div class="proof">
<p>Suppose dim<span class="math inline">\((C) = k\)</span>. Then G has <span class="math inline">\(k\)</span> rows, and H has <span class="math inline">\(n-k\)</span> rows. Also, by Proposition <a href="#prop:dualdimension" data-reference-type="ref" data-reference="prop:dualdimension">[prop:dualdimension]</a>, dim<span class="math inline">\((C^{\perp}) = n-k\)</span>.</p>
<p>The rows of <span class="math inline">\(G\)</span> are linearly independent, and by Prop. 4.1 we know that <span class="math inline">\(C^\perp = \{{\bf v}\in {\mathbb F}_q^n \;|\; {\bf v}G^t = {\bf 0} \}\)</span>, so <span class="math inline">\(G\)</span> is a check-matrix for <span class="math inline">\(C^\perp\)</span>.</p>
<p>The rows of <span class="math inline">\(H\)</span> are orthogonal to every codeword in C, so they are in <span class="math inline">\(C^{\perp}\)</span>. They are also linearly independent, and there are <span class="math inline">\(n-k\)</span> of them, so they form a basis for <span class="math inline">\(C^{\perp}\)</span>.</p>
</div>
<p>The relationships among a code, its dual, and their respective generator- and check-matrices can be clarified by drawing pictures of the spaces and maps involved. They can also be very usefully summarised in the following table:</p>
<div class="center">
<table>
<thead>
<tr class="header">
<th style="text-align: left;"></th>
<th style="text-align: center;"> <span class="math inline">\(C\)</span></th>
<th style="text-align: center;"><span class="math inline">\(C^\bot\)</span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: left;">Generator-matrix</td>
<td style="text-align: center;"><span class="math inline">\(G\)</span></td>
<td style="text-align: center;"><span class="math inline">\(H\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: left;">Check-matrix</td>
<td style="text-align: center;"><span class="math inline">\(H\)</span></td>
<td style="text-align: center;"><span class="math inline">\(G\)</span></td>
</tr>
</tbody>
</table>
</div>
<p>In the last section we discussed an algorithm which finds the basis of a dual space. So it finds <span class="math inline">\(H\)</span> from <span class="math inline">\(G\)</span>. But this means it also finds a check-matrix for <span class="math inline">\(C\)</span> from its generator-matrix. Or, if we are given the check-matrix <span class="math inline">\(H\)</span> for <span class="math inline">\(C\)</span>, we can regard <span class="math inline">\(H\)</span> as a generator-matrix for <span class="math inline">\(C^\perp\)</span>, and then use the same algorithm to find a generator-matrix for <span class="math inline">\(C = (C^\perp)^\perp\)</span>. So we can use the algorithm to move either horizontally or vertically on the table; for this reason we can call it “the <span class="math inline">\(G \leftrightarrow H\)</span> algorithm".</p>
<p>If the matrix you have (either <span class="math inline">\(G\)</span> or <span class="math inline">\(H\)</span>) is in standard form <span class="math inline">\((I_k \;|\; A)\)</span>, the simpler algorithm of Proposition <a href="#prop:dualstandardform" data-reference-type="ref" data-reference="prop:dualstandardform">[prop:dualstandardform]</a> can also be used to find the other one. Moreover, if we have <span class="math inline">\(H\)</span> or <span class="math inline">\(G\)</span> in form <span class="math inline">\((A \;|\; I_k)\)</span>, we can regard it as a check-matrix corresponding, by Proposition <a href="#prop:dualstandardform" data-reference-type="ref" data-reference="prop:dualstandardform">[prop:dualstandardform]</a>, to a generator matrix of form <span class="math inline">\((I_{n-k} \;|\; -A^t)\)</span>. (See Q47) For this reason, <span class="math inline">\((A \;|\; I_k)\)</span> can be regarded as standard form for check-matrices. But since every check-matrix for a code <span class="math inline">\(C\)</span> is also a generator-matrix for <span class="math inline">\(C^\perp\)</span> this could be confusing; it seems best to specify each time whether we mean standard form <span class="math inline">\((I_k \;|\; A)\)</span> or standard form <span class="math inline">\((A \;|\; I_k)\)</span>.</p>
<div class="exampleqed">
<p>Let <span class="math inline">\(C = \{{\bf v}\in {\mathbb F}_2^5 \;|\; {\bf v}H^t = {\bf 0} \}\)</span>, with the single-row check-matrix <span class="math inline">\(H = (1\,1\,1\,1\,1)\)</span>. Then the codewords of <span class="math inline">\(C\)</span> are <span class="math inline">\({\bf c}=(c_1, \ldots, c_5)\)</span> such that <span class="math inline">\(c_1+ \cdots +c_5 = 0\)</span>, so those with even weight. Thus <span class="math inline">\(H\)</span> performs a simple “parity check"; to make a codeword we can choose 0 or 1 freely for any four of the entries, but the final entry must make the weight even. To find a basis for this code, since <span class="math inline">\(H\)</span> is in standard form <span class="math inline">\((I_1 \;|\; A)\)</span>, we can use Proposition <a href="#prop:dualstandardform" data-reference-type="ref" data-reference="prop:dualstandardform">[prop:dualstandardform]</a> and write down a generator-matrix <span class="math inline">\(G_1 = (A^t \;|\; I_4)\)</span>. (For a binary code, <span class="math inline">\(A = -A\)</span>.) But <span class="math inline">\(H\)</span> is also in form <span class="math inline">\(( A\;|\;I_1)\)</span>, so <span class="math inline">\(G_2 =(I_4\;|\;A^t)\)</span> is another generator matrix. In fact, <span class="math inline">\(G_2 = 
\left(\begin{matrix} 
 1 &amp; 0 &amp; 0 &amp; 0 &amp;1 \\
 0 &amp; 1 &amp; 0 &amp; 0 &amp;1 \\
 0 &amp; 0 &amp; 1 &amp; 0 &amp;1 \\
 0 &amp; 0 &amp; 0 &amp; 1 &amp;1 \\
      \end{matrix}\right)\)</span> is the RREF form of <span class="math inline">\(G_1 = 
\left(\begin{matrix} 
1 &amp; 1 &amp; 0 &amp; 0 &amp; 0  \\
1 &amp; 0 &amp; 1 &amp; 0 &amp; 0  \\
1 &amp; 0 &amp; 0 &amp; 1 &amp; 0 \\
1 &amp; 0 &amp; 0 &amp; 0 &amp; 1
      \end{matrix}\right)\)</span>.</p>
</div>
<p>What if <span class="math inline">\(C = \{{\bf v}\in {\mathbb F}_q^n \;|\; {\bf v}A^t = {\bf 0} \}\)</span>, but <span class="math inline">\(A \in M_{m,n}(F_q)\)</span> does not have linearly independent rows? Or perhaps we do not know whether its row are independent or not? It is still true that <span class="math inline">\(C = {\rm ker}(f_{A^t})\)</span>, and we might call <span class="math inline">\(A\)</span> an “acting check-matrix" for <span class="math inline">\(C\)</span> - it is doing the checking job, but it may not be fully qualified. Then, also, the rows of <span class="math inline">\(A\)</span> are a spanning set for <span class="math inline">\(C^\perp = \{ {\bf v}A \;|\; {\bf v}\in {\mathbb F}_q^m\} = {\rm im}(f_{A})\)</span>, but may not be a basis. We could similarly call <span class="math inline">\(A\)</span> an “acting generator-matrix" for <span class="math inline">\(C^\perp\)</span>.</p>
<p>Of course, using a check-matrix (or an acting check-matrix) to define a code is only a convenient new notation for a very familiar idea. You are familiar with defining a subspace using equations in the coordinates.</p>
<div class="exampleqed">
<p>If <span class="math inline">\(H =  \left(\begin{matrix} 
1 &amp; 2 &amp; 3  \\
0 &amp; 4 &amp; 1  \\
       \end{matrix}\right) \in M_{2,3}({\mathbb F}_5)\)</span>, and <span class="math inline">\(C = \{{\bf v}\in {\mathbb F}_5^3 \;|\; {\bf v}H^t = {\bf 0} \}\)</span>, then <span class="math inline">\(C= \{(v_1, v_2, v_3) \in {\mathbb F}_5^3 \;|\; v_1 + 2v_2 + 3v_3 = 0 \;{\rm and } \;4v_2 + v_3 = 0\}\)</span>.</p>
</div>
<p>To solve such sets of equations, you would manipulate them in ways which correspond to elementary row operations on the check-matrix. This confirms that (as with generator-matrices) row-reducing a check-matrix for a code <span class="math inline">\(C\)</span> gives another check-matrix for <span class="math inline">\(C\)</span>.</p>
</section>
<section id="syndrome-decoding" class="level2" data-number="4.3">
<h2 data-number="4.3"><span class="header-section-number">4.3</span> Syndrome Decoding</h2>
<p>In medicine, a “syndrome” is a collection of symptoms or characteristics which occur together. They are often apparently unrelated, but are assumed to have a single cause; over the last few decades, a genetic cause has been identified for many syndromes.</p>
<p>Similarly, the “syndrome" of a received word is useful evidence as to what error it may have suffered. We find the syndrome using the check-matrix. Thus, just as a generator-matrix makes it easy for a sender to encode a message, a check-matrix can help a receiver to decode a received word.</p>
<div class="definition">
<p>Suppose a code <span class="math inline">\(C\)</span> has check-matrix <span class="math inline">\(H\)</span>, so <span class="math inline">\(C = \{{\bf x}\in{\mathbb F}_q^n\; | \; {\bf x}H^t = 0\}\)</span>. For any received word <span class="math inline">\({\bf y}\)</span>, its <span><strong>syndrome</strong></span> is <span class="math inline">\(S({\bf y}) = {\bf y}H^t\)</span>.</p>
</div>
<p>Thus <span class="math inline">\(S({\bf y}) = {\bf 0}\)</span> if and only if <span class="math inline">\({\bf y}\)</span> is a codeword. In this case we assume that it is in fact the one which was sent and no error-vector was added. In this way, the syndrome detects errors.</p>
<p>But a non-zero syndrome can also help to correct errors, by helping us to guess an error which is likely to have occurred. We know that <span class="math inline">\(f_{H^t}: {\mathbb F}_q^n \longrightarrow {\mathbb F}_q^{n-k}\)</span> is a linear map. So if <span class="math inline">\({\bf y}= {\bf c}+ {\bf e}\)</span>, where <span class="math inline">\({\bf c}\in C\)</span>, then <span class="math inline">\(S({\bf y}) = S({\bf c}) + S({\bf e}) ={\bf 0} + S({\bf e}) = S({\bf e}).\)</span> So the syndrome of the received word is the same as that of the error-vector <span class="math inline">\({\bf e}\)</span>. The syndrome is able to ignore the codeword and just “pick out" the error.</p>
<p>Unfortunately knowing <span class="math inline">\(S({\bf e})\)</span> does not tell us <span class="math inline">\({\bf e}\)</span>, because the syndrome map <span class="math inline">\(f_{H^t}\)</span> is not injective: two different errors can have the same syndrome. The following algorithm associates each possible syndrome with a single, likely, error-vector.</p>
<p><span><strong>Algorithm: Syndrome decoding</strong></span></p>
<p>Let <span class="math inline">\(C\)</span> be a <span class="math inline">\(q\)</span>-ary <span class="math inline">\([n,k]\)</span> code, with check matrix <span class="math inline">\(H \in M_{n-k,n}({\mathbb F}_q)\)</span>, so <span class="math inline">\(C = \{{\bf x}\in {\mathbb F}_q^n\; | \; {\bf x}H^t = {\bf 0}\}\)</span>.</p>
<ol>
<li><p>List the elements of <span class="math inline">\({\mathbb F}_q^n\)</span> in non-decreasing order of weight.</p></li>
<li><p>Set up a table with two columns: <span><strong>syndrome</strong></span> <span class="math inline">\(S({\bf x}) \; | \;\)</span><span><strong>error-vector</strong></span> <span class="math inline">\({\bf x}\)</span>.</p></li>
<li><p>Let <span class="math inline">\({\bf x}\)</span> be the next element in the list and calculate <span class="math inline">\(S({\bf x})\)</span>.</p></li>
<li><p>If <span class="math inline">\(S({\bf x})\)</span> is in the syndrome column already, do nothing.If it is not, write a new row: <span class="math inline">\(S({\bf x}) \; | \; {\bf x}\)</span>.</p></li>
<li><p>Repeat (3) and (4) until you have <span class="math inline">\(q^{n-k}\)</span> rows.</p></li>
</ol>
<p>(error ‘correction’) Having received a word <span class="math inline">\({\bf y}\)</span>,</p>
<ol>
<li><p>Compute <span class="math inline">\(S({\bf y}) = {\bf y}H^t\)</span>.</p></li>
<li><p>Find <span class="math inline">\(S({\bf y})\)</span> in the syndrome column.</p></li>
<li><p>Find the error-vector <span class="math inline">\({\bf x}\)</span> that is in the same row.</p></li>
<li><p>Decode <span class="math inline">\({\bf y}\)</span> to <span class="math inline">\({\bf y}-{\bf x}\)</span>.</p></li>
</ol>
<div class="exampleqed">
<p>Let <span class="math inline">\(C_1 = \{{\bf x}\in {\mathbb F}_2^4\; | \; {\bf x}H^t = {\bf 0}\}\)</span>, where <span class="math inline">\(H = \left(\begin{matrix} 
1 &amp; 1 &amp; 0 &amp; 0  \\
0 &amp; 0 &amp; 1 &amp; 1  \\
\end{matrix}\right)\)</span> is a check-matrix for <span class="math inline">\(C_1\)</span>. We calculate syndromes, starting with words of weight 0, then 1, then 2: <span class="math inline">\(S(0,0,0,0)= (0,0)\)</span>, <span class="math inline">\(S(1,0,0,0)= (1,0)\)</span>, <span class="math inline">\(S(0,1,0,0)= (1,0)\)</span>, <span class="math inline">\(S(0,0,1,0)= (0,1)\)</span>, <span class="math inline">\(S(0,0,0,1)= (0,1)\)</span>, <span class="math inline">\(S(1,1,0,0)= (0,0)\)</span>, <span class="math inline">\(S(1,0,1,0)= (1,1)\)</span>, <span class="math inline">\(S(1,0,0,1)= (1,1) \ldots\)</span></p>
<p>Omitting the repeated syndromes, we make the following look-up table:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">Syndrome <span class="math inline">\(S({\bf x})\)</span></th>
<th style="text-align: center;">Error-vector <span class="math inline">\({\bf x}\)</span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">(0,0)</td>
<td style="text-align: center;">(0,0,0,0)</td>
</tr>
<tr class="even">
<td style="text-align: center;">(1,0)</td>
<td style="text-align: center;">(1,0,0,0)</td>
</tr>
<tr class="odd">
<td style="text-align: center;">(0,1)</td>
<td style="text-align: center;">(0,0,1,0)</td>
</tr>
<tr class="even">
<td style="text-align: center;">(1,1)</td>
<td style="text-align: center;">(1,0,1,0)</td>
</tr>
</tbody>
</table>
<p>We can stop here, as we have <span class="math inline">\(2^{4-2}\)</span> rows; equivalently, we have every possible syndrome.</p>
<p>Now suppose we receive <span class="math inline">\({\bf y}_1=(1,1,0,1)\)</span>. Then <span class="math inline">\(S({\bf y}_1) = (0,1)\)</span>, so the table says that the error-vector was (0,0,1,0), and we decode to <span class="math inline">\((1,1,0,1) -(0,0,1,0) = (1,1,1,1) = {\bf c}_1\)</span>. Similarly, <span class="math inline">\({\bf y}_2 =(0,1,0,0)\)</span> decodes to <span class="math inline">\({\bf c}_2 =(1,1,0,0)\)</span>.</p>
</div>
<p>By the theory, both these <span class="math inline">\({\bf c}_i\)</span> should be in <span class="math inline">\(C_1\)</span>; we can check this by finding <span class="math inline">\(S({\bf c}_i)\)</span>. We could also use the “<span class="math inline">\(G \leftrightarrow H\)</span> algorithm" to find a generator matrix <span class="math inline">\(G\)</span> for <span class="math inline">\(C\)</span>. Surprisingly, we find that <span class="math inline">\(G=H\)</span>, so <span class="math inline">\(C_1 = C_1^\perp\)</span>; <span class="math inline">\(C_1\)</span> is ‘self-dual’ <a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a>. So this is actually the code for which, in Section <a href="#sec:arraydecoding" data-reference-type="ref" data-reference="sec:arraydecoding">2.3</a>, we made this decoding array:</p>
<p><span class="math display">\[\begin{array}{c|ccc}
 (0,0,0,0) &amp; (1,1,0,0) &amp; (0,0,1,1)&amp; (1,1,1,1) \\ \hline
 (1,0,0,0) &amp; (0,1,0,0) &amp; (1,0,1,1) &amp; (0,1,1,1)  \\
 (0,0,1,0) &amp; (1,1,1,0) &amp; (0,0,0,1) &amp; (1,1,0,1)  \\
 (1,0,1,0) &amp; (0,1,1,0) &amp; (1,0,0,1  &amp; (0,1,0,1)  \\ 
\end{array}\]</span></p>
<p>We see that the <span class="math inline">\({\bf c}_i\)</span> are in the top row, which lists the code. Also, the left-hand column of the array matches the error-vector column of the look-up table; these are the (guessed) errors we will subtract. And certainly this array gives the same decoding as the look-up table for (1,1,0,1) and (0,0,1,0). We can also see a examples of the following:</p>
<div class="proposition">
<p>Two words are in the same row of a decoding array if and only if they have the same syndrome.</p>
</div>
<div class="proof">
<p>In general, finding the two words in the array (see below) expresses them as <span class="math inline">\({\bf y}_1 ={\bf c}_1 +{\bf x}_1\)</span> and <span class="math inline">\({\bf y}_2 ={\bf c}_2 +{\bf x}_2\)</span>, with <span class="math inline">\({\bf c}_1 \in C\)</span>, and we know already that <span class="math inline">\(S({\bf y}_1) = S({\bf x}_1)\)</span> and <span class="math inline">\(S({\bf y}_2) = S({\bf x}_2)\)</span>.</p>
<p><span class="math inline">\(\begin{array}{c|cccccc}
{\bf 0} &amp;  &amp;  &amp; {\bf c}_2 &amp;  &amp; {\bf c}_1&amp; \\ \hline
    &amp;    &amp;   &amp;    &amp;  &amp; &amp;  \\ 
{\bf x}_1 &amp;   &amp;  &amp;  &amp;  &amp; {\bf y}_1&amp; \\ 
 &amp;  &amp;  &amp;       &amp;   &amp; &amp; \\
 {\bf x}_2 &amp;   &amp;  &amp; {\bf y}_2 &amp;  &amp; &amp; \\
\end{array}\)</span></p>
<p>If <span class="math inline">\({\bf y}_1\)</span> and <span class="math inline">\({\bf y}_2\)</span> are in the same row, then <span class="math inline">\({\bf x}_1 ={\bf x}_2 = {\bf x}\)</span>, so <span class="math inline">\(S({\bf y}_1) = S({\bf y}_2) = S({\bf x})\)</span>.</p>
<p>Conversely, if <span class="math inline">\(S({\bf y}_1) = S({\bf y}_2)\)</span> then <span class="math inline">\(S({\bf y}_1 -{\bf y}_2) = S({\bf y}_1) -S({\bf y}_2) = {\bf 0}\)</span>, so <span class="math inline">\({\bf y}_1 -{\bf y}_2  = {\bf c}\in C\)</span>. Then <span class="math inline">\({\bf y}_1  = {\bf y}_2+{\bf c}= {\bf x}_2 + {\bf c}_2 + {\bf c}\)</span>. Since <span class="math inline">\({\bf c}_2 + {\bf c}\in C\)</span>, it must be in the top row, so <span class="math inline">\({\bf y}_1\)</span> is in <span class="math inline">\({\bf x}_2\)</span>’s row.</p>
</div>
<p>In effect, syndrome decoding is just a more efficient way to do array decoding; without either making or searching through the array, finding <span class="math inline">\(S({\bf y})\)</span> tells us which row of the array <span class="math inline">\({\bf y}\)</span> would be on. So it follows from Proposition <a href="#prop:arraydecodingnearestneighbour" data-reference-type="ref" data-reference="prop:arraydecodingnearestneighbour">[prop:arraydecodingnearestneighbour]</a> that syndrome decoding, also, is nearest-neighbour decoding. (We can also prove this directly: Q53)</p>
<p>As with the array, there is some choice in the construction of the syndrome look-up table; it comes in the initial ordering of the words of <span class="math inline">\({\mathbb F}_q^n\)</span>. If this is different, we may get a different column of error-vectors to subtract, which will certainly result in different decoding of some words.</p>
<div id="eg:linearsyndrome" class="exampleqed">
<p>Let <span class="math inline">\(C_2 = \{{\bf x}\in {\mathbb F}_3^3\; | \; {\bf x}H^t = 0\}\)</span>, where <span class="math inline">\(H = \left(\begin{matrix} 
1 &amp; 0 &amp; 2   \\
0 &amp; 1 &amp; 2  \\
\end{matrix}\right)\)</span> is a check-matrix for <span class="math inline">\(C_2\)</span>. Then this is one possible syndrome look-up table:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">Syndrome <span class="math inline">\(S({\bf x})\)</span></th>
<th style="text-align: center;">Error-vector <span class="math inline">\({\bf x}\)</span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">(0,0)</td>
<td style="text-align: center;">(0,0,0)</td>
</tr>
<tr class="even">
<td style="text-align: center;">(1,0)</td>
<td style="text-align: center;">(1,0,0)</td>
</tr>
<tr class="odd">
<td style="text-align: center;">(2,0)</td>
<td style="text-align: center;">(2,0,0)</td>
</tr>
<tr class="even">
<td style="text-align: center;">(0,1)</td>
<td style="text-align: center;">(0,1,0)</td>
</tr>
<tr class="odd">
<td style="text-align: center;">(0,2)</td>
<td style="text-align: center;">(0,2,0)</td>
</tr>
<tr class="even">
<td style="text-align: center;">(2,2)</td>
<td style="text-align: center;">(0,0,1)</td>
</tr>
<tr class="odd">
<td style="text-align: center;">(1,1)</td>
<td style="text-align: center;">(0,0,2)</td>
</tr>
<tr class="even">
<td style="text-align: center;">(1,2)</td>
<td style="text-align: center;">(1,2,0)</td>
</tr>
<tr class="odd">
<td style="text-align: center;">(2,1)</td>
<td style="text-align: center;">(1,0,2)</td>
</tr>
</tbody>
</table>
<p>Here we have used every possible <span class="math inline">\({\bf x}\)</span> of weight 1, so the order in which we considered them did not matter. But the last two lines could instead be:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">Syndrome <span class="math inline">\(S({\bf x})\)</span></th>
<th style="text-align: center;">Error-vector <span class="math inline">\({\bf x}\)</span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">(2,1)</td>
<td style="text-align: center;">(0,2,1)</td>
</tr>
<tr class="even">
<td style="text-align: center;">(1,2)</td>
<td style="text-align: center;">(2,0,1)</td>
</tr>
</tbody>
</table>
<p>We can conclude that any error-vector of weight <span class="math inline">\(\leq\)</span> 1, but only some errors of weight 2, will be correctly identified and subtracted. Which errors of weight 2 are correctly subtracted, and which are not, depends on which table we use. For this reason we might decide to practice incomplete decoding: cut the table short, and if we receive a word with syndrome (1,2) or (2,1) ask for retransmission.</p>
</div>
<p>Looking back to <span class="math inline">\(C_1\)</span>, we see that the table lists only some <span class="math inline">\({\bf x}\)</span>’s of weight 1, so we cannot be sure of reliably correcting even error-vectors of weight 1. But we knew this: <span class="math inline">\(d(C_1) =2\)</span>, so by Proposition <a href="#prop:correctdetect" data-reference-type="ref" data-reference="prop:correctdetect">[prop:correctdetect]</a> we will detect a single symbol-error, but nearest-neighbour decoding may not correct it.</p>
<p>On the other hand, using Proposition <a href="#prop:dualstandardform" data-reference-type="ref" data-reference="prop:dualstandardform">[prop:dualstandardform]</a> (or by guessing and checking) we find that <span class="math inline">\(C_2 = \{(0,0,0),(1,1,1),(2,2,2)\}\)</span>, so <span class="math inline">\(d(C_2)=3\)</span> and we can indeed reliably correct one symbol-error, but not two. Equivalently we know that for this code, spheres <span class="math inline">\(S({\bf c},1)\)</span> around the codewords are disjoint, but the <span class="math inline">\(S({\bf c},2)\)</span> intersect. (Q24 and 25 consider alternative arrays for this code.)</p>
<p>The examples we’ve discussed so far have all been for binary or ternary codes. For codes over a larger alphabet, the number of rows in a syndrome table can get quite large. However, since the syndrome is a linear map on <span class="math inline">\({\mathbb F}_q^n\)</span>, we have <span class="math inline">\(S(\lambda {\bf y})=\lambda S({\bf y})\)</span> for any non-zero <span class="math inline">\(\lambda \in {\mathbb F}_q^n\)</span> – we can see this explicitly in Example <a href="#eg:linearsyndrome" data-reference-type="ref" data-reference="eg:linearsyndrome">[eg:linearsyndrome]</a> above.</p>
<p>For codes with <span class="math inline">\(q&gt;2\)</span>, we can therefore define a <em>reduced</em> syndrome table, where we only add new syndromes to our table if they aren’t of the form <span class="math inline">\(\lambda S({\bf x})\)</span>, for any non-zero <span class="math inline">\(\lambda \in {\mathbb F}_q\)</span>, and any <span class="math inline">\(S({\bf x})\)</span> already in our table. To decode a received word <span class="math inline">\({\bf y}\)</span>, we then calculate <span class="math inline">\(S({\bf y})\)</span> as normal, but now we need to find the row such that <span class="math inline">\(\lambda S({\bf y})\)</span> is in the first column, for some non-zero <span class="math inline">\(\lambda\)</span> which we need to calculate. We then decode <span class="math inline">\({\bf y}\)</span> to <span class="math inline">\({\bf y}- \lambda {\bf x}\)</span>, where <span class="math inline">\({\bf x}\)</span> is the error vector in the corresponding row of our table. See Q52 for an example of this idea.</p>
</section>
<section id="minimum-distance-from-a-check-matrix" class="level2" data-number="4.4">
<h2 data-number="4.4"><span class="header-section-number">4.4</span> Minimum distance from a check-matrix</h2>
<p>In the last section, <span class="math inline">\(d(C)\)</span> turned out to be relevant to the reliability of our syndrome look-up table. But to find it, we had first to find the words of the code. We will now establish a way to get <span class="math inline">\(d(C)\)</span> directly from a check-matrix, which links up many of the ideas so far.</p>
<p>In fact, it only needs to be an “acting check-matrix". We start with the following:</p>
<div id="lem:lindepcolsweight" class="lemma">
<p>For some <span class="math inline">\(A \in M_{m,n}({\mathbb F}_q)\)</span>, let <span class="math inline">\(C = \{{\bf x}\in {\mathbb F}_q^n \;|\; {\bf x}A^t = {\bf 0}\}\)</span>. Then: There are <span class="math inline">\(d\)</span> columns of A which are linearly dependent <span class="math inline">\(\Longleftrightarrow\)</span> there is some codeword <span class="math inline">\({\bf c}\in C\)</span> with <span class="math inline">\(0 &lt; w({\bf c}) \leq d\)</span>.</p>
</div>
<div class="proof">
<p>Let the columns of <span class="math inline">\(A\)</span> be <span class="math inline">\({\bf a}_1,  \ldots, {\bf a}_n\)</span>.</p>
<p><span class="math inline">\(\Longrightarrow\)</span> Suppose we have <span class="math inline">\(d\)</span> linearly dependent columns, <span class="math inline">\({\bf a}_{i_1},  \ldots, {\bf a}_{i_d}\)</span>. This means there exist <span class="math inline">\(\lambda_1, \lambda_2, \ldots, \lambda_d\)</span> in <span class="math inline">\({\mathbb F}_q\)</span>, not all 0, such that <span class="math inline">\(\lambda_1 {\bf a}_{i_1} +  \cdots + \lambda_d {\bf a}_{i_d} = {\bf 0}\)</span>. Now let <span class="math inline">\({\bf c}\)</span> be a word with <span class="math inline">\(\lambda_j\)</span> in position <span class="math inline">\(i_j\)</span>, 0 elsewhere. Then <span class="math inline">\(0 &lt; w({\bf c})\leq d\)</span>. But also, when multiplying <span class="math inline">\({\bf c}A^t\)</span>, each <span class="math inline">\(\lambda_j\)</span> picks out row <span class="math inline">\(i_j\)</span> of <span class="math inline">\(A^t\)</span>, so <span class="math display">\[{\bf c}A^t = (0, \ldots 0 ,\lambda_1, 0, \ldots, 0,\lambda_d, 0,\ldots, 0)
 \left(\begin{array}{ccc} 
  &amp; \vdots &amp; \\
 -&amp; {\bf a}_{i_1} &amp; - \\ 
    &amp; \vdots  &amp;\\ 
    - &amp; {\bf a}_{i_d} &amp; - \\
      &amp; \vdots &amp;
    \end{array}\right) 
      =\lambda_1 {\bf a}_{i_1}  + \cdots + \lambda_d {\bf a}_{i_d} = {\bf 0}.\]</span> So <span class="math inline">\({\bf c}\in C\)</span>.</p>
<p><span class="math inline">\(\Longleftarrow\)</span> If <span class="math inline">\({\bf c}= (c_1,c_2, \ldots, c_n) \in C\)</span>, and <span class="math inline">\(0&lt; w({\bf c}) \leq d\)</span>, we know that <span class="math inline">\(c_1{\bf a}_1  + \cdots  +c_n{\bf a}_n = {\bf c}A^t = 0\)</span>, and that between 1 and <span class="math inline">\(d\)</span> of the <span class="math inline">\({\bf c}_i\)</span> are non-zero. If we choose <span class="math inline">\(c_{i_1},  \ldots, c_{i_d}\)</span> to include all the non-zero <span class="math inline">\(c_i\)</span>, then we still have <span class="math inline">\(c_{i_1} {\bf a}_{i_1}  + \cdots + c_{i_d} {\bf a}_{i_d} = 0\)</span>, with not all <span class="math inline">\(c_i = 0\)</span>. Thus <span class="math inline">\({\bf a}_{i_1},  \ldots, {\bf a}_{i_d}\)</span> are linearly dependent.</p>
</div>
<div class="exampleqed">
<p>Let <span class="math inline">\(C = \{ {\bf x}\in {\mathbb F}_7^5 \; |\; {\bf x}A^t = 0\}\)</span>, where <span class="math inline">\(A = \left( \begin{array}{ccccc}
3  &amp; 1  &amp; 1  &amp; 4 &amp; 1 \\ 
2  &amp; 2  &amp; 5  &amp; 1 &amp; 4 \\
6  &amp;  3 &amp; 5  &amp; 0 &amp; 2   
 
\end{array} \right)  \in M_{3,5}({\mathbb F}_7)\)</span>. Because <span class="math inline">\((0,1,2,0,4)  \left( \begin{array}{ccc} 
                             3 &amp; 2 &amp; 6 \\
                             1 &amp; 2 &amp; 3 \\
                             1 &amp; 5 &amp; 5 \\
                             4 &amp; 1 &amp; 0 \\
                             1 &amp; 4 &amp; 2 
                            \end{array} \right)  = (0,0,0)\)</span>, we know two things:</p>
<ul>
<li><p><span class="math inline">\((0,1,2,0,4) \in C\)</span>, so <span class="math inline">\(C\)</span> contains a codeword of weight 3.</p></li>
<li><p><span class="math inline">\(1(1,2,3) + 2(1,5,5) + 4(1,2,4) = (0,0,0 )\)</span>, so <span class="math inline">\(A\)</span> has 3 columns which are linearly dependent.</p></li>
</ul>
</div>
<div id="thm:lindepcolsdistance" class="theorem">
<p>For some <span class="math inline">\(A \in M_{m,n}({\mathbb F}_q)\)</span>, let <span class="math inline">\(C = \{{\bf x}\in {\mathbb F}_q^n \;|\; {\bf x}A^t = {\bf 0}\}\)</span>. Then there is some set of <span class="math inline">\(d(C)\)</span> columns of <span class="math inline">\(A\)</span> which are linearly dependent, but any <span class="math inline">\(d(C)-1\)</span> columns of <span class="math inline">\(A\)</span> are linearly independent.</p>
</div>
<div class="proof">
<p>For a linear code, by Proposition <a href="#prop:mindminw" data-reference-type="ref" data-reference="prop:mindminw">[prop:mindminw]</a> <span class="math inline">\(d(C) = min\{w({\bf c})\;|\;{\bf c}\in C, {\bf c}\neq {\bf 0}\}\)</span>. So we know:</p>
<ul>
<li><p>There is some <span class="math inline">\({\bf c}\in C\)</span> with <span class="math inline">\(w({\bf c})= d(C)\)</span>. So by Lemma <a href="#lem:lindepcolsweight" data-reference-type="ref" data-reference="lem:lindepcolsweight">[lem:lindepcolsweight]</a> there are <span class="math inline">\(d(C)\)</span> columns which are linearly dependent.</p></li>
<li><p>There is no <span class="math inline">\({\bf c}\in C\)</span> with <span class="math inline">\(w({\bf c}) \leq d(C)-1\)</span>. So by Lemma <a href="#lem:lindepcolsweight" data-reference-type="ref" data-reference="lem:lindepcolsweight">[lem:lindepcolsweight]</a> there is no set of <span class="math inline">\(d(C)-1\)</span> columns which are linearly dependent.</p></li>
</ul>
</div>
<p>This theorem is mostly used in reverse: We find the number <span class="math inline">\(d\)</span> such that <span class="math inline">\(A\)</span> has a set of <span class="math inline">\(d\)</span> dependent columns, but no smaller such sets. Then we conclude that <span class="math inline">\(d\)</span> is the minimum distance of the code. One can remember the theorem as something like “<span class="math inline">\(d(C)\)</span> is the size of a smallest set of linearly dependent columns in the check-matrix".</p>
<div class="exampleqed">
<p>For the code <span class="math inline">\(C\)</span> in the example above, we have found that columns 2, 3 and 5 are linearly dependent. But this only tells us that <span class="math inline">\(d(C)\leq 3\)</span>. To be sure that <span class="math inline">\(d(C) = 3\)</span>, we need also to check that there are no linearly dependent pairs of columns, that is, no column is a multiple of another. For many of the <span class="math inline">\(\binom{5}{2}\)</span> pairs this is easy: its zero means that column 4 is not a multiple of any other, and (since they are not identical) the top entry 1 in columns 2, 3, and 5 means they cannot be multiples of each other. It remains to check that column 1 is not a multiple of column 2, 3 or 5. It is not, so <span class="math inline">\(d(C)=3\)</span>.</p>
</div>
</section>
</section>
<section id="perfect-codes" class="level1" data-number="5">
<h1 data-number="5"><span class="header-section-number">5</span> Perfect Codes</h1>
<p>Having established how linear codes work in general, we now begin to to look more closely at particular codes and types of codes. These will still be linear, but first we will return briefly to ideas from Section <a href="#sec:boundsoncodes" data-reference-type="ref" data-reference="sec:boundsoncodes">1.4</a> about more general codes.</p>
<p>We know (Proposition <a href="#prop:hammingbound" data-reference-type="ref" data-reference="prop:hammingbound">[prop:hammingbound]</a>) that a <span class="math inline">\(q\)</span>-ary <span class="math inline">\((n,M,d)\)</span> code satisfies: <span class="math display">\[M \cdot \sum_{k=0}^t\binom{n}{k} (q-1)^k  \leq q^n, \;\; {\rm where} \; t = \left\lfloor\frac{d-1}{2}\right\rfloor.\]</span> This is because the spheres <span class="math inline">\(S(c,t)\)</span> round all the codewords have to fit into <span class="math inline">\({\mathbb F}_q^n\)</span> without overlapping. If these spheres also fill <span class="math inline">\({\mathbb F}_q^n\)</span> then we have equality and the code is perfect. For a given <span class="math inline">\(q\)</span>, <span class="math inline">\(n\)</span> and <span class="math inline">\(d\)</span>, we have made <span class="math inline">\(M\)</span> as large as possible. Thus for a code to be perfect we need <span class="math inline">\(|S(x,t)| =\sum_{k=0}^t\binom{n}{k} (q-1)^k\)</span> to divide <span class="math inline">\(q^n\)</span>. (If <span class="math inline">\(q\)</span> is a prime power, this means that <span class="math inline">\(|S(x,t)|\)</span> is a power of <span class="math inline">\(q\)</span>.)</p>
<p>There are two very trivial solutions to this, with <span class="math inline">\(t=0\)</span>, or <span class="math inline">\(t = n\)</span> (see Q60) More useful, though still regarded as trivial, are the odd binary repetition codes, for example <span class="math inline">\(\{(0,0,0), (1,1,1)\} \subseteq {\mathbb F}_2^3\)</span> and <span class="math inline">\(\{(0,0,0,0,0), (1,1,1,1,1)\} \subseteq {\mathbb F}_2^5\)</span> (see Q63). Apart from these, computer searches have found that relatively few values for <span class="math inline">\(q\)</span>, <span class="math inline">\(n\)</span> and <span class="math inline">\(d\)</span> have <span class="math inline">\(|S(x,t)|\)</span> dividing <span class="math inline">\(q^n\)</span>. Of non-trivial parameters which meet this criterion, most are parameters for a Hamming code; we shall consider these in section 5.1. Remarkably, for <span class="math inline">\(n\leq 1000,\; d\leq 1000\)</span> and <span class="math inline">\(q\leq 100\)</span> there are only three other possibilities. For <span class="math inline">\(q=2\)</span> a [23,12,7] code or a [90,78,5] code would be perfect, if it exists; for <span class="math inline">\(q=3\)</span> a [11,6,5] code would be perfect. In 1949, Golay showed that a [90,78,5] binary code does not exist (see Q74), but he specified perfect codes for the other two sets of parameters. We shall study these in Section 5.3. Later work has gone on to show that all non-trivial perfect codes either have the same parameters as the Hamming Codes, or the Golay codes, though we won’t prove this in this course.</p>
<section id="hamming-codes" class="level2" data-number="5.1">
<h2 data-number="5.1"><span class="header-section-number">5.1</span> Hamming codes</h2>
<p>If a code is to be able to correct one symbol-error, we need <span class="math inline">\(d \geq 3\)</span>. For a linear code, by Theorem <a href="#thm:lindepcolsdistance" data-reference-type="ref" data-reference="thm:lindepcolsdistance">[thm:lindepcolsdistance]</a>, we can achieve this by making sure that no two columns of its check matrix are multiples of each other. This is simplest in the binary case.</p>
<div class="definition">
<p>For <span class="math inline">\(r \geq 2, \; n= 2^r - 1\)</span>, let the matrix <span class="math inline">\(H \in M_{r,n}({\mathbb F}_2)\)</span> have as columns all non-zero vectors in <span class="math inline">\({\mathbb F}_2^r\)</span>. The <span><strong>binary Hamming code of redundancy <span class="math inline">\(r\)</span></strong></span>, is Ham<span class="math inline">\(_2(r) = \{ {\bf x}\in {\mathbb F}_2^n \; |\; {\bf x}H^t = 0\}\)</span>.</p>
</div>
<div class="exampleqed">
<p>For <span class="math inline">\(r =2\)</span> and <span class="math inline">\(r =3\)</span> respectively, we can take <span class="math inline">\(H_2 = \left(\begin{matrix}
0&amp;1&amp;1\\
1&amp;0&amp;1
\end{matrix}\right)\;\;\)</span> and <span class="math inline">\(\;\;H_3 = \left(\begin{matrix}
0&amp;0&amp;0&amp;1&amp;1&amp;1&amp;1\\
0&amp;1&amp;1&amp;0&amp;0&amp;1&amp;1\\
1&amp;0&amp;1&amp;0&amp;1&amp;0&amp;1\\
\end{matrix}\right)\)</span>.</p>
</div>
<p>Note that, according to the definition, we could have had the columns in any order. Thus strictly Ham<span class="math inline">\(_2(r)\)</span> is not just one code, but an equivalence class of codes.</p>
<div id="prop:binaryhammingcodeparams" class="proposition">
<p> For <span class="math inline">\(r \geq 2\)</span>, Ham<span class="math inline">\(_2(r)\)</span> is a perfect <span class="math inline">\([2^r -1, 2^r-r-1, 3 \;]\)</span> code, with check matrix <span class="math inline">\(H\)</span>.</p>
</div>
<div class="proof">
<p>There are five things to check here:</p>
<ul>
<li><p><span class="math inline">\(n= 2^r - 1\)</span>: There are <span class="math inline">\(|{\mathbb F}_2^r - \{{\bf 0}\}|\)</span> columns in <span class="math inline">\(H\)</span>.</p></li>
<li><p><span class="math inline">\(H\)</span> is a check-matrix for Ham<span class="math inline">\(_2(r)\)</span>: Since <span class="math inline">\(H\)</span> is certainly acting-check, we need only show its rows are linearly independent. This is clear since its columns include standard basis vectors <span class="math inline">\({\bf e}_1, \ldots, {\bf e}_r\)</span>, so each row has (at least) one entry 1 where all other rows have 0.</p></li>
<li><p><span class="math inline">\(k = 2^r - r -1\)</span>: As <span class="math inline">\(H\)</span> is a check-matrix, it has <span class="math inline">\(n-k\)</span> rows, so <span class="math inline">\(n-r = k\)</span>.</p></li>
<li><p><span class="math inline">\(d= 3\)</span>: No column is a multiple of another, but columns <span class="math inline">\({\bf e}_1, {\bf e}_2\)</span> and <span class="math inline">\({\bf e}_1+{\bf e}_2\)</span> are linearly dependent.</p></li>
<li><p>Ham<span class="math inline">\(_2(r)\)</span> is perfect: We know <span class="math inline">\(|{\rm Ham}_2(r)| = 2^k = 2^{2^r-r-1}\)</span>, and that by Lemma 1.7 <span class="math inline">\(|S(c,1)| = 1+n =2^r\)</span>. But then since the <span class="math inline">\(S(c,1)\)</span> are disjoint, <span class="math inline">\(|\bigcup_{c \in C} S(c,1)| = 2^{2^r-r-1} \cdot 2^r  = 2^n\)</span>. So the spheres fill the space.</p></li>
</ul>
</div>
<p>If we choose the right order for the columns of <span class="math inline">\(H\)</span>, we can decode very neatly, without even making a syndrome table. Notice that in the matrices above, the columns actually count in binary, from left to right. For example, in <span class="math inline">\(H_3\)</span> the sixth column is 110, which is the binary representation of six.</p>
<p><span><strong>Algorithm: Decoding for binary Hamming codes.</strong></span></p>
<ol>
<li><p>Use the Ham<span class="math inline">\(_2(r)\)</span> with check-matrix H having column <span class="math inline">\(j\)</span> equal to the binary representation of <span class="math inline">\(j\)</span>, for <span class="math inline">\(1\leq j\leq n= 2^r - 1\)</span>.</p></li>
<li><p>Having received <span class="math inline">\({\bf y}\in {\mathbb F}_2^n\)</span>, compute its syndrome <span class="math inline">\(S({\bf y}) ={\bf y}H^t\)</span></p></li>
<li><p>If <span class="math inline">\(S({\bf y}) = 0\)</span>, then <span class="math inline">\({\bf y}\)</span> is a codeword, so decode as <span class="math inline">\({\bf y}\)</span>.</p></li>
<li><p>Otherwise, read <span class="math inline">\(S({\bf y})\)</span> as a number <span class="math inline">\(j\)</span> in binary, and decode <span class="math inline">\({\bf y}\)</span> by changing its <span class="math inline">\(j\)</span>th entry.</p></li>
</ol>
<div class="exampleqed">
<p>Suppose we are using Ham<span class="math inline">\(_2(3)\)</span>, with check-matrix <span class="math inline">\(H_3\)</span> as above, and we receive <span class="math inline">\({\bf y}= (0,1,1,0,1,0,1)\)</span>. Then <span class="math inline">\(S({\bf y}) = {\bf y}(H_3)^t = (0,1,1)\)</span>. Since 011 in binary is three, we change the third entry of <span class="math inline">\(y\)</span>, and decode it as <span class="math inline">\((0,1,0,0,1,0,1)\)</span>.</p>
</div>
<p>Why does this algorithm work? Since the <span class="math inline">\(S({\bf c},1)\)</span> partition <span class="math inline">\({\mathbb F}_2^n\)</span>, any received <span class="math inline">\({\bf y}\)</span> equals <span class="math inline">\({\bf c}+ {\bf x}\)</span>, where <span class="math inline">\({\bf c}\in {\rm Ham}_2(r)\)</span>, and <span class="math inline">\(w({\bf x})\leq 1\)</span>. If <span class="math inline">\(w({\bf x})=1\)</span>, then <span class="math inline">\({\bf x}= {\bf e}_j\)</span> for some <span class="math inline">\(j\)</span>. So <span class="math inline">\(S({\bf y}) = ({\bf c}+{\bf e}_j)H^t = {\bf e}_jH^t =  j^{th}\)</span> row of <span class="math inline">\(H^t =\)</span> binary representation of <span class="math inline">\(j\)</span>. By changing the <span class="math inline">\(j\)</span>th entry of <span class="math inline">\({\bf y}\)</span>, we find <span class="math inline">\({\bf y}- {\bf e}_j = {\bf c}\)</span>.</p>
<p>We can also make Hamming codes with <span class="math inline">\(q &gt; 2\)</span>, but we must take more care to avoid two columns of <span class="math inline">\(H\)</span> being multiples of each other. Let <span class="math inline">\({\bf v}\)</span> be one of the <span class="math inline">\(q^r -1\)</span> non-zero vectors in <span class="math inline">\({\mathbb F}_q^r\)</span>, and consider the set <span class="math inline">\(L_{{\bf v}} = \{ \lambda {\bf v}\;|\; \lambda \in {\mathbb F}_q, \lambda \neq 0 \}\)</span>. Then <span class="math inline">\(|L_{{\bf v}}| = q-1\)</span>, and if <span class="math inline">\({\bf w}\in L_{{\bf v}}\)</span>, we have <span class="math inline">\(L_{{\bf w}} = L_{{\bf v}}\)</span>. So the <span class="math inline">\(L_{{\bf v}}\)</span> partition <span class="math inline">\({\mathbb F}_q^n -\{{\bf 0}\}\)</span>, and there are <span class="math inline">\((q^r-1)/(q-1)\)</span> of them.</p>
<div class="exampleqed">
<p>For <span class="math inline">\(q=3,\; r=2\)</span> we have <span class="math inline">\(8/2 =4\)</span> sets: <span class="math display">\[L_{(0,1)} = \{(0,1),(0,2)\},\;L_{(1,0)} = \{(1,0),(2,0)\},\]</span> <span class="math display">\[L_{(1,1)} = \{(1,1),(2,2)\},\;L_{(1,2)} = \{(1,2),(2,1)\}.\]</span></p>
</div>
<div class="definition">
<p>For <span class="math inline">\(r \geq 2, \; n= (q^r - 1)/(q-1)\)</span>, let the sets <span class="math inline">\(L_{{\bf v}}\)</span> as above partition <span class="math inline">\({\mathbb F}_q^n -\{{\bf 0}\}\)</span>. Construct <span class="math inline">\(H \in M_{r,n}({\mathbb F}_q)\)</span> by taking one column from each <span class="math inline">\(L_{{\bf v}}\)</span>. The <span><strong>Hamming code of redundancy <span class="math inline">\(r\)</span></strong></span>, is Ham<span class="math inline">\(_q(r) = \{ {\bf x}\in {\mathbb F}_q^n \; |\; {\bf x}H^t = 0\}\)</span>.</p>
</div>
<div class="exampleqed">
<p>For Ham<span class="math inline">\(_3(2)\)</span>, <span class="math inline">\(H\)</span> could be <span class="math inline">\(\left(\begin{matrix}
0&amp;2&amp;2&amp;2\\1&amp;2&amp;0&amp;1\\
\end{matrix}\right)\)</span>.</p>
</div>
<div id="prop:qaryhammingcodeparams" class="proposition">
<p> For <span class="math inline">\(r \geq 2\)</span>, Ham<span class="math inline">\(_q(r)\)</span> is a perfect <span class="math inline">\([n, n-r, 3 \;]\)</span> code, with check-matrix <span class="math inline">\(H\)</span>.</p>
</div>
<p>Notice that this definition, and Proposition <a href="#prop:binaryhammingcodeparams" data-reference-type="ref" data-reference="prop:binaryhammingcodeparams">[prop:binaryhammingcodeparams]</a>, actually include the binary case discussed above. The proof of Proposition <a href="#prop:qaryhammingcodeparams" data-reference-type="ref" data-reference="prop:qaryhammingcodeparams">[prop:qaryhammingcodeparams]</a> is almost the same as that of Proposition <a href="#prop:binaryhammingcodeparams" data-reference-type="ref" data-reference="prop:binaryhammingcodeparams">[prop:binaryhammingcodeparams]</a>; proving <span class="math inline">\(d = 3\)</span>, and that the code is perfect, need a little more detail (see Q67). Again, a different choice and/or ordering of vectors for the columns of <span class="math inline">\(H\)</span> will give an equivalent code. For the following algorithm, it may be convenient to choose each column so that its last non-zero entry is 1. Again we exploit the fact that the Ham<span class="math inline">\(_q(r)\)</span> is perfect.</p>
<p><span><strong>Algorithm: Decoding for Hamming codes.</strong></span></p>
<ol>
<li><p>Having received <span class="math inline">\({\bf y}\in {\mathbb F}_q^n\)</span>, compute its syndrome <span class="math inline">\(S({\bf y}) ={\bf y}H^t\)</span></p></li>
<li><p>If <span class="math inline">\(S({\bf y}) = 0\)</span>, then <span class="math inline">\({\bf y}\)</span> is a codeword, so decode as <span class="math inline">\({\bf y}\)</span>.</p></li>
<li><p>Otherwise, find <span class="math inline">\(j\)</span> and <span class="math inline">\(\lambda\)</span> such that <span class="math inline">\(S({\bf y})\)</span> is <span class="math inline">\(\lambda\)</span> times the <span class="math inline">\(j^{th}\)</span> column of <span class="math inline">\(H\)</span>, and decode <span class="math inline">\({\bf y}\)</span> as <span class="math inline">\({\bf y}-\lambda {\bf e}_j\)</span>.</p></li>
</ol>
<div class="exampleqed">
<p>Let us use Ham<span class="math inline">\(_3(2)\)</span>, with <span class="math inline">\(H =\left(\begin{matrix}
1&amp;0&amp;1&amp;2\\0&amp;1&amp;1&amp;1\\
\end{matrix}\right)\)</span>. If <span class="math inline">\({\bf y}= (2,1,0,1)\)</span> is received, then <span class="math inline">\(S({\bf y}) = (1,2)\)</span>, which is twice the last column of <span class="math inline">\(H\)</span>. So we decode to <span class="math inline">\({\bf y}- 2{\bf e}_4 = (2,1,0,2)\)</span>.</p>
</div>
</section>
<section id="extending-and-puncturing" class="level2" data-number="5.2">
<h2 data-number="5.2"><span class="header-section-number">5.2</span> Extending and Puncturing</h2>
<p>To improve error-correction or -detection we may wish to increase the minimum distance of a code, even at the expense of longer codewords. One way to attempt this is to extend the code. This puts the codewords into a bigger space, so they may be further apart.</p>
<div class="definition">
<p>Let the <span class="math inline">\([n,k,d]\)</span> code <span class="math inline">\(C\)</span> have check-matrix <span class="math inline">\(H\)</span>. Then the <span><strong>extended</strong></span> code <span class="math inline">\(\widehat{C}\)</span> has check-matrix <span class="math inline">\(\widehat{H} = \left(\begin{matrix}
 &amp; &amp; &amp;0 \\
  &amp;H&amp; &amp;\vdots\\
  &amp; &amp; &amp; 0 \\
 1&amp; \cdots &amp;1&amp;1 \\
\end{matrix}\right)\)</span>.</p>
</div>
<p>The last row perform a “parity check": it requires that the entries of a codeword add to zero.</p>
<p>The definition implies that the rows of <span class="math inline">\(\widehat{H}\)</span> are linearly independent, but this is true, because the rows of <span class="math inline">\(H\)</span> were linearly independent, and only the last row has a non-zero entry in the last column.</p>
<div id="prop:extendedcodeparams" class="proposition">
<p> If <span class="math inline">\(C\)</span> is an <span class="math inline">\([n,k,d]\)</span> code then <span class="math inline">\(\widehat{C}\)</span> is an <span class="math inline">\([n&#39;,k&#39;,d&#39;]\)</span> code, with <span class="math inline">\(n&#39; = n+1\)</span>, <span class="math inline">\(k&#39; = k\)</span>, and <span class="math inline">\(d \leq d&#39;\leq d+1\)</span>.</p>
</div>
<div class="proof">
<p>Clearly <span class="math inline">\(n&#39; = n+1\)</span>. Since <span class="math inline">\(\widehat{H}\)</span> is a check matrix for <span class="math inline">\(\widehat{C}\)</span>, it has <span class="math inline">\(n&#39;-k&#39;\)</span> rows, but it also has one more row than <span class="math inline">\(H\)</span>, so <span class="math inline">\((n+1)-k&#39; = (n-k)+1\)</span>. Using Thm. 4.11, it is clear that <span class="math inline">\(d \leq d&#39;\)</span>, because if some set of columns of <span class="math inline">\(\widehat{H}\)</span> is linearly dependent, then certainly those columns of <span class="math inline">\(H\)</span> must also be linearly dependent <a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a>. On the other hand, if some set of columns of <span class="math inline">\(H\)</span> are linearly dependent, those columns in <span class="math inline">\(\widehat{H}\)</span> will not usually satisfy this relationship; we may need to use the last column to make zero in the last co-ordinate.</p>
</div>
<div id="eg:extendedhamming" class="exampleqed">
<p> Let <span class="math inline">\(C_2 \subseteq F_2^3\)</span> and <span class="math inline">\(C_3\subseteq F_3^4\)</span> have check-matrices <span class="math display">\[H_2 = \left(\begin{matrix}
1 &amp; 0&amp;1  \\
 0 &amp; 1&amp; 1\\
\end{matrix}\right), \;\;
\text{and} \;\; H_3 = \left(\begin{matrix}
1 &amp; 0&amp;1 &amp;2 \\
 0 &amp; 1&amp; 1&amp;1\\
 \end{matrix}\right).\]</span> Then <span class="math inline">\(\widehat{C}_2\)</span> and <span class="math inline">\(\widehat{C}_3\)</span> have check-matrices <span class="math inline">\(\widehat{H}_2 = \left(\begin{matrix}
1 &amp; 0&amp;1 &amp;0 \\
 0 &amp; 1&amp; 1&amp;0\\
 1&amp; 1&amp; 1&amp;  1 \\
\end{matrix}\right)\)</span>, and <span class="math inline">\(\widehat{H}_3 = \left(\begin{matrix}
1 &amp; 0&amp;1 &amp;2&amp;0 \\
 0 &amp; 1&amp; 1&amp;1&amp;0\\
  1&amp; 1&amp; 1&amp; 1 &amp;1\\
\end{matrix}\right)\)</span>. Looking at the columns of <span class="math inline">\(H_2\)</span> and <span class="math inline">\(\widehat{H}_2\)</span>, it is clear that <span class="math inline">\(d(C_2)=3\)</span> but <span class="math inline">\(d(\widehat{C}_2)=4\)</span>. On the other hand, in both <span class="math inline">\(H_3\)</span> and <span class="math inline">\(\widehat{H}_3\)</span> columns 2 to 4 add up to zero, so <span class="math inline">\(d(C_3) = d(\widehat{C}_3)=3\)</span>.</p>
</div>
<p>Here <span class="math inline">\(C_2\)</span> is a Ham<span class="math inline">\(_2(2)\)</span> code, so this is an example of the following:</p>
<p><span id="cor:extendedbinary" label="cor:extendedbinary">[cor:extendedbinary]</span> If a binary <span class="math inline">\([n,k,d]\)</span> code <span class="math inline">\(C\)</span> has <span class="math inline">\(d\)</span> odd, then <span class="math inline">\(\widehat{C}\)</span> is a <span class="math inline">\([n+1, k, d+1]\)</span> code.</p>
<div class="proof">
<p>Using Proposition <a href="#prop:extendedcodeparams" data-reference-type="ref" data-reference="prop:extendedcodeparams">[prop:extendedcodeparams]</a>, we need only show for Theorem <a href="#thm:lindepcolsdistance" data-reference-type="ref" data-reference="thm:lindepcolsdistance">[thm:lindepcolsdistance]</a> that any <span class="math inline">\(d\)</span> columns in the check-matrix for <span class="math inline">\(\widehat{C}\)</span> are linearly independent. But this is clear, as their last entries must add to 1 in <span class="math inline">\({\mathbb F}_2\)</span>.</p>
</div>
<p><span id="cor:extendedhamming" label="cor:extendedhamming">[cor:extendedhamming]</span> The extended binary Hamming code <span class="math inline">\({\rm H\widehat{am}}_2(r)\)</span> is a <span class="math inline">\([2^r, 2^r-r-1, 4]\)</span> code.</p>
<p>Since 4 is even, <span class="math inline">\({\rm H\widehat{am}}_2(r)\)</span> is not perfect (see Q16). By Prop.1.2, <span class="math inline">\({\rm H\widehat{am}}_2(r)\)</span> can still only correct one symbol-error, but it can detect two. This is a gain worth having, particularly if we can ask for retransmission. (Strictly, it can detect three - but with three symbol-errors even unique-nearest-neighbour decoding may give the wrong answer.)</p>
<p>Suppose we have two equivalent codes, <span class="math inline">\(C\)</span> and <span class="math inline">\(C&#39;\)</span>, with check-matrices <span class="math inline">\(H\)</span> and <span class="math inline">\(H&#39;\)</span>, and we form the extended codes <span class="math inline">\(\widehat{C}\)</span> and <span class="math inline">\(\widehat{C}&#39;\)</span>, with check-matrices <span class="math inline">\(\widehat{H}\)</span> and <span class="math inline">\(\widehat{H}&#39;\)</span>. Will <span class="math inline">\(\widehat{C}\)</span> and <span class="math inline">\(\widehat{C}&#39;\)</span> be equivalent? If the codes are binary then yes: <span class="math inline">\(H\)</span> and <span class="math inline">\(H&#39;\)</span> have the same columns in a (possibly) different order, and so do <span class="math inline">\(\widehat{H}\)</span> and <span class="math inline">\(\widehat{H}&#39;\)</span>. But if <span class="math inline">\(q \geq3\)</span>, then some column of <span class="math inline">\(H&#39;\)</span> may be a multiple (<span class="math inline">\(\lambda \neq 0, \neq1\)</span>) of a column of <span class="math inline">\(H\)</span>. With one added at the end of each, they are no longer multiples, so <span class="math inline">\(\widehat{C}\)</span> and <span class="math inline">\(\hat{C}&#39;\)</span> may not be equivalent (Q70).</p>
<p>To find a generator-matrix for an extended code, we can use the <span class="math inline">\(G \leftrightarrow H\)</span> algorithm on <span class="math inline">\(\widehat{H}\)</span>. But we can also get it directly from the original generator-matrix, by adding an overall check-digit to each row, and so to each codeword.</p>
<p><span><strong>Notation:</strong></span> If <span class="math inline">\({\bf g}= (g_1, \,\ldots,\, g_n)\)</span>, we write <span class="math inline">\(({\bf g},\, a)\)</span> for <span class="math inline">\((g_1, \,\ldots,\, g_n, a)\)</span>.</p>
<div id="prop:extendedgeneratormatrix" class="proposition">
<p> If <span class="math inline">\(C\)</span> has generator-matrix <span class="math inline">\(G\)</span> with rows <span class="math inline">\({\bf g}_i = (g_{i1}, \,\ldots,\, g_{in})\)</span>, for <span class="math inline">\(\leq i \leq k\)</span>, then <span class="math inline">\(\widehat{C}\)</span> has generator-matrix <span class="math inline">\(\widehat{G}\)</span> with rows <span class="math inline">\(\widehat{{\bf g}_i} = ({\bf g}_i,\, -\sum_{j=1}^n g_{ij})\)</span></p>
</div>
<div id="eg:extendedgeneratormatrix" class="exampleqed">
<p> Using Proposition <a href="#prop:dualstandardform" data-reference-type="ref" data-reference="prop:dualstandardform">[prop:dualstandardform]</a>, the code <span class="math inline">\(C_3\)</span> from Example <a href="#eg:extendedhamming" data-reference-type="ref" data-reference="eg:extendedhamming">[eg:extendedhamming]</a> has generator matrix <span class="math display">\[G = \left( \begin{array}{cccc}
			2 &amp; 2 &amp; 1 &amp; 0 \\
			1 &amp; 2 &amp; 0 &amp; 1
		\end{array} \right).\]</span></p>
<p>Using Proposition <a href="#prop:extendedgeneratormatrix" data-reference-type="ref" data-reference="prop:extendedgeneratormatrix">[prop:extendedgeneratormatrix]</a>, the generator matrix for <span class="math inline">\(\widehat{C}_3\)</span> is therefore <span class="math display">\[\widehat{G} = \left( \begin{array}{ccccc}
			2 &amp; 2 &amp; 1 &amp; 0 &amp; 1 \\
			1 &amp; 2 &amp; 0 &amp; 1 &amp; 2
		\end{array} \right),\]</span> and one can easily check that the rows of this matrix are orthogonal to the extended check matrix in Example <a href="#eg:extendedhamming" data-reference-type="ref" data-reference="eg:extendedhamming">[eg:extendedhamming]</a>.</p>
</div>
<div class="proof">
<p>(Of These <span class="math inline">\(\widehat{{\bf g}_i}\)</span> are linearly independent, and there are <span class="math inline">\(k\)</span> of them as required. We need only check that they are in <span class="math inline">\(\widehat{C}\)</span>. Let the rows of <span class="math inline">\(C\)</span>’s check-matrix <span class="math inline">\(H\)</span> be <span class="math inline">\({\bf h}_1,\,\ldots,\,{\bf h}_{n-k}\)</span>. Then <span class="math inline">\(\widehat{C}\)</span> has check-matrix <span class="math inline">\(\widehat{H}\)</span> with rows <span class="math inline">\(\widehat{{\bf h}}_1 =({\bf h}_1,0),\,\ldots,\,\widehat{{\bf h}}_{n-k}=({\bf h}_{n-k},0)\)</span> and <span class="math inline">\(\widehat{{\bf h}}_{n-k+1}=(1, \ldots, 1)\)</span>. Then <span class="math display">\[\begin{aligned}
		\widehat{{\bf g}_i} \cdot \widehat{{\bf h}_l}&amp; = ({\bf g}_i,\, -\sum_{j=1}^n g_{ij}) \cdot ({\bf h}_l,0)\; = \;{\bf g}_i \cdot {\bf h}_l = 0 \;\;\;\text{for}\; 1 \leq l \leq n-k, \\
		\text{and} \;\;\widehat{{\bf g}_i} \cdot \widehat{{\bf h}}_{n-k+1} &amp; = ({\bf g}_i,\, -\sum_{j=1}^n g_{ij}) \cdot (1, \ldots, 1) = \sum_{j=1}^n g_{ij}-\sum_{j=1}^n g_{ij} = 0.
	\end{aligned}\]</span></p>
</div>
<p>How can we return from <span class="math inline">\(\widehat{C}\)</span> to <span class="math inline">\(C\)</span>? In terms of <span class="math inline">\(\widehat{G}\)</span>, this is obvious: we just delete the last column, thus deleting the last symbol from each codeword of <span class="math inline">\(\widehat{C}\)</span>. More generally:</p>
<div class="definition">
<p>To <span><strong>puncture</strong></span> a <span class="math inline">\([n,k,d]\)</span> code <span class="math inline">\(C\)</span>, we choose <span class="math inline">\(1 \leq j\leq n\)</span>, and remove the <span class="math inline">\(j^{th}\)</span> entry from every codeword.</p>
</div>
<div id="prop:punctureonce" class="proposition">
<p> Let <span class="math inline">\(C&#39;\)</span> be the <span class="math inline">\([n-1,k&#39;,d&#39;]\)</span> code obtained by puncturing the <span class="math inline">\([n,k,d]\)</span> code <span class="math inline">\(C\)</span> in the <span class="math inline">\(i\)</span><sup>th</sup> position.</p>
<ol>
<li><p>If <span class="math inline">\(d \ge 2\)</span>, then <span class="math inline">\(k&#39; = k\)</span>. If <span class="math inline">\(C\)</span> has a codeword of minimum weight with a non-zero entry in the <span class="math inline">\(i\)</span><sup>th</sup> position, then <span class="math inline">\(d&#39; = d-1\)</span>. Otherwise, <span class="math inline">\(d&#39;=d\)</span>.</p></li>
<li><p>If <span class="math inline">\(d=1\)</span>, and <span class="math inline">\(C\)</span> contains a weight 1 codeword whose non-zero element is in the <span class="math inline">\(i\)</span><sup>th</sup> position, then <span class="math inline">\(k&#39;=k-1\)</span> (as long as <span class="math inline">\(k&gt;1\)</span>) and <span class="math inline">\(d&#39;\ge 1\)</span>. Otherwise, <span class="math inline">\(k&#39;=k\)</span> and <span class="math inline">\(d&#39;=1\)</span>.</p></li>
</ol>
</div>
<div class="proof">
<p>Clearly we always have <span class="math inline">\(n&#39; = n-1\)</span>.</p>
<p>If <span class="math inline">\(d&gt;1\)</span>, then no two codewords can become the same by removing the <span class="math inline">\(i\)</span><sup>th</sup> position, hence <span class="math inline">\(q^{k&#39;}=q^k\)</span>. If <span class="math inline">\(c\in C\)</span> is a codeword of minimum weight <span class="math inline">\(w(c)=d\)</span>, with a non-zero entry in the <span class="math inline">\(i\)</span><sup>th</sup> position, then in <span class="math inline">\(C&#39;\)</span> this becomes the codeword <span class="math inline">\(c&#39;\)</span> with <span class="math inline">\(w(c&#39;)=d-1\)</span>. If no minimal weight codeword (with weight <span class="math inline">\(d\)</span>) in <span class="math inline">\(C\)</span> has a non-zero entry in the <span class="math inline">\(i\)</span><sup>th</sup> position, then in <span class="math inline">\(C&#39;\)</span> all such words still have weight <span class="math inline">\(d\)</span>, and removing the <span class="math inline">\(i\)</span><sup>th</sup> position from all codewords cannot produce a word of weight less that <span class="math inline">\(d\)</span>.</p>
<p>If <span class="math inline">\(d=1\)</span>, then there exists at least one codeword of weight one by Proposition <a href="#prop:mindminw" data-reference-type="ref" data-reference="prop:mindminw">[prop:mindminw]</a>. Since <span class="math inline">\({\mathbb F}_q\)</span> is a field, there exist weight 1 words in <span class="math inline">\(C\)</span> whose non-zero entry is a 1. Of course, there may be multiple such words whose 1s are in different positions. Then the generator matrix for <span class="math inline">\(C\)</span> in RREF must contain each of these words as rows (as they cannot be written as the sum of multiple rows of the generator matrix, due to the leading ones in the rows of this matrix).</p>
<p>If <span class="math inline">\(C\)</span> contains such a word whose 1 is in the <span class="math inline">\(i\)</span><sup>th</sup> position, then the corresponding row of the generator matrix (in RREF) for <span class="math inline">\(C&#39;\)</span> is 0 in all positions, and so <span class="math inline">\(k&#39;&lt;k\)</span>. Since no other row of this generator matrix contains a 1 in this position (as it is in RREF), the remaining rows must be linearly independent, and so <span class="math inline">\(k&#39;=k-1\)</span>. The minimum distance of <span class="math inline">\(C&#39;\)</span> is then the minimum weight of the remaining words of <span class="math inline">\(C&#39;\)</span>, so <span class="math inline">\(d&#39;\ge 1\)</span>.</p>
<p>If <span class="math inline">\(C\)</span> contains a word of weight 1 whose non-zero entry is not in the <span class="math inline">\(i\)</span><sup>th</sup> position, then this word still has weight 1 in <span class="math inline">\(C&#39;\)</span>, and so <span class="math inline">\(d&#39;=1\)</span>. If no weight 1 word in <span class="math inline">\(C\)</span> has a non-zero entry in the <span class="math inline">\(i\)</span><sup>th</sup> position, then by linearity no two words of <span class="math inline">\(C\)</span> can differ in only the <span class="math inline">\(i\)</span><sup>th</sup> position, and no two codewords can become the same by removing their <span class="math inline">\(i\)</span><sup>th</sup> positions, so <span class="math inline">\(q^{k&#39;}=q^k\)</span>.</p>
</div>
<p>Slightly more generally, given a code <span class="math inline">\(C\subseteq {\mathbb F}_q^n\)</span> and set of <span class="math inline">\(m\)</span> coordinates <span class="math inline">\(T=\{t_1,\ldots,t_m\}\)</span>, where <span class="math inline">\(1\le t_i \le n\)</span> for <span class="math inline">\(1 \le i \le m\)</span>, we can puncture <span class="math inline">\(C\)</span> on each position in <span class="math inline">\(T\)</span> to obtain the code <span class="math inline">\(C^T\)</span>. The code obtained by puncturing <span class="math inline">\(C\)</span> in position <span class="math inline">\(i\)</span> as above, can then be written as <span class="math inline">\(C^{\{i\}}\)</span>.</p>
<div id="prop:puncturemultiple" class="proposition">
<p> Let <span class="math inline">\(C\subseteq {\mathbb F}_q^n\)</span> be an <span class="math inline">\([n,k,d]\)</span> code, and <span class="math inline">\(T\)</span> be a coordinate set of size <span class="math inline">\(m\)</span> as above. Then <span class="math inline">\(C^T\)</span> is an <span class="math inline">\([n-m,k&#39;,d&#39;]\)</span> code, with <span class="math inline">\(k&#39;\ge k-m\)</span> and <span class="math inline">\(d&#39;\ge d-m\)</span>.</p>
</div>
<div id="pf:puncturemultiple" class="proof">
<p> Use Proposition <a href="#prop:punctureonce" data-reference-type="ref" data-reference="prop:punctureonce">[prop:punctureonce]</a> and induction.</p>
</div>
<p>So it seems there could be <span class="math inline">\(n\)</span> different single punctured versions of a code. These may or may not be equivalent; they may not even have the same minimum distance.</p>
<div id="eg:extendingandpuncturing" class="exampleqed">
<p> Let <span class="math inline">\(C\subset {\mathbb F}_2^5\)</span> be the <span class="math inline">\([5,2,2]\)</span> code generated by <span class="math display">\[G = \left( \begin{array}{ccccc}
		1 &amp; 0 &amp; 1 &amp; 0 &amp; 0 \\
		0 &amp; 1 &amp; 0 &amp; 1 &amp; 1
		\end{array}\right).\]</span> Using Proposition <a href="#prop:dualstandardform" data-reference-type="ref" data-reference="prop:dualstandardform">[prop:dualstandardform]</a>, this has check-matrix <span class="math display">\[H = \left( \begin{array}{ccccc}
		1 &amp; 0 &amp; 1 &amp; 0 &amp; 0 \\
		0 &amp; 1 &amp; 0 &amp; 1 &amp; 0 \\
		0 &amp; 1 &amp; 0 &amp; 0 &amp; 1
		\end{array}\right),\]</span> and so the extended code <span class="math inline">\(\widehat{C}\)</span> has check-matrix <span class="math display">\[\widehat{H} = \left( \begin{array}{cccccc}
		1 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 \\
		0 &amp; 1 &amp; 0 &amp; 1 &amp; 0 &amp; 0 \\
		0 &amp; 1 &amp; 0 &amp; 0 &amp; 1 &amp; 0 \\
		1 &amp; 1 &amp; 1 &amp; 1 &amp; 1 &amp; 1
		\end{array}\right),\]</span> and by Proposition <a href="#prop:extendedgeneratormatrix" data-reference-type="ref" data-reference="prop:extendedgeneratormatrix">[prop:extendedgeneratormatrix]</a>, <span class="math inline">\(\widehat{C}\)</span> has generator matrix <span class="math display">\[\widehat{G} = \left( \begin{array}{cccccc}
		1 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 \\
		0 &amp; 1 &amp; 0 &amp; 1 &amp; 1 &amp; 1
		\end{array}\right).\]</span></p>
<p>If we puncture in the 6<sup>th</sup> position, we clearly get back <span class="math inline">\(C\)</span>, so <span class="math inline">\(\widehat{C}^{\{6\}} = C\)</span>. However, if we puncture <span class="math inline">\(\widehat{C}\)</span> in the 3<sup>rd</sup> position, we get a code <span class="math inline">\(\widehat{C}^{\{3\}}\)</span> with generator matrix <span class="math display">\[G&#39; = \left( \begin{array}{ccccc}
		1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
		0 &amp; 1 &amp; 1 &amp; 1 &amp; 1
		\end{array}\right),\]</span> which is clearly a code of minimum distance 1, which is not even (permutation) equivalent to <span class="math inline">\(C\)</span>.</p>
<p>The code <span class="math inline">\(\widehat{C}^{\{1,3\}}\)</span> has generator matrix <span class="math display">\[\tilde{G} = \left( \begin{array}{cccc}
		1 &amp; 1 &amp; 1 &amp; 1
		\end{array}\right),\]</span> and hence has dimension 1 and minimum distance 4.</p>
</div>
<p>To summarise, extending takes a code <span class="math inline">\(C\)</span> of dimension <span class="math inline">\(k\)</span> in the space <span class="math inline">\({\mathbb F}_q^n\)</span>, and makes a new code <span class="math inline">\(\widehat{C}\)</span>, still of dimension <span class="math inline">\(k\)</span>, in <span class="math inline">\({\mathbb F}_q^{n+1}\)</span>. Puncturing <span class="math inline">\(\widehat{C}\)</span> (once) projects it back into <span class="math inline">\({\mathbb F}_q^n\)</span>, but may or may not give <span class="math inline">\(C\)</span> again.</p>
</section>
<section id="sec:golay_codes" class="level2" data-number="5.3">
<h2 data-number="5.3"><span class="header-section-number">5.3</span> Golay Codes</h2>
<p><strong>The remainder of this chapter of the notes is non-examinable, and is provided only for your interest.</strong></p>
<p>The perfect binary [23,12,7] code found by Golay is known as <span class="math inline">\(\mathcal{G}_{23}\)</span>. We shall find it indirectly: assuming such a code exists, we shall first consider an extended version of it, and then puncture this. We call this code <span class="math inline">\(\mathcal{G}_{24}\)</span>; by Corollary <a href="#cor:extendedbinary" data-reference-type="ref" data-reference="cor:extendedbinary">[cor:extendedbinary]</a> it is a <span class="math inline">\([24, 12, 8]\)</span> code, and is not perfect. We first describe how to construct a generator matrix for <span class="math inline">\(\mathcal{G}_{24}\)</span> and then show that the code generated from this is indeed a binary <span class="math inline">\([24,12,8]\)</span> code. In fact, one can prove that a <span class="math inline">\([24,12,8]\)</span> code is unique up to equivalence, a fact which we will use without proof.</p>
<section id="sub:the_extended_binary_golay_code_g_24" class="level3" data-number="5.3.1">
<h3 data-number="5.3.1"><span class="header-section-number">5.3.1</span> The Extended Binary Golay Code <span class="math inline">\(\mathcal{G}_{24}\)</span></h3>
<p>We construct our generator matrix using the adjacencies of the vertices of the icosahedron. We recall that an icosahedron is a twenty sided platonic solid with five equilateral triangles meeting at each vertex. The icosahedron is shown in Figure <a href="#fig:icosahedron" data-reference-type="ref" data-reference="fig:icosahedron">5.1</a>. It is easiest to consider the adjacency of the icosahedron by studying its net (Figure <a href="#fig:icosahedronnet" data-reference-type="ref" data-reference="fig:icosahedronnet">5.2</a>).</p>
<figure>
<img src="../Images/Icosahedron.png" id="fig:icosahedron" style="width:50.0%" alt="" /><figcaption>The Icosahedron.</figcaption>
</figure>
<p> </p>
<figure>
<img src="../Images/IcoNet.png" id="fig:icosahedronnet" alt="" /><figcaption>The net of the icosahedron, with the vertices labelled A to L.</figcaption>
</figure>
<div class="definition">
<p>Two points of the icosahedron are <em>adjacent</em> if in the net there is a single line joining the two points.</p>
</div>
<p>Note that by the above definition, a point X is not adjacent to itself, since there is no single line joining any point to itself in the net of the icosahedron.</p>
<p>Let us label the vertices of the Icosahedron as <span class="math inline">\(v_i\)</span> for <span class="math inline">\(1\le i\le 12\)</span>. We now define a matrix <span class="math inline">\(A\)</span>, where the entry in row <span class="math inline">\(i\)</span>, column <span class="math inline">\(j\)</span>, is 0 if the two points indexed by the position in the matrix are adjacent, and 1 if not. That is, we let <span class="math inline">\(A \in M_{12,12}({\mathbb F}_2)\)</span> be given by <span class="math display">\[A_{i,j} =
	\begin{cases}
	      0 &amp; \text{if $v_i$ is adjacent to $v_j$} \\
		  1 &amp; \text{if $v_i$ is not adjacent to $v_j$}.
	\end{cases}\]</span> Explicitly, we have <span class="math display">\[A = \left(\begin{matrix}
	1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 1 &amp; 1 &amp; 1 &amp; 1 &amp; 1 \\
	0 &amp; 1 &amp; 0 &amp; 1 &amp; 1 &amp; 0 &amp; 0 &amp; 1 &amp; 1 &amp; 1 &amp; 0 &amp; 1 \\
	0 &amp; 0 &amp; 1 &amp; 0 &amp; 1 &amp; 1 &amp; 0 &amp; 0 &amp; 1 &amp; 1 &amp; 1 &amp; 1 \\
	0 &amp; 1 &amp; 0 &amp; 1 &amp; 0 &amp; 1 &amp; 1 &amp; 0 &amp; 0 &amp; 1 &amp; 1 &amp; 1 \\
	0 &amp; 1 &amp; 1 &amp; 0 &amp; 1 &amp; 0 &amp; 1 &amp; 1 &amp; 0 &amp; 0 &amp; 1 &amp; 1 \\
	0 &amp; 0 &amp; 1 &amp; 1 &amp; 0 &amp; 1 &amp; 1 &amp; 1 &amp; 1 &amp; 0 &amp; 0 &amp; 1 \\
	1 &amp; 0 &amp; 0 &amp; 1 &amp; 1 &amp; 1 &amp; 1 &amp; 0 &amp; 1 &amp; 1 &amp; 0 &amp; 0\\
	1 &amp; 1 &amp; 0 &amp; 0 &amp; 1 &amp; 1 &amp; 0 &amp; 1 &amp; 0 &amp; 1 &amp; 1 &amp; 0\\
	1 &amp; 1 &amp; 1 &amp; 0 &amp; 0 &amp; 1 &amp; 1 &amp; 0 &amp; 1 &amp; 0 &amp; 1 &amp; 0\\
	1 &amp; 1 &amp; 1 &amp; 1 &amp; 0 &amp; 0 &amp; 1 &amp; 1 &amp; 0 &amp; 1 &amp; 0 &amp; 0\\
	1 &amp; 0 &amp; 1 &amp; 1 &amp; 1 &amp; 0 &amp; 0 &amp; 1 &amp; 1 &amp; 0 &amp; 1 &amp; 0\\
	1 &amp; 1 &amp; 1 &amp; 1 &amp; 1 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1
	\end{matrix}\right)\]</span> Note that this matrix is symmetric, since <span class="math inline">\(v_i\)</span> is adjacent to <span class="math inline">\(v_j\)</span> <span class="math inline">\(\iff\)</span> <span class="math inline">\(v_j\)</span> is adjacent to <span class="math inline">\(v_i\)</span>.</p>
<div id="def:golaygenerator" class="definition">
<p> A generator matrix <span class="math inline">\(G\)</span> for the <strong>Extended Binary Golay Code</strong> <span class="math inline">\(\mathcal{G}_{24}\)</span> is then given in standard form as <span class="math inline">\((I_{12} \;|\; A)\)</span>, <span class="math display">\[G = \left(\begin{matrix}
		1&amp; &amp; &amp; &amp; &amp; &amp; &amp; &amp; &amp; &amp; &amp; &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 1 &amp; 1 &amp; 1 &amp; 1 &amp; 1 \\
		 &amp;1&amp; &amp; &amp; &amp; &amp; &amp; &amp; &amp; &amp; &amp; &amp; 0 &amp; 1 &amp; 0 &amp; 1 &amp; 1 &amp; 0 &amp; 0 &amp; 1 &amp; 1 &amp; 1 &amp; 0 &amp; 1 \\
		 &amp; &amp;1&amp; &amp; &amp; &amp; &amp; &amp; &amp; &amp; &amp; &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 1 &amp; 1 &amp; 0 &amp; 0 &amp; 1 &amp; 1 &amp; 1 &amp; 1 \\
		 &amp; &amp; &amp;1&amp; &amp; &amp; &amp; &amp;0&amp; &amp; &amp; &amp; 0 &amp; 1 &amp; 0 &amp; 1 &amp; 0 &amp; 1 &amp; 1 &amp; 0 &amp; 0 &amp; 1 &amp; 1 &amp; 1 \\
		 &amp; &amp; &amp; &amp;1&amp; &amp; &amp; &amp; &amp; &amp; &amp; &amp; 0 &amp; 1 &amp; 1 &amp; 0 &amp; 1 &amp; 0 &amp; 1 &amp; 1 &amp; 0 &amp; 0 &amp; 1 &amp; 1 \\
		 &amp; &amp; &amp; &amp; &amp;1&amp; &amp; &amp; &amp; &amp; &amp; &amp; 0 &amp; 0 &amp; 1 &amp; 1 &amp; 0 &amp; 1 &amp; 1 &amp; 1 &amp; 1 &amp; 0 &amp; 0 &amp; 1 \\
		 &amp; &amp; &amp; &amp; &amp; &amp;1&amp; &amp; &amp; &amp; &amp; &amp; 1 &amp; 0 &amp; 0 &amp; 1 &amp; 1 &amp; 1 &amp; 1 &amp; 0 &amp; 1 &amp; 1 &amp; 0 &amp; 0\\
		 &amp; &amp; &amp; &amp; &amp; &amp; &amp;1&amp; &amp; &amp; &amp; &amp; 1 &amp; 1 &amp; 0 &amp; 0 &amp; 1 &amp; 1 &amp; 0 &amp; 1 &amp; 0 &amp; 1 &amp; 1 &amp; 0\\
		 &amp; &amp; &amp;0&amp; &amp; &amp; &amp; &amp;1&amp; &amp; &amp; &amp; 1 &amp; 1 &amp; 1 &amp; 0 &amp; 0 &amp; 1 &amp; 1 &amp; 0 &amp; 1 &amp; 0 &amp; 1 &amp; 0\\
		 &amp; &amp; &amp; &amp; &amp; &amp; &amp; &amp; &amp;1&amp; &amp; &amp; 1 &amp; 1 &amp; 1 &amp; 1 &amp; 0 &amp; 0 &amp; 1 &amp; 1 &amp; 0 &amp; 1 &amp; 0 &amp; 0\\
		 &amp; &amp; &amp; &amp; &amp; &amp; &amp; &amp; &amp; &amp;1&amp; &amp; 1 &amp; 0 &amp; 1 &amp; 1 &amp; 1 &amp; 0 &amp; 0 &amp; 1 &amp; 1 &amp; 0 &amp; 1 &amp; 0\\
		 &amp; &amp; &amp; &amp; &amp; &amp; &amp; &amp; &amp; &amp; &amp;1&amp; 1 &amp; 1 &amp; 1 &amp; 1 &amp; 1 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1
		\end{matrix}\right).\]</span></p>
</div>
<p>Since <span class="math inline">\(G\)</span> is in standard form, every row in <span class="math inline">\(G\)</span> can be written as <span class="math inline">\(({\bf e}_i , {\bf a}_i)\)</span>, where the <span class="math inline">\({\bf e}_i\)</span> are standard basis vectors, and the <span class="math inline">\({\bf a}_i\)</span> are rows of <span class="math inline">\(A\)</span>. The code generated by <span class="math inline">\(G\)</span> is clearly a binary code with <span class="math inline">\(n=24\)</span> and <span class="math inline">\(k=12\)</span>. In order to show that <span class="math inline">\(\mathcal{G}_{24}\)</span> is a binary <span class="math inline">\([24,12,8]\)</span> code, we ‘just’ need to show that the code generated by <span class="math inline">\(G\)</span> has <span class="math inline">\(d=8\)</span>. We do not use Theorem <a href="#thm:lindepcolsdistance" data-reference-type="ref" data-reference="thm:lindepcolsdistance">[thm:lindepcolsdistance]</a> here, as we would need to show that no combination of 7 or less columns of <span class="math inline">\(G\)</span> are linearly dependent. Instead, we show this in several steps by considering the weights of the codewords directly.</p>
<div id="def:intersection" class="definition">
<p> For <span class="math inline">\({\bf x}\)</span> and <span class="math inline">\({\bf y}\in {\mathbb F}_2^n\)</span>, the <em>intersection</em> of <span class="math inline">\({\bf x}\)</span> and <span class="math inline">\({\bf y}\)</span>, written as <span class="math inline">\({\bf x}\cap{\bf y}\)</span>, is coordinatewise product of <span class="math inline">\({\bf x}\)</span> and <span class="math inline">\({\bf y}\)</span>.</p>
</div>
<p>This intersection of <span class="math inline">\({\bf x}\)</span> and <span class="math inline">\({\bf y}\)</span> has 1s in exactly <span class="math inline">\(\{\text{places where } {\bf x}\text{ has a 1}\} \cap \{\text{places where } {\bf y}\text{ has a 1}\}\)</span>, and zeros elsewhere.</p>
<div id="lem:intersectionweight" class="lemma">
<p> For <span class="math inline">\({\bf x}\)</span> and <span class="math inline">\({\bf y}\)</span> in <span class="math inline">\({\mathbb F}_2^n\)</span>: <span>i)</span> <span class="math inline">\(w({\bf x}+{\bf y}) = w({\bf x}) + w({\bf y}) - 2 w({\bf x}\cap {\bf y})\)</span>. <span>ii)</span> <span class="math inline">\({\bf x}\cdot {\bf y}= 0 \in {\mathbb F}_2\)</span> if and only if <span class="math inline">\(w({\bf x}\cap {\bf y})\)</span> is even. <span>iii)</span> <span class="math inline">\({\bf x}\cdot {\bf x}= 0 \in {\mathbb F}_2\)</span> if and only if <span class="math inline">\(w({\bf x})\)</span> is even.</p>
</div>
<div class="proof">
<p>Easy - see Q75.</p>
</div>
<div id="eg:golaycodewordweight" class="exampleqed">
<p> <span class="math inline">\({\bf a}_2= (0 , 1 , 0 , 1 , 1 , 0 , 0 , 1 , 1 , 1 , 0 , 1),\; {\bf a}_3 = ( 0 , 0 , 1 , 0 , 1 , 1 , 0 , 0 , 1 , 1 , 1 , 1)\)</span>. Then <span class="math inline">\({\bf a}_2 + {\bf a}_3 = ( 0,1,1,1,0,1,0,1,0,0,1,0)\)</span>, <span class="math inline">\({\bf a}_2 \cap {\bf a}_3 = (0,0,0,0,1,0,0,0,1,1,0,1)\)</span>. The weights are <span class="math inline">\(w({\bf a}_2)=w({\bf a}_3)=7\)</span>, <span class="math inline">\(w({\bf a}_2 + {\bf a}_3) = 6\)</span>, and <span class="math inline">\(w({\bf a}_2 \cap {\bf a}_3)= 4\)</span>.</p>
<p>In fact, we have <span class="math inline">\(w({\bf a}_i) = 7\)</span> and <span class="math inline">\(w({\bf g}_i)=8\)</span> for <span class="math inline">\(i = 1,\ldots,12\)</span>, since each point on the icosahedron is not adjacent to exactly 7 other points.</p>
</div>
<div id="prop:golayweight8" class="proposition">
<p> <span class="math display">\[d(\mathcal{G}_{24}) = 8.\]</span></p>
</div>
<p>As noted in Example <a href="#eg:golaycodewordweight" data-reference-type="ref" data-reference="eg:golaycodewordweight">[eg:golaycodewordweight]</a>, there certainly exist codewords in the Extended Binary Golay Code of weight 8. We show there are no codewords with <span class="math inline">\(w({\bf c}) &lt; 8\)</span> via four lemmas. The first two concern the code as a whole.</p>
<div id="lem:golayselfdual" class="lemma">
<p> The code <span class="math inline">\(\mathcal{G}_{24}\)</span> is self-dual, that is, <span class="math inline">\(\mathcal{G}_{24}^\perp = \mathcal{G}_{24}\)</span>.</p>
</div>
<div id="pf:golayselfdual" class="proof">
<p> We know that <span class="math inline">\(\operatorname{dim}(\mathcal{G}_{24}^\perp) = n - k = 12,\)</span> and so <span class="math inline">\(\lvert \mathcal{G}_{24}^\perp \rvert = \lvert \mathcal{G}_{24} \rvert\)</span>. It is therefore enough to show that <span class="math inline">\(\mathcal{G}_{24} \subset \mathcal{G}_{24}^\perp\)</span>. Recalling that <span class="math inline">\(\mathcal{G}_{24}^\perp = \{ {\bf x}\in \mathbb{F}_2^{24}\ \vert\ {\bf x}\cdot G^t = {\bf 0} \}\)</span>, we therefore have <span class="math inline">\(\mathcal{G}_{24} \subset \mathcal{G}_{24}^\perp \iff {\bf c}\cdot G^t = {\bf 0} \ \forall\ {\bf c}\in \mathcal{G}_{24}\)</span>. By linearity, it is enough to check this for a basis for <span class="math inline">\(\mathcal{G}_{24}\)</span>. We therefore check that for any two rows <span class="math inline">\(({\bf e}_i,{\bf a}_i)\)</span> and <span class="math inline">\(({\bf e}_j,{\bf a}_j)\)</span> of <span class="math inline">\(G\)</span>, we have <span class="math inline">\(({\bf e}_i,{\bf a}_i) \cdot ({\bf e}_j,{\bf a}_j) = 0\)</span>.</p>
<p>By Lemma <a href="#lem:intersectionweight" data-reference-type="ref" data-reference="lem:intersectionweight">[lem:intersectionweight]</a>, this is true whenever we have <span class="math inline">\(i=j\)</span>, since all rows of <span class="math inline">\(G\)</span> have even weight. For <span class="math inline">\(i \ne j\)</span>, <span class="math display">\[\begin{aligned}
			({\bf e}_i,{\bf a}_i) \cdot ({\bf e}_j,{\bf a}_j) &amp;= {\bf e}_i \cdot {\bf e}_j + {\bf a}_i \cdot {\bf a}_j \\
				&amp;= {\bf a}_i \cdot {\bf a}_j.
		\end{aligned}\]</span> In terms of our icosahedron, <span class="math inline">\({\bf a}_i \cdot {\bf a}_j\)</span> is just the number of points on the icosahedron not adjacent to <span class="math inline">\(v_i\)</span> <em>and</em> not adjacent to <span class="math inline">\(v_j\)</span> modulo 2. By the rotational symmetry of the icosahedron, without loss of generality we can assume that <span class="math inline">\(v_i\)</span> is <span class="math inline">\(v_1=A\)</span>, and <span class="math inline">\(v_j\)</span> is one of <span class="math inline">\(v_2 = B\)</span>, <span class="math inline">\(v_7 = G\)</span> or <span class="math inline">\(v_{12}=L\)</span>. If we let <span class="math inline">\(E_i = \{ \text{points in the icosahedron adjacent to } v_i\}\)</span>, then by the Inclusion-Exclusion principle, we have <span class="math display">\[\begin{aligned}
			{\bf a}_i \cdot {\bf a}_j &amp;= 12 - \lvert E_i \cup E_j \rvert \\
			&amp;= 12 - \lvert E_i \rvert - \lvert E_j \rvert + \lvert E_i \cap E_j \rvert.
		\end{aligned}\]</span> We can now consider the three possibilities for <span class="math inline">\(v_j\)</span> in turn:</p>
<ul>
<li><p>If <span class="math inline">\(v_j\)</span> is <span class="math inline">\(v_{12} = L\)</span>, then <span class="math inline">\({\bf a}_i \cdot {\bf a}_j = 12 - 5 -5 + 0 \pmod{2} = 0\)</span>.</p></li>
<li><p>If <span class="math inline">\(v_j\)</span> is <span class="math inline">\(v_{7} = G\)</span>, then <span class="math inline">\({\bf a}_i \cdot {\bf a}_j = 12 - 5 -5 + 2 \pmod{2} = 0\)</span>.</p></li>
<li><p>If <span class="math inline">\(v_j\)</span> is <span class="math inline">\(v_{2} = B\)</span>, then <span class="math inline">\({\bf a}_i \cdot {\bf a}_j = 12 - 5 -5 + 2 \pmod{2} = 0\)</span>.</p></li>
</ul>
<p>We therefore see that <span class="math display">\[\begin{equation} \label{eq:intersectionweightinnerprod}
		{\bf a}_i \cdot {\bf a}_j = w({\bf a}_i \cap {\bf a}_j)\! \pmod{2} = 0 \quad \forall\, 1 \le i,j \le 12. \end{equation}\]</span> This shows that every basis vector is orthogonal to every other basis vector, and hence by linearity that <span class="math inline">\(\mathcal{G}_{24} = \mathcal{G}_{24}^\perp\)</span>.</p>
</div>
<div class="lemma">
<p><span class="math inline">\((A \;|\; I_{12})\)</span> is another generator-matrix for <span class="math inline">\(\mathcal{G}_{24}\)</span>.</p>
</div>
<div class="proof">
<p>By Proposition <a href="#prop:dualstandardform" data-reference-type="ref" data-reference="prop:dualstandardform">[prop:dualstandardform]</a>, <span class="math inline">\(( -A^t \;|\; I_{12})\)</span> is a generator-matrix for <span class="math inline">\(\mathcal{G}_{24}^\perp\)</span>. But <span class="math inline">\(-A^t = A\)</span>, and by Lemma <a href="#lem:golayselfdual" data-reference-type="ref" data-reference="lem:golayselfdual">[lem:golayselfdual]</a>, <span class="math inline">\(\mathcal{G}_{24} = \mathcal{G}_{24}^\perp\)</span>. We therefore have that <span class="math inline">\((A \;|\; I_{12})\)</span> is a generator matrix for <span class="math inline">\(\mathcal{G}_{24}\)</span> also.</p>
</div>
<p>The next two Lemmas are about individual codewords of <span class="math inline">\(\mathcal{G}_{24}\)</span>.</p>
<div id="lem:doublyeven" class="lemma">
<p> If <span class="math inline">\({\bf c}\in \mathcal{G}_{24}\)</span>, then <span class="math inline">\(w({\bf c})\)</span> is divisible by 4.</p>
</div>
<div id="pf:doublyeven" class="proof">
<p> Let <span class="math inline">\({\bf c}_1,\, {\bf c}_2 \in \mathcal{G}_{24}\)</span> have weights divisible by 4. Since <span class="math inline">\(\mathcal{G}_{24}\)</span> is self-dual by Lemma <a href="#lem:golayselfdual" data-reference-type="ref" data-reference="lem:golayselfdual">[lem:golayselfdual]</a>, <span class="math inline">\({\bf c}_1 \cdot {\bf c}_2 = 0\)</span>, so <span class="math inline">\(w({\bf c}_1 \cap {\bf c}_2)\)</span> is even by Lemma <a href="#lem:intersectionweight" data-reference-type="ref" data-reference="lem:intersectionweight">[lem:intersectionweight]</a>. So, <span class="math inline">\(w({\bf c}_1 + {\bf c}_2) = w({\bf c}_1) + w({\bf c}_2) - 2w({\bf c}_1 \cap {\bf c}_2)\)</span> is also divisible by 4. Since any <span class="math inline">\({\bf c}\in \mathcal{G}_{24}\)</span> is a sum of rows of <span class="math inline">\(G\)</span>, all of which have weight 8, then all such <span class="math inline">\({\bf c}\)</span> must have weight divisible by 4.</p>
</div>
<div id="lem:noweight4" class="lemma">
<p> No <span class="math inline">\({\bf c}\in \mathcal{G}_{24}\)</span> has weight 4.</p>
</div>
<div id="pf:noweight4" class="proof">
<p> We prove this via a contradiction. Suppose <span class="math inline">\({\bf c}\in \mathcal{G}_{24},\, w({\bf c})=4\)</span>. Since <span class="math inline">\((I_{12} \;|\; A)\)</span> and <span class="math inline">\((A \;|\; I_{12})\)</span> are both generator matrices for <span class="math inline">\(\mathcal{G}_{24}\)</span>, then <span class="math inline">\({\bf c}\)</span> can be written as a sum of <span class="math inline">\(({\bf e}_i,{\bf a}_i)\)</span> <em>and</em> as a sum of <span class="math inline">\(({\bf a}_i,{\bf e}_i)\)</span>. Let <span class="math inline">\({\bf l}= (c_1,\ldots,c_{12}),\, {\bf r}= (c_{13},\ldots,c_{24})\)</span>, such that <span class="math inline">\({\bf c}= ({\bf l},{\bf r})\)</span>. Then <span class="math inline">\(w({\bf l}) + w({\bf r}) = 4\)</span> and so we can consider the different cases satisfying this:</p>
<ul>
<li><p>If <span class="math inline">\(w({\bf l})=0\)</span>, then we have no <span class="math inline">\(({\bf e}_i,{\bf a}_i)\)</span>, and so <span class="math inline">\(w({\bf c})=0\)</span>.</p></li>
<li><p>If <span class="math inline">\(w({\bf r})=0\)</span>, then we have no <span class="math inline">\(({\bf a}_i,{\bf e}_i)\)</span>, and so <span class="math inline">\(w({\bf c})=0\)</span>.</p></li>
<li><p>If <span class="math inline">\(w({\bf l})=1\)</span>, then we have one <span class="math inline">\(({\bf e}_i,{\bf a}_i)\)</span>, and so <span class="math inline">\(w({\bf c})=8\)</span>.</p></li>
<li><p>If <span class="math inline">\(w({\bf r})=1\)</span>, then we have one <span class="math inline">\(({\bf a}_i,{\bf e}_i)\)</span>, and so <span class="math inline">\(w({\bf c})=8\)</span>.</p></li>
<li><p>If <span class="math inline">\(w({\bf l})=w({\bf r})=2\)</span>, then we have two <span class="math inline">\(({\bf e}_i,{\bf a}_i)\)</span>, and so <span class="math display">\[\begin{aligned}
				w({\bf c}) &amp;= 2 + w({\bf a}_i + {\bf a}_j) \\
				    &amp;= 2 + w({\bf a}_i) + w({\bf a}_j) - 2w({\bf a}_i \cap {\bf a}_j) \\
					&amp;= 16 - 2w({\bf a}_i \cap {\bf a}_j)
			\end{aligned}\]</span></p></li>
</ul>
<p>However, by Equation <span class="math inline">\(\eqref{eq:intersectionweightinnerprod}\)</span>, we see that we have already shown that <span class="math inline">\(w({\bf a}_i \cap {\bf a}_j) \ne 6\)</span> for any <span class="math inline">\(i,j\)</span> in the proof of Lemma <a href="#lem:golayselfdual" data-reference-type="ref" data-reference="lem:golayselfdual">[lem:golayselfdual]</a>, and therefore no <span class="math inline">\({\bf c}\in \mathcal{G}_{24}\)</span> has <span class="math inline">\(w({\bf c})=4\)</span>.</p>
</div>
<p>Lemmas <a href="#lem:doublyeven" data-reference-type="ref" data-reference="lem:doublyeven">[lem:doublyeven]</a> and <a href="#lem:noweight4" data-reference-type="ref" data-reference="lem:noweight4">[lem:noweight4]</a> together complete the proof of Proposition <a href="#prop:golayweight8" data-reference-type="ref" data-reference="prop:golayweight8">[prop:golayweight8]</a> – we have shown that the weights of all codewords are divisible by 4, no word of weight 4 exists and there does exist at least one (in fact there are 759) words of weight 8. The Extended Binary Golay Code is therefore a binary <span class="math inline">\([24,12,8]\)</span> code as claimed.</p>
</section>
<section id="sub:the_perfect_ternary_golay_code_g_23" class="level3" data-number="5.3.2">
<h3 data-number="5.3.2"><span class="header-section-number">5.3.2</span> The Perfect Binary Golay Code <span class="math inline">\(\mathcal{G}_{23}\)</span></h3>
<p>We can now puncture the code by deleting the last column of <span class="math inline">\(G\)</span>, to get a generator matrix for the Golay code <span class="math inline">\(\mathcal{G}_{23}\)</span>. Since <span class="math inline">\(G\)</span> contained a minimum weight codeword with a non-zero entry in the final position, then by Proposition <a href="#prop:punctureonce" data-reference-type="ref" data-reference="prop:punctureonce">[prop:punctureonce]</a>, <span class="math inline">\(\mathcal{G}_{23}\)</span> is a [23, 12, 7] code. (It is true, though not obvious, that deleting any other column of <span class="math inline">\(G\)</span> would give a permutation equivalent code which we could also call <span class="math inline">\(\mathcal{G}_{23}\)</span>.)</p>
<p>We can quickly confirm that <span class="math inline">\(\mathcal{G}_{23}\)</span> is perfect: since <span class="math inline">\(d=7\)</span>, spheres <span class="math inline">\(S({\bf c},3)\)</span> around each of the <span class="math inline">\(2^{12}\)</span> codewords do not intersect, and since <span class="math inline">\(2^{12}\left( 1 + 23 + \binom{23}{2} +\binom{23}{3}\right) = 2^{23}\)</span>, they fill <span class="math inline">\({\mathbb F}_2^{23}\)</span> as required.</p>
</section>
<section id="sub:subsection_name" class="level3" data-number="5.3.3">
<h3 data-number="5.3.3"><span class="header-section-number">5.3.3</span> The Ternary Golay Codes <span class="math inline">\(\mathcal{G}_{12}\)</span> &amp; <span class="math inline">\(\mathcal{G}_{11}\)</span></h3>
<p>We now look briefly at the perfect Ternary Golay Code <span class="math inline">\(\mathcal{G}_{11}\)</span>, with parameters <span class="math inline">\([11, 6, 5]\)</span>. We can find it in the same way as the perfect Binary Golay Code, by first considering the Extended Ternary Golay Code <span class="math inline">\(\mathcal{G}_{12}\)</span>. One possible generator matrix for <span class="math inline">\(\mathcal{G}_{12}\)</span> is <span class="math display">\[G = [I_6 \;|\;A] =\left(\begin{matrix}
1&amp; &amp; &amp; &amp; &amp; &amp;0&amp;1&amp;1&amp;1&amp;1&amp;1\\
 &amp;1&amp; &amp; &amp;0&amp; &amp;1&amp;0&amp;1&amp;2&amp;2&amp;1\\
 &amp; &amp;1&amp; &amp; &amp; &amp;1&amp;1&amp;0&amp;1&amp;2&amp;2\\
 &amp; &amp; &amp;1&amp; &amp; &amp;1&amp;2&amp;1&amp;0&amp;1&amp;2\\
 &amp;0&amp; &amp; &amp;1&amp; &amp;1&amp;2&amp;2&amp;1&amp;0&amp;1\\
 &amp; &amp; &amp; &amp; &amp;1&amp;1&amp;1&amp;2&amp;2&amp;1&amp;0\\
\end{matrix}\right).\]</span> As before we can confirm that this gives parameters <span class="math inline">\([12,6,6]\)</span>, and then delete the last column to get a generator-matrix for <span class="math inline">\(\mathcal{G}_{11}\)</span>. Alternatively, in this slightly smaller case we can construct a check-matrix <span class="math inline">\(H \in M_{5,11}({\mathbb F}_3)\)</span> for <span class="math inline">\(\mathcal{G}_{11}\)</span> directly, with any 4 columns linearly independent. (See Q76 and Q77.)</p>
</section>
<section id="sub:other_constructions_for_g_24" class="level3" data-number="5.3.4">
<h3 data-number="5.3.4"><span class="header-section-number">5.3.4</span> Other Constructions for <span class="math inline">\(\mathcal{G}_{24}\)</span></h3>

<p>Aside from the construction of <span class="math inline">\(\mathcal{G}_{24}\)</span> discussed above in terms of the geometry of the icosahedron, there are many other interesting constructions of the code. Here, I would like to very briefly mention two other (related) constructions.</p>
<p>Firstly, the Extended Binary Golay Code can be constructed using a so called <em>Lexicographic</em> construction. In this construction, we start with a set <span class="math inline">\(C\)</span> containing only the vector <span class="math inline">\({\bf c}_0 = (0,\ldots,0) \in \mathbb{F}_2^{24}\)</span>. We now consider each non-zero element of <span class="math inline">\(\mathbb{F}_2^{24}\)</span> in turn, ordered increasingly by their values when read as binary numbers. This is known as a lexicographical ordering of the elements of <span class="math inline">\(\mathbb{F}_2^{24}\)</span>. That is, we first consider <span class="math inline">\((0,\ldots,0,1)\)</span>, then <span class="math inline">\((0,\ldots,0,1,0)\)</span>, and so on. Every time we consider a vector with distance at least 8 from every element already in our set <span class="math inline">\(C\)</span>, we add it to the set <span class="math inline">\(C\)</span>. So the first element we add to <span class="math inline">\(C\)</span> is the vector <span class="math inline">\({\bf c}_1=(0,\ldots,0,1,1,1,1,1,1,1,1)\)</span>, as this is the first element of <span class="math inline">\(\mathbb{F}_2^{24}\)</span> in the lexicographical ordering with distance at least 8 from <span class="math inline">\({\bf c}_0\)</span>. The next element of <span class="math inline">\(\mathbb{F}_2^{24}\)</span> to be added is <span class="math inline">\({\bf c}_2 = (0,\ldots,0,1,1,1,1,0,0,0,0,1,1,1,1)\)</span>, as this is the first element in the lexicographical ordering with distance at least 8 from the two words we have already added to <span class="math inline">\(C\)</span>, namely <span class="math inline">\({\bf c}_0\)</span> and <span class="math inline">\({\bf c}_1\)</span>.</p>
<p>In this construction, the fact that the code being constructed has <span class="math inline">\(n=24\)</span> and <span class="math inline">\(d=8\)</span> is clear by construction. However, it is not immediately clear that this code is linear, or that it has dimension <span class="math inline">\(k=12\)</span>. As an exercise, you may wish to code the algorithm described above on a computer, and run it to see how many elements of <span class="math inline">\(\mathbb{F}_2^{24}\)</span> end up getting added to <span class="math inline">\(C\)</span>. You should find that you end up with <span class="math inline">\(4096\)</span> elements of <span class="math inline">\(C\)</span>, which implies that <em>if</em> the code is linear, it has dimension <span class="math inline">\(k=12\)</span>. Since we stated (without proof) that a <span class="math inline">\([24,12,8]\)</span> code is unique up to equivalence, this implies that this is a lexicographical construction of <span class="math inline">\(\mathcal{G}_{24}\)</span>.</p>
<p>A related construction is via a two-player impartial game known as Mogul. The rules of this game are defined as follows:</p>
<div id="def:mogulrules" class="definition">
<p> Mogul is a game, played by two players with a row of twenty-four coins.</p>
<ul>
<li><p>To begin with, the twenty-four coins are all placed heads up.</p></li>
<li><p>The two players then take turns to turn over between one and seven coins (inclusive), with the condition that the right-most coin turned is turned from heads to tails. Any other coins turned, if there are any others turned, may be turned from heads to tails or tails to heads.</p></li>
<li><p>The winner is the player who makes the last possible move.</p></li>
</ul>
</div>
<p>A possible first move for Mogul is shown in Figure <a href="#fig:mogul" data-reference-type="ref" data-reference="fig:mogul">5.3</a>. One can prove that under the assumption that both players play optimally, the player who makes the first move (P1) will always lose. We therefore say that P2 has a winning strategy, and this strategy consists of P2 always moving to one of a predefined set of positions on his turn. This set of positions, from which P1 can never hope to win, is exactly the Extended Binary Golay Code.</p>
<div class="center">
<figure>
<img src="../Images/Mogul.png" id="fig:mogul" alt="" /><figcaption>A move in the the mathematical game of Mogul</figcaption>
</figure>
</div>
</section>
<section id="sub:_g_24_and_moonshine" class="level3" data-number="5.3.5">
<h3 data-number="5.3.5"><span class="header-section-number">5.3.5</span> <span class="math inline">\(\mathcal{G}_{24}\)</span> and Moonshine</h3>
<p>Perhaps the most interesting thing about <span class="math inline">\(\mathcal{G}_{24}\)</span> is its connection to Mathematical Physics through a phenomenon known as Mathieu Moonshine. This moonshine connects the physics of superstring theory to the mathematics of modular forms and the representation theory of a sporadic group called Mathieu 24 (<span class="math inline">\(M_{24}\)</span>).</p>
<p>In Section <a href="#sec:equivalence" data-reference-type="ref" data-reference="sec:equivalence">3.4</a>, we saw that two binary codes are permutation equivalent if applying a permutation to the <span class="math inline">\(n\)</span> positions of all codewords maps the set of codewords of one code to the other. The set of permutations which map a code to itself forms a group (under composition of permutations) known as the permutation automorphism group of the code <span class="math inline">\(C\)</span>, <span class="math inline">\(\operatorname{PAut}(C)\)</span>. For the Extended Binary Golay Code, this automorphism group can be shown to be the simple sporadic group <span class="math inline">\(M_{24} \subset A_{24}\)</span>. The automorphism groups of the other 3 Golay codes are related to three other simple sporadic groups, <span class="math inline">\(M_{11},\,M_{12}\)</span> and <span class="math inline">\(M_{23}\)</span>.</p>
<p>Those of you who are also studying representation theory will know that an algebraic object such as a group can be studied via its representations. Roughly speaking, these are maps from the group to a vector space on which the group can be seen to have a well defined action. That is, for a group <span class="math inline">\(G\)</span>, a representation is a homomorphism from <span class="math inline">\(G\)</span> to <span class="math inline">\(GL(V)\)</span>, the group of invertible linear transformations for some vector space <span class="math inline">\(V\)</span>. We say that such a representation has a <em>dimension</em> equal to the dimension of the vector space <span class="math inline">\(V\)</span>. The representations of the group <span class="math inline">\(M_{24}\)</span> appear to play a role in the physics of superstring theory, via an important (mock-)modular form <span class="math display">\[H^1_2(q) = 2q^{-1/8}\left( -1 + 45q + 231q^2 + 770q^3 + 2277q^4 + 5796 q^5 + \ldots \right).\]</span> Each of the coefficients of <span class="math inline">\(q\)</span> in this form is the dimension of a representation of <span class="math inline">\(M_{24}\)</span>. However, the appearance of <span class="math inline">\(M_{24}\)</span> in this context is still not fully understood. Due to similarities with a mathematical phenomenon known as Monstrous Moonshine, this appearance of the representation theory of <span class="math inline">\(M_{24}\)</span> in the mock-modular form <span class="math inline">\(H^1_2\)</span> is known as Mathieu Moonshine.</p>
<p>The Extended Ternary Golay also has a connection to moonshine via its automorphism group. This moonshine is one of a collection of 23 instances of Moonshine known as Umbral Moonshine, in which the two Extended Golay Codes, as well as two other codes which you may meet in this course known as the Tetracode and the Hexacode, all appear.</p>
</section>
</section>
</section>

</section>
<section class="footnotes" role="doc-endnotes">
<hr />
<ol>
<li id="fn1" role="doc-endnote"><p>Thus the dot product is not (generally) an inner product on <span class="math inline">\({\mathbb F}_q\)</span>, so we cannot use <span class="math inline">\({\bf x}\cdot {\bf x}\)</span> as a norm, and we do not have any idea of the length of a vector in <span class="math inline">\({\mathbb F}_q^n\)</span>.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2" role="doc-endnote"><p>Strictly, in Linear Algebra you only proved this for vector spaces over <span class="math inline">\({\mathbb R}\)</span>, but it is true in general.<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3" role="doc-endnote"><p>This could not happen over <span class="math inline">\({\mathbb R}\)</span>.<a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn4" role="doc-endnote"><p>What if the dependent set of columns of <span class="math inline">\(\widehat{H}\)</span> includes the last column? Then we have linear dependence for <span><em>one fewer</em></span> columns of <span class="math inline">\(H\)</span>. It still follows that <span class="math inline">\(d \leq d&#39;\)</span> .<a href="#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn5" role="doc-endnote"><p>Why the extra brackets round <span class="math inline">\(f(x)\)</span>, which we did not put round <span class="math inline">\(n\)</span>? One reason is that, in LaTeX, <span class="math inline">\({\mathbb F}_q[x]/x^2 + x+ 1\)</span> is not as clear as it can be on a board: are we dividing out just by the <span class="math inline">\(x^2\)</span>? Another reason, for those of you who did Algebra II, is that <span class="math inline">\((f(x))\)</span> is the notation for the <span><em>ideal</em></span> <span class="math inline">\(\{q(x)f(x)\;| \;q(x) \in F_q[x]\}\)</span>, and in fact that is exactly what we are dividing out by (regarding as 0).<a href="#fnref5" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn6" role="doc-endnote"><p>In contrast, a code usually has many different generator-<span><em>matrices</em></span>.<a href="#fnref6" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn7" role="doc-endnote"><p>If <span class="math inline">\(\Sigma \lambda_i\text{row}_i =0\)</span>, then we must have <span class="math inline">\(\lambda_1 = 0\)</span>, so <span class="math inline">\(\lambda_2 = 0\)</span>, ... .<a href="#fnref7" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn8" role="doc-endnote"><p>It is an <span><em>integral domain</em></span>.<a href="#fnref8" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn9" role="doc-endnote"><p>the “obvious map <span class="math inline">\(\phi\)</span>" from Section <a href="#sec:polynomialsoverfq" data-reference-type="ref" data-reference="sec:polynomialsoverfq">6.1</a>.<a href="#fnref9" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
<script>
function doNumbering() {
	// The syntax to read the structured data from the yaml is horrible, template literals fix the problem but probably aren't widely supported enough. Escaping line breaks is browser dependant. I don't know if there's a better way?
	// Note that the data from the yaml file is manipulated into an array, and then parsed back into strings later, but I didn't want to deal with the pandoc templating syntax longer than necessary.
	var supportedEnvsArrayString = ' .definition;;; .theorem;;; .lemma;;; .proposition;;; .remark;;; .corollary;;; .exercise;;; .question';
	var supportedEnvsArray = supportedEnvsArrayString.split("|||");
	supportedEnvsArray = supportedEnvsArray.map(inner => inner.split(";;;"));
	var numberWithin = '1';
	var counterOffset = '0';
	var subcounterOffset = '';
	var problemCounter = '0';
	const partLabels = 'abcdefghijklmnopqrstuvwxyz'.split('');
	
	// counterOffset may be negative, and by default if specified on the command line this gets string concatenated with the default given in the yaml config and this then causes a problem. Can be fixed by removing the default in the config file and converting to an int, but this causes a NaN error if no value is suplied on the command line, so if NaN set to 0.
	counterOffset = parseInt(counterOffset);
	if (isNaN(counterOffset)) {
		counterOffset = 0;
	}
	
	subcounterOffset = parseInt(subcounterOffset);
	if (isNaN(subcounterOffset)) {
		subcounterOffset = 0;
	}
	
	problemCounter = parseInt(problemCounter);
	if (isNaN(problemCounter)) {
		problemCounter = 1;
	}
	
	function sanitiseSelector(selector) {
		// tex labels often have colons in which need escaping. There may be other escaping needed here. Unfortunately neither encodeURI nor encodeURIComponent do what I need, so use regex to do the escaping manually.
		var sanitised = selector.replace(/\:/g,"\\\:");
		sanitised = sanitised.replace(/(^[\d])/,"\\3$1 ");
		sanitised = sanitised.replace(/\//g,"\\\/");
		return sanitised
	}
	
	function labelLinks() {
		var refs = document.querySelectorAll("a[data-reference-type=ref]")
		for (ref of refs) {
			// Escape colons (or other) from the link title.
			var ref_label = sanitiseSelector(ref.getAttribute("data-reference"));
			// Hopefully ref is a reference to a div or a section, which should have the associated id. If so, we just need the data-number from the relevant DOM item.
			var ref_to = document.querySelector("#"+ref_label);
			if (ref_to !== null) {
				var ref_number = ref_to.getAttribute("data-number");
			} else {
				// If ref is being used for an equation, then we need to try to parse the mathjax divs. This is fragile, but try to find the span which corresponds to the equation number we need.
				try {
					var mathjax_ref = "#mjx-eqn-"+ref_label;
					ref_to = document.querySelector(mathjax_ref);
					// Since this is a ref, we don't want the parens to be returned, so find the equation number and strip the parens.
					var ref_number = ref_to.querySelector(".mjx-char").innerHTML.replace(/[()]/g,"");
					ref.setAttribute("href",mathjax_ref);
				}
				// If we can't find a place to link to, just indicate a missing link.
				catch (err){
					var ref_number = "???"
				}
			}
			ref.innerHTML = ref_number;
		};
	}
	
	function numberEnvs() {
		for (var levelSpec = 0; levelSpec <= numberWithin; levelSpec++) {
			var reqLevels = document.querySelectorAll(".level"+levelSpec);
			for (var level of reqLevels) {
				levelCount = level.getAttribute("data-number");
				levelCount = String(parseFloat(levelCount)+(counterOffset));
				levelCount = levelCount+(("."+subcounterOffset).repeat(numberWithin-levelSpec));
				for (var counter of supportedEnvsArray) {
					var envCount = 1;
					var envs = level.querySelectorAll(counter.join(", "));
					for (var env of envs) {
						env.setAttribute("data-number",levelCount+"."+envCount);
						envCount += 1;
					}
				}
			}
		}
		var allLevels = document.querySelectorAll('[class^="level"]');
		console.log(allLevels);
		for (var level of allLevels) {
			levelCount = level.getAttribute("data-number");
			levelCount = String(parseFloat(levelCount)+(counterOffset));
			level.setAttribute("data-number",levelCount);
		} 
	}
	
	function numberFigs() {
		// Figures should either be in a figure environment, or a table with image class imageTable thanks to the tableCaps filter.
		figs = document.querySelectorAll("figure, .imageTable");
		var fig_no = 1
		for (var fig of figs) {
			var cap
			// For figures, we want to move the id to the figure, and set the data-number on both the figure and the figcaption
			if (fig.nodeName == "FIGURE") {
				cap = fig.querySelector("figcaption");
				var img = fig.querySelector("img, embed")
				if (img) {
					var img_id = img.getAttribute("id");
					fig.setAttribute("id",img_id);
					img.removeAttribute("id");
				}
			// for tables (which must be .imageTable due to the querySelector above), we want to set the data-number on the table and the caption
			} else if (fig.nodeName == "TABLE") {
				cap = fig.querySelector("caption");
			}
			cap.setAttribute("data-number",fig_no);
			fig.setAttribute("data-number",fig_no);
			fig_no += 1;
		}
	}
	
	function numberGlobals() {
		// This function numbers any environments that just use a global counter, such as a problem number on a problems sheet, where there are no sections to number with respect to.
		probsols = document.querySelectorAll(".problem, .solution");
		var prob_no = problemCounter;
		var partNo = 0;
		for (var probsol of probsols) {
			if (probsol.className == "problem"){
				prob_no +=1;
				partNo = 0;
				probsol.setAttribute("data-number",prob_no);
			}
			else {
				if (probsol.parentNode.nodeName == "LI") {
					var partLabel = partLabels[partNo];
					probsol.setAttribute("data-number",prob_no.toString()+partLabel);
					partNo +=1;
				}
				else{
					probsol.setAttribute("data-number",prob_no);
				}
			}
			
		}
		// sols = document.querySelectorAll(".solution");
// 		var sol_no = problemCounter;
// 		for (var sol of sols) {
// 			sol.setAttribute("data-number",sol_no);
// 			sol_no +=1
// 		}
		egs = document.querySelectorAll(".example, .exampleqed");
		var eg_no = problemCounter;
		for (var eg of egs) {
			eg.setAttribute("data-number",eg_no);
			eg_no +=1
		}
	}
	
	// labelLinks() should occur last, so that the data-numbers have been correctly set first.
	numberEnvs();
	numberFigs();
	numberGlobals();
	labelLinks();
}
</script><script>
	var imageDir = ''
	imgs = document.querySelectorAll("img");
	for (var img of imgs) {
		imgsrc = img.getAttribute("src");
		img.setAttribute("src",imageDir.concat(imgsrc));
	}
</script></body>
</html>
