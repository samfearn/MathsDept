<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Sam Fearn Department of Mathematical Sciences, Durham University The notes for this term were originally written by Dr. Sophy Darwin and are based on a previous course developed by Rob de Jeu, Sophy Darwin, Fredrik Strömberg, and Emilie Dufresne Please send questions, comments or corrections to s.m.fearn@durham.ac.uk" />
  <title>MATH3401 Error-correcting Codes Epiphany term 2021/22</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
  </style>
  <link rel="stylesheet" href="https://samfearn.github.io/latex.min.css" />
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML" type="text/javascript"></script>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
  <script type="text/x-mathjax-config">
  	MathJax.Hub.Config({ TeX: { equationNumbers: {autoNumber: "ams"} } });
  	// I need to wait until MathJax has finished before running the numbering script
  	MathJax.Hub.Register.StartupHook("End",function(){doNumbering()});
  </script>
</head>
<body>
<header id="title-block-header">
<h1 class="title"><span>MATH3401</span><br />
<span>Error-correcting Codes</span><br />
<span>Epiphany term 2021/22</span></h1>
<p class="author">Sam Fearn<br />
<span>Department of Mathematical Sciences, Durham University</span><br />
<span>The notes for this term were originally written by Dr. Sophy Darwin</span><br />
<span>and are based on a previous course developed by</span><br />
Rob de Jeu, Sophy Darwin, Fredrik Strömberg, and Emilie Dufresne<br />
<span>Please send questions, comments or corrections to</span><br />
<code>s.m.fearn@durham.ac.uk</code></p>
</header>
<nav id="TOC" role="doc-toc">
<ul>
<li><a href="#cha:basiccodingtheory"><span class="toc-section-number">1</span> Basic Coding Theory</a>
<ul>
<li><a href="#sec:firstdefinitions"><span class="toc-section-number">1.1</span> First Definitions</a></li>
<li><a href="#sec:nearestneighbourdecoding"><span class="toc-section-number">1.2</span> Nearest-Neighbour Decoding</a></li>
<li><a href="#sec:probabilities"><span class="toc-section-number">1.3</span> Probabilities</a></li>
<li><a href="#sec:boundsoncodes"><span class="toc-section-number">1.4</span> Bounds on Codes</a></li>
</ul></li>
<li><a href="#cha:linearcodes"><span class="toc-section-number">2</span> Linear Codes</a>
<ul>
<li><a href="#sec:finitefields"><span class="toc-section-number">2.1</span> Finite Fields</a></li>
<li><a href="#finite-vector-spaces"><span class="toc-section-number">2.2</span> Finite Vector Spaces</a></li>
<li><a href="#sec:arraydecoding"><span class="toc-section-number">2.3</span> Array Decoding</a></li>
</ul></li>
</ul>
</nav>
<section id="cha:basiccodingtheory" class="level1" data-number="1">
<h1 data-number="1"><span class="header-section-number">1</span> Basic Coding Theory</h1>
<p>Error-correcting codes use very abstract mathematics in very concrete applications. If we try to communicate information over some “channel” (e.g., by radio transmission, by storing data on tape and retrieving it later, or by writing music on a CD and playing it later) then there is usually a chance that some errors occur: what comes out of the channel is not identical to what went in. Various strategies have been developed to help with this, one of which is the theory of error-correcting codes. Using such a code, one hopes to decode any information in such a way that the errors that occurred in transmission are corrected and the original information is retrieved.</p>
<p>This is the basic situation:</p>
<p><span class="math inline">\(\boxed{SENDER} \overset{\rm message}{\longrightarrow\longrightarrow} \boxed{ENCODER} \overset{\rm codeword}{\longrightarrow\longrightarrow} \boxed{CHANNEL} \overset{\text{ received}}{\overset{\text{ word}}{\longrightarrow\longrightarrow}} 
\boxed{DECODER} \overset{\text{ decoded}}{\overset{\text{ message}}{\longrightarrow\longrightarrow}} \boxed{USER}\)</span></p>
<p>And here is an example of what might happen:</p>
<p><span class="math inline">\(\boxed{\substack{\text{Yes} \\ \text{ or No}}} \overset{\rm Yes}{\longrightarrow\longrightarrow}\; \boxed{\substack{\text{Yes } \rightarrow 000 \\ \text{No } \rightarrow 111}} \overset{000}{\longrightarrow\longrightarrow}\; \boxed{\substack{NOISE \\ \hookrightarrow 100}} \overset{100}{\longrightarrow\longrightarrow} \boxed{100 \sim 000 \rightarrow Yes} \overset{\text{Yes}}{\longrightarrow\longrightarrow} \boxed{USER}\)</span></p>
<p>The decoder does two things: first (<span class="math inline">\(\sim\)</span>) it makes a good guess as to what codeword was sent, and then (<span class="math inline">\(\rightarrow\)</span>) converts this back to a message. We shall be mostly concerned with the <span class="math inline">\(\sim\)</span> process, and how to encode so that <span class="math inline">\(\sim\)</span> works well.</p>
<p>There is no very good name for <span class="math inline">\(\sim\)</span> . It is often called “decoding", but this should really include <span class="math inline">\(\rightarrow\)</span> as well. We can also call it “error-correction", but this is not quite right either, as we can never be <span><em>sure</em></span> we have found the original codeword - only that we <span><em>probably</em></span> have.</p>
<section id="sec:firstdefinitions" class="level2" data-number="1.1">
<h2 data-number="1.1"><span class="header-section-number">1.1</span> First Definitions</h2>
<div class="definition">
<p>An <span><strong>alphabet</strong></span> is a finite set of symbols. If <span class="math inline">\(A\)</span> is an alphabet, then <span class="math inline">\(A^n\)</span> is the set of all lists of <span class="math inline">\(n\)</span> symbols from <span class="math inline">\(A\)</span>. (So <span class="math inline">\(|A^n| = |A|^n\)</span>.) We call these lists <span><strong>words</strong></span> of <span><strong>length</strong></span> <span class="math inline">\(n\)</span>. A <span><strong>code</strong></span> <span class="math inline">\(C\)</span> of <span><strong>block length</strong></span> <span class="math inline">\(n\)</span> on alphabet <span class="math inline">\(A\)</span> is a subset of <span class="math inline">\(A^n\)</span>. A <span><strong>codeword</strong></span> is an element of the code.</p>
</div>
<div class="exampleqed">
<p>If the alphabet <span class="math inline">\(A= \{0,1\}\)</span>, then <span class="math inline">\(A^3 = \{000, 001, 010, 011, 100, 101, 110, 111\}\)</span>. Above, we used <span class="math inline">\(C_1 = \{000, 111\} \subseteq A^3\)</span>.</p>
<p>Now suppose <span class="math inline">\(C_2 = \{000,110, 101, 011\} \subseteq A^3\)</span>. We might have: <span class="math inline">\(\overset{000}{\longrightarrow\longrightarrow}
\boxed{\substack{NOISE \\ 001\hookleftarrow }}
\stackrel{001}{\longrightarrow\longrightarrow}
\boxed{001 \sim \left\{\begin{matrix}
0 0 0  \\1 0 1 \\0 1 1 
\end{matrix} \right\} \;\;? }
\overset{???}{\longrightarrow\longrightarrow}\;\)</span></p>
<p>We detect an error, but it is not clear how to correct it.</p>
</div>
<div class="definition">
<p>If <span class="math inline">\(|A|=2\)</span> then <span class="math inline">\(C\)</span> is a <span><strong>binary</strong></span> code. If <span class="math inline">\(|A|=3\)</span> then <span class="math inline">\(C\)</span> is a <span><strong>ternary</strong></span> code. If <span class="math inline">\(|A|=q\)</span> then <span class="math inline">\(C\)</span> is a <span class="math inline">\(q\)</span><span><strong>-ary</strong></span> code. (We usually use <span class="math inline">\(A = \{0,1,2,\ldots ,q-1\}\)</span>.)</p>
</div>
<div class="definition">
<p>For some alphabet <span class="math inline">\(A\)</span>, let <span class="math inline">\(x\)</span> and <span class="math inline">\(y\)</span> be words in <span class="math inline">\(A^n\)</span>. The <span><strong>Hamming distance</strong></span> between <span class="math inline">\(x\)</span> and <span class="math inline">\(y\)</span>, written <span class="math inline">\(d(x, y)\)</span>, is the number of places in which <span class="math inline">\(x\)</span> and <span class="math inline">\(y\)</span> differ. So <span class="math inline">\(d(x,y)\)</span> is also the (minimum) number of changes of a symbol needed to turn <span class="math inline">\(x\)</span> into <span class="math inline">\(y\)</span>. If <span class="math inline">\(x\)</span> was transmitted, but <span class="math inline">\(y\)</span> is received, then <span class="math inline">\(d(x,y)\)</span> <span><strong>symbol-errors</strong></span> have occurred.</p>
</div>
<div class="exampleqed">
<p>If <span class="math inline">\(x=0102\)</span> and <span class="math inline">\(y=2111\)</span> in <span class="math inline">\(\{0,1,2\}^4\)</span>, then <span class="math inline">\(d(x,y) = 3.\)</span></p>
</div>
<p>Formally <span class="math inline">\(d\)</span> is a function, <span class="math inline">\(d:A^n \times A^n \longrightarrow \{0,1,2,\ldots\}\)</span>. We call it a distance because in certain important ways it behaves like ordinary Euclidean distance, measured between two points in <span class="math inline">\({{\mathbb R}}^n\)</span>. In fact, because of properties ii), iii) and iv) of the following proposition, <span class="math inline">\(d\)</span> qualifies as a ‘metric’.</p>
<div class="proposition">
<p>For words <span class="math inline">\(x\)</span> and <span class="math inline">\(y\)</span> of length <span class="math inline">\(n\)</span>, the Hamming distance <span class="math inline">\(d(x,y)\)</span> satisfies:</p>
<ul>
<li><p><span class="math inline">\(0 \leq d(x,y) \leq n\)</span></p></li>
<li><p><span class="math inline">\(d(x,y)= 0 \Leftrightarrow x=y\)</span></p></li>
<li><p><span class="math inline">\(d(x,y) = d(y, x)\)</span></p></li>
<li><p><span class="math inline">\(d(x,y) \leq d(x,z) + d(z,y)\)</span></p></li>
</ul>
</div>
<div class="proof">
<p>The first three are obvious. For iv), the triangle inequality, we use the second meaning of <span class="math inline">\(d(x,y)\)</span>: the RHS is</p>
<p>the number of changes required to turn <span class="math inline">\(x\)</span> into <span class="math inline">\(z\)</span></p>
<p><span class="math inline">\(\;\;+\;\;\)</span></p>
<p>the number of changes required to turn <span class="math inline">\(z\)</span> into <span class="math inline">\(y\)</span>.</p>
<p>All these changes would certainly change <span class="math inline">\(x\)</span> into <span class="math inline">\(y\)</span>, so the RHS must be at least the minimum number of changes to do so, which is <span class="math inline">\(d(x,y)\)</span>.</p>
</div>
<div class="definition">
<p>For a code <span class="math inline">\(C\)</span>, its <span><strong>minimum distance</strong></span> <span class="math inline">\(d(C)\)</span> is min<span class="math inline">\(\{d(x,y)\;|\;x\in C, y \in C, x \neq y\}\)</span>. So <span class="math inline">\(d(C) \in \{1,2,3,\ldots\}\)</span> A code of block length <span class="math inline">\(n\)</span> with <span class="math inline">\(M\)</span> codewords and minimum distance <span class="math inline">\(d\)</span> is called an <span class="math inline">\((n, M, d)\)</span> code (or sometimes an <span class="math inline">\((n, M)\)</span> code).</p>
</div>
<p>We sometimes also refer to a <span class="math inline">\(q\)</span>-ary <span class="math inline">\((n,M,d)\)</span> code as an <span class="math inline">\((n,M,d)_q\)</span> code.</p>
<div class="exampleqed">
<p>C=<span class="math inline">\(\{0001, 2200,0031\} \subseteq\{0, 1, 2, \ldots,6\}^4\)</span> is a 7-ary (4,3,1) code.</p>
</div>
<div class="definition">
<p>If <span class="math inline">\(C \subseteq A^n\)</span> is a code, and <span class="math inline">\(x\)</span> is a word in <span class="math inline">\(A^n\)</span>, then a <span><strong>nearest neighbour</strong></span> of <span class="math inline">\(x\)</span> is a codeword <span class="math inline">\(c \in C\)</span> such that <span class="math inline">\(d(x,c) =\)</span> min<span class="math inline">\(\{d(x,y)\; | \; y \in C\}\)</span>. A word may have several nearest neighbours. A codeword’s nearest neighbour is itself.</p>
</div>
<div class="exampleqed">
<p>If <span class="math inline">\(C = \{000,111,110,011\} \subseteq \{0,1\}^3\)</span>, and <span class="math inline">\(x= 100\)</span>, then <span class="math inline">\(d(x,000) =1\)</span>, <span class="math inline">\(d(x,111) =2\)</span>, <span class="math inline">\(d(x,110)= 1\)</span>, <span class="math inline">\(d(x,011) =3\)</span>. So <span class="math inline">\(x\)</span> has two nearest neighbours, 000 and 110.</p>
</div>
</section>
<section id="sec:nearestneighbourdecoding" class="level2" data-number="1.2">
<h2 data-number="1.2"><span class="header-section-number">1.2</span> Nearest-Neighbour Decoding</h2>
<p>In this course, we shall be using <span><strong>nearest-neighbour decoding</strong></span>: if a word <span class="math inline">\(x\)</span> is received, we shall decode it to a nearest neighbour of <span class="math inline">\(x\)</span> in our code <span class="math inline">\(C\)</span>. This can always be done by finding <span class="math inline">\(d(x,c)\)</span> for every <span class="math inline">\(c \in C\)</span>, though soon we’ll have better methods.</p>
<div class="exampleqed">
<p>Let <span class="math inline">\(C_1\)</span> be our original (3,2,3) code, <span class="math inline">\(C= \{000,111\} \subseteq \{0,1\}^3\)</span>. Then we would decode 000, 100, 010, and 001 to 000. We would decode 111, 110, 101, and 011 to 111.</p>
</div>
<div class="exampleqed">
<p>Let <span class="math inline">\(C_2\)</span> be the (2,2,2) code <span class="math inline">\(C_2 = \{00,11\} \subseteq \{0,1\}^2\)</span>. Then clearly we would decode 00 to 00, and 11 to 11. But 01 and 10 each have two nearest neighbours, both 00 and 11.</p>
</div>
<p>So we can deal with <span class="math inline">\(C_2\)</span> in two different ways:</p>
<ul>
<li><p>We decide which nearest neighbour to use, for example <span class="math inline">\(01\)</span> to <span class="math inline">\(00\)</span>, <span class="math inline">\(10\)</span> to <span class="math inline">\(11\)</span>. Or perhaps both <span class="math inline">\(01\)</span> and 10 go to 00. Both of these are nearest-neighbour decoding. (Later, our algorithm for finding a nearest neighbour may decide this for us.)</p></li>
<li><p>“Incomplete decoding": we do not decode 10 and 01 at all. Possibly we ask for retransmission.</p></li>
</ul>
<p><span><strong>Notation:</strong></span> The “floor function" <span class="math inline">\(\lfloor x
\rfloor\)</span> means the largest integer <span class="math inline">\(\leq x\)</span>. So <span class="math inline">\(\lfloor 3.7 \rfloor = 3\)</span>, <span class="math inline">\(\lfloor 6 \rfloor =6\)</span>, <span class="math inline">\(\lfloor -1/2 \rfloor = -1\)</span>.</p>
<div id="prop:correctdetect" class="proposition">
<p> For a code with minimum distance <span class="math inline">\(d\)</span>, if a word has:</p>
<ul>
<li><p><span class="math inline">\(\leq d-1\)</span> symbol-errors, we will detect that it has some errors.</p></li>
<li><p><span class="math inline">\(\leq \lfloor \frac{d-1}{2} \rfloor\)</span> symbol-errors, nearest-neighbour decoding will correct them.</p></li>
</ul>
</div>
<p>Notice that, even with more symbol-errors than this, we <span><em>may</em></span> be able to detect or correct. But this is our guaranteed minimum performance.</p>
<div class="proof">
<p>Suppose codeword <span class="math inline">\(c\)</span> is sent, but <span class="math inline">\(t &gt;0\)</span> symbol-errors occur, and and word <span class="math inline">\(x\)</span> is received. So <span class="math inline">\(d(c,x) = t\)</span>.</p>
<ul>
<li><p>If <span class="math inline">\(c&#39;\)</span> is another codeword, we know <span class="math inline">\(d(c,c&#39;) \geq d\)</span>. So if <span class="math inline">\(0 &lt; t = d(c,x)\leq d-1\)</span>, then <span class="math inline">\(x\)</span> is not a codeword. We notice this, so we detect that symbol-errors have occurred (though we cannot be sure which symbols have been affected).</p></li>
<li><p>We must show that, if <span class="math inline">\(t \leq \lfloor \frac{d-1}{2} \rfloor\)</span>, then <span class="math inline">\(c\)</span> is the <span><em>unique</em></span> nearest neighbour of <span class="math inline">\(x\)</span>; that is, if <span class="math inline">\(c&#39;\)</span> is any other codeword, then <span class="math inline">\(d(x,c) &lt; d(x,c&#39;)\)</span>. Suppose not. Then <span class="math inline">\(d(x,c&#39;) \leq d(x,c) \leq\lfloor \frac{d-1}{2} \rfloor\)</span>. But then by the triangle inequality we have <span class="math display">\[d(c,c&#39;) \leq d(c,x) + d(x,c&#39;) \leq2 \left\lfloor \frac{d-1}{2} \right\rfloor \leq d-1.\]</span> This contradicts that <span class="math inline">\(d\)</span> was minimum distance.</p></li>
</ul>
</div>
<p>Draw your own pictures for these proofs: For i), you need a circle of radius <span class="math inline">\(d - 1\)</span> centred on <span class="math inline">\(c\)</span>. For ii), draw the “suppose" part: a triangle with vertices <span class="math inline">\(c\)</span>, <span class="math inline">\(x\)</span>, and <span class="math inline">\(c&#39;\)</span>.</p>
<p>Informally, we often say the code <span class="math inline">\(C\)</span> “detects" or “corrects" so many symbol-errors, when we really mean that our decoding procedure, used with this code, detects or corrects them.</p>
<div class="exampleqed">
<p>Let <span class="math inline">\(C\)</span> have <span class="math inline">\(d = 5\)</span>. Then <span class="math inline">\(\lfloor \frac{d-1}{2}\rfloor = 2\)</span>, and so this code can detect up to 4 symbol errors and correct up to 2 symbol errors.</p>
</div>
<div class="exampleqed">
<p>The code <span class="math inline">\(C_2 = \{00,11\} \subseteq \{0,1\}^2\)</span> has <span class="math inline">\(d=2\)</span>. So it detects up to 2 - 1 = 1 symbol-errors, but corrects <span class="math inline">\(\lfloor \frac{2-1}{2}\rfloor = 0\)</span>, as we found.</p>
<p>The code <span class="math inline">\(C_1 = \{000,111\} \subseteq \{0,1\}^3\)</span> has <span class="math inline">\(d=3\)</span>. So it detects up to 3 - 1 = 2 symbol-errors, but corrects <span class="math inline">\(\lfloor \frac{3-1}{2}\rfloor = 1\)</span>. Suppose that <span class="math inline">\(c=000\)</span> is sent, but we receive <span class="math inline">\(x= 101\)</span>, so we have 2 symbol-errors. Then we detect that symbol-errors have occurred, because <span class="math inline">\(x\)</span> is not a codeword. But nearest-neighbour decoding gives 111, so we fail to correct them.</p>
</div>
</section>
<section id="sec:probabilities" class="level2" data-number="1.3">
<h2 data-number="1.3"><span class="header-section-number">1.3</span> Probabilities</h2>
<p>So far we have tacitly assumed that a codeword is more likely to suffer a small number of symbol-errors, than a larger number. This is why Proposition <a href="#prop:correctdetect" data-reference-type="ref" data-reference="prop:correctdetect">[prop:correctdetect]</a>, which talks about being able to detect or correct symbol-errors <span><em>up to</em></span> a certain number, is useful. Now we must make our assumptions explicit, and calculate the probabilities of different outcomes. We start by defining a certain kind of channel, in which all symbol-errors are equally likely.</p>
<div id="def:symmetricchannel" class="definition">
<p> A <span><strong><span class="math inline">\(q\)</span>-ary symmetric channel with symbol-error probability <span class="math inline">\(p\)</span></strong></span> is a channel for a <span class="math inline">\(q\)</span>-ary alphabet <span class="math inline">\(A\)</span> such that:</p>
<ul>
<li><p>For any <span class="math inline">\(a \in A\)</span>, the chance that it is changed in the channel is <span class="math inline">\(p\)</span>.</p></li>
<li><p>For any <span class="math inline">\(a, b \in A, a\neq b\)</span>, the chance that <span class="math inline">\(a\)</span> is changed to <span class="math inline">\(b\)</span> in the channel, written <span class="math inline">\(P(b\; {\rm received}\;|\; a \;{\rm sent})\)</span>, is <span class="math inline">\(\frac{p}{q-1}\)</span>.</p></li>
</ul>
</div>
<p>Symmetric channels are easy to work with, but many real-life channels are not strictly symmetric. Part ii) of the definition says that <span class="math inline">\(p\)</span>, the chance of change, is split equally among all <span class="math inline">\(q-1\)</span> other symbols: each wrong symbol is equally likely. So the symbol 6 would be equally likely to become 5, 0, or 9. But in fact 5 and 7 are more likely if someone is typing, 0 if copying by hand, and 9 if arranging plastic numbers on the fridge!</p>
<p>Part i) says that the chance of change is not affected by which symbol is sent, or its position in the codeword, or which other symbols are nearby, or whether other symbols are changed. So for example, in a symmetric channel, 12234 is equally likely to become 12334 or 12134. In fact, if someone tries to remember or copy 12234, 12334 (repeating the wrong symbol) is much more likely than 12134. Similarly, with two symbol-errors occurring, in a symmetric channel 12234 is equally likely to become 12243 or 14233. But for human error, 12243 (swapping two adjacent symbols) is the more likely.</p>
<p>(For many types of mechanical channel, also, 12234 is more likely to become 12243 than 14233, but this is because the physical cause of a symbol-error (a scratch on a CD, or a surge of electricity, for example) is likely also to affect adjacent symbols. So symbol-errors in the last two positions is more likely than symbol-errors in the second position and the last. There are ways to adapt nearest-neighbour decoding to help with the fact that, in real life, symbol-errors may tend to come in “bursts".)</p>
<p>In the language of probability, i) implies that in a symmetric channel, symbol-errors in different positions are <span><em>independent</em></span> events. This makes for easy calculations.</p>
<div id="prop:receivedgivensentprobability" class="proposition">
<p> Let <span class="math inline">\(c\)</span> be a codeword in a <span class="math inline">\(q\)</span>-ary code of block-length <span class="math inline">\(n\)</span>, sent over a <span class="math inline">\(q\)</span>-ary symmetric channel with symbol-error probability <span class="math inline">\(p\)</span>. Then <span class="math display">\[P( x \;{\rm received} \;| \;  c \;{\rm sent}) = \left( \frac{p}{q-1}\right)^t(1-p)^{n-t},\;\; {\rm where}\;\; t = d(c,x).\]</span></p>
</div>
<div class="proof">
<p>First we note that, from the definition of of a symmetric channel, the chance of a symbol remaining correct is <span class="math inline">\(1-p\)</span>.</p>
<p>To change <span class="math inline">\(c\)</span> to <span class="math inline">\(x\)</span>, the channel must make the “right" change in each of the “right" <span class="math inline">\(t\)</span> positions. From Definition <a href="#def:symmetricchannel" data-reference-type="ref" data-reference="def:symmetricchannel">[def:symmetricchannel]</a>, the chance of each of these events is <span class="math inline">\(\frac{p}{q-1}\)</span>. Since they are independent, the chance of all of them occurring is <span class="math inline">\(\left( \frac{p}{q-1}\right)^t\)</span>. But the symbols in the other <span class="math inline">\(n-t\)</span> positions must remain correct, and the chance of this is <span class="math inline">\((1-p)^{n-t}\)</span>. Again using independence, we multiply to get the result.</p>
</div>
<p>In the case <span class="math inline">\(t =0\)</span>, we have <span class="math inline">\(x=c\)</span>. So the chance of <span class="math inline">\(c\)</span> being correctly received is <span class="math inline">\((1-p)^n\)</span>.</p>
<div class="exampleqed">
<p>Using the code <span class="math inline">\(C_2 = \{000,111\} \subseteq \{0,1\}^3\)</span>, so <span class="math inline">\(q=2\)</span>, suppose 000 is sent. Then the chance of receiving 001 is <span class="math inline">\(p(1-p)^2\)</span>. There is the same chance of receiving 010. In fact, we can complete the following table:</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: center;"><span class="math inline">\(x\)</span></td>
<td style="text-align: center;"><span class="math inline">\(t=d(000,x)\)</span></td>
<td style="text-align: center;">chance 000</td>
<td style="text-align: center;">chance if <span class="math inline">\(p=0.01\)</span></td>
<td style="text-align: center;">n-n decodes</td>
</tr>
<tr class="even">
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;">received as <span class="math inline">\(x\)</span></td>
<td style="text-align: center;"></td>
<td style="text-align: center;">correctly?</td>
</tr>
<tr class="odd">
<td style="text-align: center;">000</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;"><span class="math inline">\((1-p)^3\)</span></td>
<td style="text-align: center;">0.970299</td>
<td style="text-align: center;">yes</td>
</tr>
<tr class="even">
<td style="text-align: center;">100</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;">010</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;"><span class="math inline">\(p(1-p)^2\)</span></td>
<td style="text-align: center;">0.009801</td>
<td style="text-align: center;">yes</td>
</tr>
<tr class="even">
<td style="text-align: center;">001</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;">110</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;">101</td>
<td style="text-align: center;">2</td>
<td style="text-align: center;"><span class="math inline">\(p^2(1-p)\)</span></td>
<td style="text-align: center;">0.000099</td>
<td style="text-align: center;">no</td>
</tr>
<tr class="odd">
<td style="text-align: center;">011</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;">111</td>
<td style="text-align: center;">3</td>
<td style="text-align: center;"><span class="math inline">\(p^3\)</span></td>
<td style="text-align: center;">0.000001</td>
<td style="text-align: center;">no</td>
</tr>
</tbody>
</table>
</div>
<p>Note that nearest-neighbour decoding corrects 000, 100, 010, and 001 all to 000. So, if <span class="math inline">\(p=.01\)</span>, then the chance of success is: <span class="math display">\[\begin{aligned}
P(\text{we decode back to 000}) &amp; = &amp; P(\text{we receive 000, 001, 010, or 100})\\
 &amp; = &amp;  0.99^3 + 3 \times 0.01 \times 0.99^2 =  0.999702\\ \end{aligned}\]</span> We can also see in the table that because <span class="math inline">\(p&lt; 1-p\)</span>, smaller <span class="math inline">\(d(000,x)\)</span> gives a larger chance. A closer <span class="math inline">\(x\)</span> is more likely to be received. More generally, we have:</p>
<p><span id="cor:receivedwordlikelyneighbour" label="cor:receivedwordlikelyneighbour">[cor:receivedwordlikelyneighbour]</span> If <span class="math inline">\(p &lt; (q-1)/q\)</span> then <span class="math inline">\(P(x \;{\rm received}\;|\;c \;\rm{sent})\)</span> increases as <span class="math inline">\(d(x,c)\)</span> decreases.</p>
<p>Before we prove this, consider a channel so noisy that all information is lost: whatever symbol is sent, there is an equal chance, <span class="math inline">\(1/q\)</span>, of each symbol being received. In a ‘random’ channel like this, the chance that a symbol is changed is <span class="math inline">\((q-1)/q\)</span>. So the corollary is considering channels which are better than random.</p>
<div class="proof">
<p>If <span class="math inline">\(p &lt; (q-1)/q\)</span> then it is easy to show that <span class="math inline">\(1-p &gt;1/q\)</span> (the chance that a symbol remains unchanged is more than random), and also that <span class="math inline">\(p/(q-1)&lt;1/q\)</span> (the chance that a specified wrong symbol is received is less than random). Putting these together, we have <span class="math inline">\((1-p) &gt; p/(q-1)\)</span> (so the most likely symbol to be received is the correct one) and it follow that <span class="math inline">\((1-p)^{n-t}\left( \frac{p}{q-1}\right)^t\)</span> is larger for smaller <span class="math inline">\(t\)</span>.</p>
</div>
<div class="exampleqed">
<p>For the (3,3,3) code <span class="math inline">\(C=\{ 111, 202, 020 \} \subseteq \{0, 1, 2\}^3\)</span>, there are more words to consider. Suppose we send codeword <span class="math inline">\(c=111\)</span> through a ternary symmetric channel with symbol-error probability <span class="math inline">\(p\)</span>. The following table shows the probability of different <span class="math inline">\(d(x,c)\)</span>, when <span class="math inline">\(p=1/4\)</span> and when <span class="math inline">\(p= 1/2\)</span>, calculated using Proposition <a href="#prop:receivedgivensentprobability" data-reference-type="ref" data-reference="prop:receivedgivensentprobability">[prop:receivedgivensentprobability]</a>:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;"></th>
<th style="text-align: center;"><span><span class="math inline">\(p= 1/4\)</span></span></th>
<th style="text-align: center;"><span><span class="math inline">\(p= 1/2\)</span></span></th>
<th style="text-align: center;"></th>
<th style="text-align: center;"></th>
<th style="text-align: center;"></th>
<th style="text-align: center;"></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><span class="math inline">\(t=\)</span></td>
<td style="text-align: center;">ex.s of</td>
<td style="text-align: center;"># of</td>
<td style="text-align: center;">for each such <span class="math inline">\(x\)</span>,</td>
<td style="text-align: center;">prob. of</td>
<td style="text-align: center;">for each such <span class="math inline">\(x\)</span>,</td>
<td style="text-align: center;">prob. of</td>
</tr>
<tr class="even">
<td style="text-align: center;"><span class="math inline">\(d(x,c)\)</span></td>
<td style="text-align: center;">such <span class="math inline">\(x\)</span></td>
<td style="text-align: center;">such <span class="math inline">\(x\)</span></td>
<td style="text-align: center;">prob. received</td>
<td style="text-align: center;">this <span class="math inline">\(t\)</span></td>
<td style="text-align: center;">prob. received</td>
<td style="text-align: center;">this <span class="math inline">\(t\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;">0</td>
<td style="text-align: center;">111</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;"><span class="math inline">\(\left(1-\frac{1}{4}\right)^3\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\frac{27}{64}\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\left(1-\frac{1}{2}\right)^3\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\frac{1}{8}\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"><span class="math inline">\(= \frac{27}{64}\)</span></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"><span class="math inline">\(= \frac{1}{8}\)</span></td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;"></td>
<td style="text-align: center;">110</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;">1</td>
<td style="text-align: center;">112</td>
<td style="text-align: center;">6</td>
<td style="text-align: center;"><span class="math inline">\(\left(1-\frac{1}{4}\right)^2 \cdot\frac{1/4}{2}\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\frac{27}{64}\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\left(1-\frac{1}{2}\right)^2 \cdot\frac{1/2}{2}\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\frac{3}{8}\)</span></td>
</tr>
<tr class="even">
<td style="text-align: center;"></td>
<td style="text-align: center;">101</td>
<td style="text-align: center;">= <span class="math inline">\(\binom{3}{1} \times 2\)</span></td>
<td style="text-align: center;"><span class="math inline">\(= \frac{9}{128}\)</span></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"><span class="math inline">\(= \frac{1}{16}\)</span></td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;"></td>
<td style="text-align: center;">⋮</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;"></td>
<td style="text-align: center;">100</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;"></td>
<td style="text-align: center;">102</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;">2</td>
<td style="text-align: center;">120</td>
<td style="text-align: center;">12</td>
<td style="text-align: center;"><span class="math inline">\(\left(1-\frac{1}{4}\right) \left(\frac{1/4}{2}\right)^2\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\frac{9}{64}\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\left(1-\frac{1}{2}\right) \left(\frac{1/2}{2}\right)^2\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\frac{3}{8}\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: center;"></td>
<td style="text-align: center;">122</td>
<td style="text-align: center;">= <span class="math inline">\(\binom{3}{2}\times 2^2\)</span></td>
<td style="text-align: center;"><span class="math inline">\(= \frac{3}{256}\)</span></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"><span class="math inline">\(= \frac{1}{32}\)</span></td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;"></td>
<td style="text-align: center;">⋮</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;"></td>
<td style="text-align: center;">000</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;">3</td>
<td style="text-align: center;">002</td>
<td style="text-align: center;">8</td>
<td style="text-align: center;"><span class="math inline">\(\left(\frac{1/4}{2}\right)^3\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\frac{1}{64}\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\left(\frac{1/2}{2}\right)^3\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\frac{1}{8}\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: center;"></td>
<td style="text-align: center;">⋮</td>
<td style="text-align: center;"><span class="math inline">\(=\binom{3}{3}\times 2^3\)</span></td>
<td style="text-align: center;"><span class="math inline">\(= \frac{1}{512}\)</span></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"><span class="math inline">\(= \frac{1}{64}\)</span></td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;"></td>
<td style="text-align: center;">222</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
</tbody>
</table>
<p>Both <span class="math inline">\(p=1/4\)</span> and <span class="math inline">\(p=1/2\)</span> are quite large, but we have <span class="math inline">\(p&lt; (3-1)/3\)</span>, so Corollary <a href="#cor:receivedwordlikelyneighbour" data-reference-type="ref" data-reference="cor:receivedwordlikelyneighbour">[cor:receivedwordlikelyneighbour]</a> applies, and we can see the probabilities increase as we go up the fourth or sixth column.</p>
<p>As <span class="math inline">\(d(C)\)</span> is 3 , <span class="math inline">\(C\)</span> can correct one symbol-error and detect two. A word with <span class="math inline">\(\geq 2\)</span> symbol-errors may have the the wrong nearest neighbour (102 has nearest neighbour 202), or it may have several nearest neighbours (100 has all three codeword as nearest neighbours).</p>
<p>So suppose now we only decode when the nearest neighbour is unique. Then for <span class="math inline">\(d(x,c) =0\)</span> or 1 we will always decode correctly. For <span class="math inline">\(d(x,c) =2\)</span> or 3 we will sometimes decode incorrectly (e.g.102 to 202), and sometime not at all (e.g. 100). So, <span class="math inline">\(P(x \;{\rm correctly  \; decoded}) = P( d(x,c) = 0 \;{\rm or}\; 1)\)</span>. Thus, for <span class="math inline">\(p=1/4\)</span>, <span class="math inline">\(P(x \;{\rm correctly  \; decoded})  = \frac{27}{64} +\frac{27}{64} = \frac{27}{32}\)</span>, and for <span class="math inline">\(p=1/2\)</span> this is <span class="math inline">\(\frac{1}{8} +  \frac{3}{8} = \frac{1}{2}\)</span>.</p>
<p>How does this compare to using the trivial (1, 3, 1) code <span class="math inline">\(C_0 = \{0,1,2\}\)</span>? Here we simply send one symbol and the chance of it being received correctly is <span class="math inline">\(1-p\)</span>. For <span class="math inline">\(p=1/4\)</span>, <span class="math inline">\(\frac{27}{32} &gt; \frac{3}{4}\)</span>, so <span class="math inline">\(C\)</span> with nearest-neighbour decoding is a little more reliable than <span class="math inline">\(C_0\)</span>. But for <span class="math inline">\(p= 1/2\)</span> we gain nothing.</p>
</div>
<p>Both Proposition <a href="#prop:receivedgivensentprobability" data-reference-type="ref" data-reference="prop:receivedgivensentprobability">[prop:receivedgivensentprobability]</a> and Corollary <a href="#cor:receivedwordlikelyneighbour" data-reference-type="ref" data-reference="cor:receivedwordlikelyneighbour">[cor:receivedwordlikelyneighbour]</a> are from the sender’s point of view: they assume we know which codeword <span class="math inline">\(c\)</span> was sent, and tell us about <span class="math inline">\(P(x \;{\rm received}\;|\;c \;\rm{sent})\)</span> for different possible <span class="math inline">\(x\)</span>s. But the receivers know only that word <span class="math inline">\(x\)</span> has arrived. What <span><em>they</em></span> want to know is, which word is most likely to have been sent? They must compare, for all codewords <span class="math inline">\(c\)</span>, <span class="math inline">\(P(c \;{\rm sent}\;|\;x \;{\rm received})\)</span>. The following proposition, closely related to Cor. 1.4, may seem obvious. To prove it, we use Bayes’ theorem, which allows us to ‘reverse’ the conditional probabilities.</p>
<div id="prop:nearestneighbourslikely" class="proposition">
<p>Suppose that a <span class="math inline">\(q\)</span>-ary <span class="math inline">\((n,M,d)\)</span> code <span class="math inline">\(C\)</span> is sent over a <span class="math inline">\(q\)</span>-ary symmetric channel with symbol-error probability <span class="math inline">\(p\)</span>, where <span class="math inline">\(p &lt; (q-1)/q\)</span>, and each codeword <span class="math inline">\(c \in C\)</span> is equally likely to be sent. Then for any word <span class="math inline">\(x\)</span> received, <span class="math inline">\(P(c \;{\rm sent}\;|\;x \;{\rm received})\)</span> increases as <span class="math inline">\(d(x,c)\)</span> decreases.</p>
</div>
<div class="proof">
<p><span class="math display">\[\begin{aligned}
			P(c \;{\rm sent}\;|\;x \;{\rm received})
			&amp; = \frac{P(c \;{\rm sent \; and }\;x \;{\rm received})}{P(x \;{\rm received})}\\
			&amp; = \frac{P(c \; {\rm sent})P(x \;{\rm received}\;|\;c \;{\rm sent})}{P(x \;{\rm received})}\\
			&amp;= \frac{P(x \;{\rm received}\;|\;c \;{\rm sent})}{M \cdot P(x \;{\rm received})},
		\end{aligned}\]</span> since we assumed that for any <span class="math inline">\(c \in C\)</span>, <span class="math inline">\(P(c \; {\rm sent})= 1/M\)</span>.</p>
<p>Also, by the law of total probability (also known as the partition theorem), if <span class="math inline">\(C= \{c_1, c_2, \ldots,c_M\}\)</span>, then <span class="math inline">\(P(x \;{\rm received}) = 
 \sum_{i=1}^M P(c_i \; {\rm sent})P(x \;{\rm received}\;|\;c_i \;{\rm sent})\)</span>. This is independent of the <span class="math inline">\(c\)</span> which was sent, since we sum over all possible sent codewords.</p>
<p>Now the receiver knows <span class="math inline">\(x\)</span>, and is considering different possible <span class="math inline">\(c\)</span>’s. But in <span class="math display">\[P(c \;{\rm sent}\;|\;x \;{\rm received}) = \frac{P(x \;{\rm received}\;|\;c \;{\rm sent})}{M \cdot P(x \;{\rm received})},\]</span> the denominator is independent of <span class="math inline">\(c\)</span>. Hence <span class="math inline">\(P(c \;{\rm sent}\;|\;x \;{\rm received})\)</span> increases as <span class="math inline">\(P(x \;{\rm received}\;|\;c \;{\rm sent})\)</span> increases; that is, by Cor. 1.4, as <span class="math inline">\(d(x,c)\)</span> decreases.</p>
</div>
<p>So the nearest neighbours of <span class="math inline">\(x\)</span> are indeed the most likely codewords to have been sent. If we have the conditions described in Proposition <a href="#prop:nearestneighbourslikely" data-reference-type="ref" data-reference="prop:nearestneighbourslikely">[prop:nearestneighbourslikely]</a>, we are justified in using nearest-neighbour decoding.</p>
<p>(The assumption that each codeword is equally likely to be sent is important. If this were not the case, it would obviously affect our conclusions. This is like the well-known problem in medical testing for rare diseases, when a false positive may be more likely than an actual case.)</p>
</section>
<section id="sec:boundsoncodes" class="level2" data-number="1.4">
<h2 data-number="1.4"><span class="header-section-number">1.4</span> Bounds on Codes</h2>
<p>What makes a good <span class="math inline">\((n,M,d)\)</span> code? Small <span class="math inline">\(n\)</span> will make transmission faster. Large <span class="math inline">\(M\)</span> will provide many words, to convey many different messages. Large <span class="math inline">\(d\)</span> will allow us to detect and correct more symbol-errors, and so make communication more reliable. But these parameters are related, so we have to make trade-offs. The following is known as the <span><strong>Singleton Bound</strong></span>.</p>
<div class="proposition">
<p>For a <span class="math inline">\(q\)</span>-ary (n,M,d) code, we have <span class="math inline">\(M\leq q^{n-d+1}\)</span>.</p>
</div>
<p>Thus, for fixed <span class="math inline">\(q\)</span>, small <span class="math inline">\(n\)</span> and large <span class="math inline">\(d\)</span> will make <span class="math inline">\(M\)</span> small. This makes sense intuitively: small <span class="math inline">\(n\)</span> makes the space of possible words small, and large <span class="math inline">\(d\)</span> makes the codewords far apart. So we can’t fit in very many of them! The proof involves a ‘projection’ map which simply ‘forgets’ the last <span class="math inline">\(d-1\)</span> symbols of the codeword. (You draw the picture.)</p>
<div class="proof">
<p>Let <span class="math inline">\(C \subseteq A^n\)</span>, where <span class="math inline">\(|A|=q\)</span>. For <span class="math inline">\(d=1\)</span> the proposition is trivial. For <span class="math inline">\(d&gt;1\)</span>, define a map <span class="math inline">\(f:A^n \rightarrow A^{n-d+1}\)</span> by <span class="math inline">\(f(a_1a_2\ldots a_n) =  a_1a_2\ldots a_{n-d+1}\)</span>. Clearly <span class="math inline">\(f\)</span> is not injective on <span class="math inline">\(A^n\)</span>: if two words <span class="math inline">\(x\)</span> and <span class="math inline">\(y\)</span> differ only in the last position, then <span class="math inline">\(f(x) = f(y)\)</span>. But if <span class="math inline">\(x\)</span> and <span class="math inline">\(y\)</span> are distinct codewords in <span class="math inline">\(C\)</span>, they must differ in <span class="math inline">\(\geq d\)</span> positions. So <span class="math inline">\(f\)</span> cannot ‘forget’ all these differences, so <span class="math inline">\(f(x) \neq f(y)\)</span>. Thus <span class="math inline">\(f\)</span> is injective on <span class="math inline">\(C\)</span>, and it follows that <span class="math inline">\(|f(C)| = |C|\)</span>. But <span class="math inline">\(f(C) \subseteq A^{n-d+1}\)</span>, so <span class="math display">\[M =|C|= |f(C)|\leq |A^{n-d+1}| = q^{n-d+1}\]</span> as required.</p>
</div>
<p>A code which saturates the Singleton bound is known as <em>Maximum Distance Separable</em> or MDS.</p>
<div id="eg:MDSbinaryrepatition" class="exampleqed">
<p> Let <span class="math inline">\(C_n\)</span> be the ‘binary repetition code’ of block length <span class="math inline">\(n\)</span>, <span class="math display">\[C_n := \{ \overbrace{00\ldots0}^n, \overbrace{11\ldots1}^n \} \subset \{0,1\}^n.\]</span></p>
<p><span class="math inline">\(C_n\)</span> is a <span class="math inline">\((n,2,n)_2\)</span> code, and since <span class="math inline">\(2 = 2^{n-n+1}\)</span>, <span class="math inline">\(C_n\)</span> is an MDS code.</p>
</div>
<div class="definition">
<p>Let <span class="math inline">\(A\)</span> be an alphabet, <span class="math inline">\(|A| = q\)</span>. Let <span class="math inline">\(n\geq 1\)</span> and <span class="math inline">\(0 \leq t \leq n\)</span> be integers, and <span class="math inline">\(x\)</span> a word in <span class="math inline">\(A^n\)</span>. Then</p>
<ul>
<li><p>The <span><strong>sphere of radius <span class="math inline">\(t\)</span> around <span class="math inline">\(x\)</span></strong></span> is <span class="math inline">\(S(x,t) = \{y \in A^n \;|\; d(y,x) \leq t \}\)</span>.</p></li>
<li><p>A code <span class="math inline">\(C \subseteq A^n\)</span> is <span><strong>perfect</strong></span> if there is some <span class="math inline">\(t\)</span> such that <span class="math inline">\(A^n\)</span> is the disjoint union of all the <span class="math inline">\(S(c,t)\)</span> as <span class="math inline">\(c\)</span> runs through <span class="math inline">\(C\)</span>.</p></li>
</ul>
</div>
<p>Because of the ‘ <span class="math inline">\(\leq\)</span>’, <span class="math inline">\(S(c,t)\)</span> is like a solid ball around <span class="math inline">\(c\)</span>, not just the surface of a sphere. (Of course, we use the Hamming distance, not ordinary Euclidean distance.) In a perfect code, the <span class="math inline">\(S(c,t)\)</span> partition <span class="math inline">\(A^n\)</span>. Thus any word <span class="math inline">\(x \in A^n\)</span> is in exactly one <span class="math inline">\(S(c,t)\)</span>, and that <span class="math inline">\(c\)</span> is <span class="math inline">\(x\)</span>’s unique nearest neighbour.</p>
<div class="exampleqed">
<p>For <span class="math inline">\(C_1 = \{000, 111\} \subseteq  \{0,1\}^3\)</span>, we have <span class="math inline">\(S(000,1) = \{ 000, 100, 010, 001\}\)</span> and <span class="math inline">\(S(111,1) = \{ 111, 011, 101, 110\}\)</span>. These are disjoint, and <span class="math inline">\(S(000,1) \cup S(111,1) =  \{0,1\}^3\)</span>. So <span class="math inline">\(C_1\)</span> is perfect. (You should draw a picture, with the words of <span class="math inline">\(A^n\)</span> labelling the vertices of a cube in the obvious way. Or even better, make a model.)</p>
</div>
<div class="exampleqed">
<p>Let <span class="math inline">\(C_2 = \{ 111, 020, 202\} \subseteq  \{0,1,2\}^3\)</span>. Then, for example, <span class="math inline">\(S(111,1) = \{111, 110, 112, 101, 121, 011, 211\}\)</span>. Is <span class="math inline">\(C_2\)</span> perfect? No, because for all <span class="math inline">\(c \in C\)</span>, we have <span class="math inline">\(d(c,012) = 2\)</span>. So 012 is not in any <span class="math inline">\(S(c,1)\)</span>, but is in every <span class="math inline">\(S(c,2)\)</span>. Thus for <span class="math inline">\(t = 0\)</span> or 1 the <span class="math inline">\(S(c,t)\)</span> do not cover all of <span class="math inline">\(\{0,1,2\}^3\)</span>, and for <span class="math inline">\(t= 2\)</span> or 3 they are not disjoint.</p>
</div>
<p>To decide whether a code is perfect or not, we may not need to consider the actual codewords. We can look first at the sizes of spheres in the space. As we would expect, the size of a sphere in <span class="math inline">\(A^n\)</span> depends only on its ‘radius’, <span class="math inline">\(t\)</span>, not on its centre.</p>
<div class="lemma">
<p>If <span class="math inline">\(|A| = q\)</span>, <span class="math inline">\(n\geq 1\)</span>, and <span class="math inline">\(x \in A^n\)</span>, then <span class="math display">\[|S(x,t)| 
%%   =  1+ n(q-1) + \binom{n}{2}(q-1)^2 + \cdots + \binom{n}{t}(q-1)^t 
= \sum_{k=0}^t\binom{n}{k} (q-1)^k.\]</span></p>
</div>
<div class="proof">
<p>How many <span class="math inline">\(y \in A^n\)</span> have <span class="math inline">\(d(x,y) = k\)</span>? To make such a <span class="math inline">\(y\)</span> from <span class="math inline">\(x\)</span>, we must first choose <span class="math inline">\(k\)</span> positions to change: <span class="math inline">\(\binom{n}{k}\)</span> ways to do this. Then for each chosen position, we choose one of the <span class="math inline">\(q-1\)</span> other symbols: <span class="math inline">\((q-1)^k\)</span> ways. So there are <span class="math inline">\(\binom{n}{k}(q-1)^k\)</span> such <span class="math inline">\(y\)</span>. Now we build up the sphere in layers, by letting <span class="math inline">\(k\)</span> go from 0 to <span class="math inline">\(t\)</span>.</p>
</div>
<div class="exampleqed">
<p>For the code <span class="math inline">\(C_2\)</span> above, we have, <span class="math inline">\(q=3\)</span>, <span class="math inline">\(n=3\)</span>. So <span class="math inline">\(|S(x, 1)| = \binom{3}{0} + \binom{3}{1}(3-1) = 1+6 = 7\)</span> , as we saw, and <span class="math inline">\(|S(x, 2)| = \binom{3}{0} + \binom{3}{1}(3-1) + \binom{3}{2}(3-1)^2 = 1+6+12 = 19\)</span>. Since <span class="math inline">\(|\{0,1,2\}^3|=27\)</span>, and neither 7 nor 19 divides 27, clearly this space cannot be partitioned by spheres of either size. Three spheres containing 7 words each cannot fill the space, and three containing 19 must overlap, just as we saw by considering the word 012.</p>
<p>Of course, <span class="math inline">\(|S(x, 3)|=27\)</span>, and <span class="math inline">\(|S(x, 0)|\)</span> is always 1, and these do divide 27. But to use these spheres to make a perfect code, we would have to have, respectively, just one codeword, or <span class="math inline">\(C = A^n\)</span>. These ‘trivial’ codes are no use to us.</p>
</div>
<p>We can use spheres to give us another bound on the size of a code. This is known as the <span><strong>Hamming Bound</strong></span> or the <span><strong>Sphere-packing Bound</strong></span>:</p>
<div id="prop:hammingbound" class="proposition">
<p>A <span class="math inline">\(q\)</span>-ary <span class="math inline">\((n,M,d)\)</span> code satisfies: <span class="math display">\[M \cdot \sum_{k=0}^t\binom{n}{k} (q-1)^k  \leq q^n, \;\; {\rm where} \; t = \left\lfloor\frac{d-1}{2}\right\rfloor.\]</span></p>
</div>
<p>Notice that we are relating the radius of the sphere to the minimum distance of the code; in fact, we must have <span class="math inline">\(d = 2t+1\)</span> or <span class="math inline">\(2t+2\)</span>. The first part of the proof is really the same as that of the second part of Proposition <a href="#prop:correctdetect" data-reference-type="ref" data-reference="prop:correctdetect">[prop:correctdetect]</a>. The notation is different, but the picture is the same.</p>
<div class="proof">
<p>Let the code be <span class="math inline">\(C \subseteq A^n\)</span>. First we must show that the <span class="math inline">\(S(c,t)\)</span> for codewords <span class="math inline">\(c \in C\)</span> are disjoint. Suppose not, so there is some <span class="math inline">\(x \in A^n\)</span> such that <span class="math inline">\(x \in S(c_1,t)\)</span> and <span class="math inline">\(x \in S(c_2,t)\)</span>, where <span class="math inline">\(c_1 \neq c_2\)</span>. This means that <span class="math inline">\(d(x,c_1)\)</span> and <span class="math inline">\(d(x,c_2)\)</span> are both <span class="math inline">\(\leq t\)</span>. So by the triangle inequality we have <span class="math inline">\(d(c_1,c_2) \leq d(x,c_1) +d(x,c_2) \leq 2t\)</span>. But this contradicts <span class="math inline">\(d(c_1,c_2) \geq d(C) \geq 2t+1\)</span>.</p>
<p>Now <span class="math display">\[\bigcup_{c \in C} S(c,t) \subseteq A^n, \;\; {\rm so}\;\; \left|\bigcup_{c \in C} S(c,t)\right| \leq q^n.\]</span> But since the <span class="math inline">\(S(c,t)\)</span> are disjoint, we have <span class="math display">\[\left|\bigcup_{c \in C} S(c,t)\right| = \sum_{c \in C} |S(c,t)| = M|S(c,t)|.\]</span> Thus <span class="math inline">\(M|S(c,t)|\leq q^n\)</span>, which by Lemma 1.7 proves the proposition.</p>
</div>
<p>We have equality in the Hamming Bound if and only if the code is perfect; in this case the spheres <span class="math inline">\(S(c,t)\)</span>, which are as large as they can be without overlapping, will fill <span class="math inline">\(A^n\)</span>. Thus for a perfect code, <span class="math inline">\(M\)</span> must divide <span class="math inline">\(q^n\)</span>, and so must <span class="math inline">\(|S(c,t)| = \sum_{k=0}^t\binom{n}{k} (q-1)^k\)</span> for some <span class="math inline">\(t\)</span>. We used this idea in the example above. It is also not hard to show that a perfect code must have <span class="math inline">\(d\)</span> odd (see Q16).</p>
</section>
</section>
<section id="cha:linearcodes" class="level1" data-number="2">
<h1 data-number="2"><span class="header-section-number">2</span> Linear Codes</h1>
<p>In Chapter 1, we used <span class="math inline">\(0, 1, 2, \ldots\)</span> purely as symbols in an alphabet <span class="math inline">\(A\)</span>, and our code could be any subset of <span class="math inline">\(A^n\)</span>. To make progress we now want to do arithmetic with our symbols, so our alphabet must be a field <span class="math inline">\(F\)</span>. Then we can regard our words in <span class="math inline">\(A^n\)</span> as vectors in <span class="math inline">\(F^n\)</span>, which is a vector space over <span class="math inline">\(F\)</span>. Moreover, we shall require that our code <span class="math inline">\(C\)</span> is a subspace of <span class="math inline">\(F^n\)</span>.</p>
<section id="sec:finitefields" class="level2" data-number="2.1">
<h2 data-number="2.1"><span class="header-section-number">2.1</span> Finite Fields</h2>
<p>A field is a set with two binary operations, which obey the standard rules of arithmetic.</p>
<div class="definition">
<p>A non-empty set <span class="math inline">\(F\)</span> with addition <span class="math inline">\(F \times F \rightarrow F\)</span>, mapping <span class="math inline">\((a,b)\)</span> to <span class="math inline">\(a+b\)</span>, and multiplication <span class="math inline">\(F \times F \rightarrow F\)</span>, mapping <span class="math inline">\((a,b)\)</span> to <span class="math inline">\(ab\)</span>, is called a <span><strong>field</strong></span> if the following axioms hold.</p>
<ul>
<li><p>Associativity of addition: For every <span class="math inline">\(a\)</span>, <span class="math inline">\(b\)</span>, and <span class="math inline">\(c\)</span> in <span class="math inline">\(F\)</span>, <span class="math inline">\((a+b)+c = a+(b+c)\)</span></p></li>
<li><p>Additive identity: There exists 0 in <span class="math inline">\(F\)</span> such that for every <span class="math inline">\(a \in F\)</span>, <span class="math inline">\(a+0 = a = 0+a\)</span></p></li>
<li><p>Additive inverse: For every <span class="math inline">\(a \in F\)</span>, there exists <span class="math inline">\(b \in F\)</span> such that <span class="math inline">\(a+b = 0 = b+a\)</span></p></li>
<li><p>Commutative addition: For every <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span> in <span class="math inline">\(F\)</span>, <span class="math inline">\(a+b = b+a\)</span></p></li>
<li><p>Associativity of multiplication: For every <span class="math inline">\(a\)</span>, <span class="math inline">\(b\)</span>, and <span class="math inline">\(c\)</span> in <span class="math inline">\(F\)</span>, <span class="math inline">\((a\cdot b)\cdot c = a\cdot (b\cdot c)\)</span></p></li>
<li><p>Multiplicative identity: There exists 1 in <span class="math inline">\(F\)</span> such that, for every <span class="math inline">\(a \in F\)</span>, <span class="math inline">\(1\cdot a = a = a \cdot 1\)</span></p></li>
<li><p>Multiplicative inverse: For every <span class="math inline">\(a \in F\)</span>, <span class="math inline">\(a \neq 0\)</span>, there exists <span class="math inline">\(b \in F\)</span> such that <span class="math inline">\(a\cdot b = 1 = b \cdot a\)</span></p></li>
<li><p>Commutative multiplication: For every <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span> in <span class="math inline">\(F\)</span>, <span class="math inline">\(a \cdot b =b \cdot a\)</span></p></li>
<li><p>Distributivity: For every <span class="math inline">\(a\)</span>, <span class="math inline">\(b\)</span>, and <span class="math inline">\(c\)</span> in <span class="math inline">\(F\)</span>, <span class="math inline">\((a+b)\cdot c = a\cdot c + b\cdot c\)</span> and <span class="math inline">\(a\cdot (b+c) = a\cdot b + a\cdot c\)</span></p></li>
<li><p>Multiplicative and additive inverses are different: <span class="math inline">\(0 \neq 1\)</span></p></li>
</ul>
</div>
<p>Axioms i - iv make <span class="math inline">\((F, +)\)</span> into an abelian (or commutative) group; axioms v - viii make <span class="math inline">\((F-\{0\}, \cdot)\)</span> into another abelian group; axioms i - vi &amp; ix make <span class="math inline">\((F,+,\cdot)\)</span> a ring. Note that the definitions of addition and multiplication as maps <span class="math inline">\(F \times F \rightarrow F\)</span> imply that these operations are closed. It is easy to show that the identities 0 and 1 are unique, and that for each <span class="math inline">\(a \in F\)</span>, the additive inverse <span class="math inline">\(-a\)</span> and the multiplicative inverse <span class="math inline">\(a^{-1}\)</span> are unique. We also have some convenient notations: for <span class="math inline">\(m\)</span> a non-negative integer, we write <span class="math inline">\(m\cdot a\)</span> for adding, and <span class="math inline">\(a^m\)</span> for multiplying, <span class="math inline">\(m\)</span> copies of <span class="math inline">\(a\)</span>. It’s all very familiar.</p>
<p>However, the fields you know best are the reals <span class="math inline">\({\mathbb R}\)</span>, the complex numbers <span class="math inline">\({\mathbb C}\)</span>, and the rationals <span class="math inline">\({\mathbb Q}\)</span>, and these are no good as alphabets, because they are infinite.</p>
<p>To find finite fields, we start from arithmetic modulo <span class="math inline">\(n\)</span>. Here the set <span class="math inline">\({\mathbb Z}/n\)</span> (or <span class="math inline">\({\mathbb Z}_n\)</span>, or <span class="math inline">\({\mathbb Z}/n{\mathbb Z}\)</span>) is the congruence classes <span class="math inline">\(\{[0]_n, [1]_n,\ldots,[n-1]_n\}\)</span> (or <span class="math inline">\(\{\overline{0}, \overline{1},\ldots,\overline{n-1}\}\)</span>), and we add or multiply by using any representative of that class. It is easy to check that every axiom except for vii will hold for any <span class="math inline">\(n\)</span>. But vii holds (that is, <span class="math inline">\({\mathbb Z}/n\)</span> has multiplicative inverses for all non-zero elements) if and only if <span class="math inline">\(n\)</span> is prime.</p>
<p>For <span class="math inline">\(n\)</span> prime we have a field, and to make this clear (and also to be able to use <span class="math inline">\(n\)</span> for block-length, as in Chapter <a href="#cha:basiccodingtheory" data-reference-type="ref" data-reference="cha:basiccodingtheory">1</a>) we shall write <span class="math inline">\({\mathbb F}_p\)</span> instead of <span class="math inline">\({\mathbb Z}/n\)</span>. Once we have specified <span class="math inline">\(p\)</span>, we can write simply <span class="math inline">\(0, 1, 2,\ldots p-1\)</span> rather than <span class="math inline">\([0]_p, [1]_p,\ldots,[p-1]_p\)</span> (or <span class="math inline">\(\overline{0}, \overline{1},\ldots,\overline{p-1}\)</span>).</p>
<p>Are there finite fields with a non-prime number <span class="math inline">\(q\)</span> of elements? The answer is yes if and only if <span class="math inline">\(q\)</span> is a prime power, <span class="math inline">\(q = p^r, r \in {\mathbb Z}_+\)</span>. But of course <span class="math inline">\({\mathbb F}_{3^2} = {\mathbb F}_9 \neq {\mathbb Z}/9\)</span>, because <span class="math inline">\({\mathbb Z}/9\)</span> is not a field. We shall construct and use such non-prime fields <span class="math inline">\({\mathbb F}_q\)</span> in Chapter <a href="#cha:polynomialsandcodes" data-reference-type="ref" data-reference="cha:polynomialsandcodes">6</a>.</p>
<p>The notation <span class="math inline">\({\mathbb F}_q\)</span> is justified, because it can be shown that any two fields with the same number of elements are isomorphic. For general statements we shall call our field <span class="math inline">\({\mathbb F}_q\)</span>, but <span><em>until we reach Chapter <a href="#cha:polynomialsandcodes" data-reference-type="ref" data-reference="cha:polynomialsandcodes">6</a> <span class="math inline">\(q\)</span> will always be prime</em></span> (that is, <span class="math inline">\(r = 1\)</span>). This allows us to keep ‘<span class="math inline">\(p\)</span>’ for the symbol-error probability.</p>
</section>
<section id="finite-vector-spaces" class="level2" data-number="2.2">
<h2 data-number="2.2"><span class="header-section-number">2.2</span> Finite Vector Spaces</h2>
<p>Just as <span class="math inline">\({\mathbb R}^n\)</span> is a vector space over <span class="math inline">\({\mathbb R}\)</span>, <span class="math inline">\({\mathbb F}_q^n =({\mathbb F}_q)^n\)</span> is a vector space over <span class="math inline">\({\mathbb F}_q\)</span>. Everything you have learned about vector spaces (and most of your ideas about <span class="math inline">\({\mathbb R}^n\)</span>) will still work. These notes gives only a quick, informal reminder of the main definitions and ideas from linear algebra which we shall use. Formal definitions, results and examples will be written in terms of finite fields, and spaces and codes over them. The main difference is that we can now count the vectors in a space: to start with, <span class="math inline">\(|{\mathbb F}_q^n|= q^n\)</span>. We can even write a complete list of them.</p>
<p>We shall still sometimes call our vectors ‘words’, and some of them will be our codewords. Because words (in English) are horizontal, we will usually write vectors as rows (rather than columns): <span class="math inline">\({\bf x} = (x_1, x_2, \ldots,x_n) \in {\mathbb F}_q^n\)</span>, where the <span class="math inline">\(x_i\)</span> are in <span class="math inline">\({\mathbb F}_q\)</span>. You need to know which field <span class="math inline">\({\mathbb F}_q\)</span> you are working over, because all arithmetic must be done mod <span class="math inline">\(q\)</span>.</p>
<div class="exampleqed">
<p>The vectors <span class="math inline">\({\bf x} = (0,1,2,0)\)</span> and <span class="math inline">\({\bf y} = (1,1,1,1)\)</span> could be vectors in <span class="math inline">\({\mathbb F}_3^4\)</span>, but they could also be vectors in <span class="math inline">\({\mathbb F}_7^4\)</span>. In <span class="math inline">\({\mathbb F}_3^4\)</span>, we would have <span class="math inline">\({\bf x} + {\bf y} = (1, 2, 0, 1)\)</span>, and <span class="math inline">\(2{\bf x} = (0,2,1,0)\)</span>. But in <span class="math inline">\({\mathbb F}_7^4\)</span>, it would be <span class="math inline">\({\bf x} + {\bf y} = (1, 2, 3, 1)\)</span>, <span class="math inline">\(2{\bf x} = (0,2,4,0)\)</span> and <span class="math inline">\(4{\bf x} = (0,4,1,0)\)</span>.</p>
</div>
<p>In Chapter 1, a code could be any subset of <span class="math inline">\(A^n\)</span>. But we now make a more restrictive definition.</p>
<div class="definition">
<p>A <span><strong>linear code</strong></span> is a subspace of the vector space <span class="math inline">\({\mathbb F}_q^n\)</span>, for some finite field <span class="math inline">\({\mathbb F}_q\)</span> and non-negative integer <span class="math inline">\(n\)</span>.</p>
</div>
<p>Recall that a <span><strong>subspace</strong></span> of a vector space is a subset which is closed under vector addition and scalar multiplication. Thus, if we are given a subset of <span class="math inline">\({\mathbb F}_q^n\)</span> as a list, it is straightforward (if tedious) to check whether it is a linear code or not.</p>
<div class="exampleqed">
<p>Let <span class="math inline">\({\bf x} = (0,1,2,0)\)</span>, and <span class="math inline">\({\bf y} = (1,1,1,1,)\)</span>, <span class="math inline">\({\bf z} = (0,2,1,0)\)</span> and <span class="math inline">\({\bf 0} = (0,0,0,0)\)</span> be vectors in <span class="math inline">\({\mathbb F}_3^4\)</span>. Then <span class="math inline">\(C_1 = \{{\bf x},{\bf y}\}\)</span> is not a linear code since <span class="math inline">\({\bf x}+{\bf y} = (1,2,0,1)\not\in C_1\)</span>. But <span class="math inline">\(C_2 = \{{\bf x},{\bf z},{\bf 0}\}\)</span> is a linear code, as adding any combination of these vectors (which also includes multiplying them by 0, 1 or 2) gives one of them.</p>
</div>
<p>If the subset S is not closed, we can keep adding in vectors as necessary until it is. The resulting space is the <span><strong>span</strong></span> of the set, written <span class="math inline">\(\langle S \rangle\)</span>, and is by construction a linear code.</p>
<div class="exampleqed">
<p>The span of <span class="math inline">\(C_1\)</span> is the linear code <span class="math inline">\(C_3 =\langle C_1 \rangle 
= \langle\{{\bf x},{\bf y}\}\rangle =\)</span> <span class="math display">\[\{(0,0,0,0), (0,1,2,0),  (0,2,1,0),
  (1,1,1,1),  (1,2,0,1), (1,0,2,1), 
  (2,2,2,2),  (2,0,1,2), (2,1,0,2) \}.\]</span></p>
<p>We could also notice that <span class="math inline">\(C_2 = \{0{\bf x},1{\bf x},2{\bf x}\} = \langle\{{\bf x}\}\rangle\)</span>, so in fact <span class="math inline">\(\langle C_2 \rangle = C_2\)</span>.</p>
</div>
<p>If <span class="math inline">\(\langle S \rangle = C\)</span> then we say <span class="math inline">\(S\)</span> is a <span><strong>spanning set</strong></span> for <span class="math inline">\(C\)</span>. There are usually many possible spanning set for a subspace.</p>
<p>A set of vectors <span class="math inline">\(S = \{ {\bf x_1}, {\bf x_2}, \ldots {\bf x_k}\}\)</span> in <span class="math inline">\({\mathbb F}_q^n\)</span> is <span><strong>linearly independent</strong></span> if and only if no non-trivial linear combination of them equals the zero-vector <span class="math inline">\({\bf 0}\)</span>; that is, for <span class="math inline">\(\lambda_i \in {\mathbb F}_q\)</span>, iff:</p>
<p><span class="math display">\[\lambda_1{\bf x_1} +\lambda_2{\bf x_2} + \ldots +\lambda_k{\bf x_k} = {\bf 0} \;\; \Longrightarrow \;\; \lambda_1 =
\lambda_2 = \ldots =\lambda_k = 0.\]</span></p>
<p>A linearly independent spanning set for a linear code <span class="math inline">\(C\)</span> is a <span><strong>basis</strong></span> for <span class="math inline">\(C\)</span>. While there may still be many possible bases, these will all have the same number of vectors, and this number is the <span><strong>dimension</strong></span> of <span class="math inline">\(C\)</span>, written dim(<span class="math inline">\(C\)</span>).</p>
<div class="exampleqed">
<p>The spanning sets of the code listed above, <span class="math inline">\(C_3 \subseteq {\mathbb F}_3^4\)</span>, include <span class="math inline">\(S_1 =\{(0,1,2,0),(1,1,1,1)\}\)</span>, <span class="math inline">\(S_2 =\{(0,1,2,0),(2,2,2,2)\}\)</span>, and <span class="math inline">\(S_3 =\{(0,1,2,0),(1,1,1,1),(2,0,1,2)\}\)</span>.</p>
<p><span class="math inline">\(S_3\)</span> is not a basis, because <span class="math inline">\(1(0,1,2,0)+ 2(1,1,1,1)+ 2(2,0,1,2) = (6,3,6,6)=(0,0,0,0)\)</span>. But both <span class="math inline">\(S_1\)</span> and <span class="math inline">\(S_2\)</span> are linearly independent sets, and thus bases for <span class="math inline">\(C_3\)</span>. So dim<span class="math inline">\((C_3) =2\)</span>.</p>
<p>To prove the linear independence of <span class="math inline">\(S_1\)</span>, we can note that if <span class="math inline">\(\lambda_1(0,1,2,0)+ \lambda_2(1,1,1,1) = (0,0,0,0)\)</span>, then by the first position <span class="math inline">\(\lambda_2 = 0\)</span>, and so then by the second position <span class="math inline">\(\lambda_1 = 0\)</span> also.</p>
</div>
<div class="exampleqed">
<p>For the whole space <span class="math inline">\({\mathbb F}_q^n\)</span>, the ‘standard basis’ is <span class="math inline">\(B = \{ {\bf e_1}, {\bf e_2}, \ldots {\bf e_k}\}\)</span>, where <span class="math inline">\(e_i\)</span> has 1 in the <span class="math inline">\(i^{th}\)</span> position and 0 elsewhere.</p>
</div>
<p>A basis <span class="math inline">\(B\)</span> for a linear code <span class="math inline">\(C\)</span> is “just right" for making every vector <span class="math inline">\({\bf c} \in C\)</span> as a linear combination of vectors from <span class="math inline">\(B\)</span>: a spanning set can make each <span class="math inline">\({\bf c}\)</span> <span><em>at least</em></span> one way, a linearly independent set can make each <span class="math inline">\({\bf c}\)</span> <span><em>at most</em></span> one way, but a basis can make each <span class="math inline">\({\bf c}\)</span> <span><em>exactly</em></span> one way. We use this property to prove the following:</p>
<div id="prop:dimlincode" class="proposition">
<p> If a linear code <span class="math inline">\(C \subseteq {\mathbb F}_q^n\)</span> has dimension <span class="math inline">\(k\)</span>, then <span class="math inline">\(|C| = q^k\)</span>.</p>
</div>
<div class="proof">
<p>Let <span class="math inline">\(B = \{ {\bf x_1}, {\bf x_2}, \ldots {\bf x_k}\}\)</span> be any basis for <span class="math inline">\(C\)</span>. There is a one-to-one correspondence between codewords <span class="math inline">\({\bf c} \in C\)</span> and linear combinations <span class="math inline">\(\lambda_1{\bf x_1} +\lambda_2{\bf x_2} + \ldots +\lambda_k{\bf x_k}\)</span>, with <span class="math inline">\(\lambda_i \in {\mathbb F}_q\)</span>. Each <span class="math inline">\(\lambda_i\)</span> can take any of <span class="math inline">\(q\)</span> values.</p>
</div>
<div class="exampleqed">
<p>For <span class="math inline">\(C_3 \subseteq {\mathbb F}_3^4\)</span> listed above, dim<span class="math inline">\((C_3)=2\)</span>, and <span class="math inline">\(|C_3| = 9 = 3^2\)</span>.</p>
</div>
<p>We can now update our <span class="math inline">\((n, M, d)\)</span> notation for the parameters of a code:</p>
<div class="definition">
<p>A <span class="math inline">\(q\)</span>-ary <span class="math inline">\([n,k,d]\)</span> code is a linear code, a subspace of <span class="math inline">\({\mathbb F}_q^n\)</span> of dimension <span class="math inline">\(k\)</span> with minimum distance <span class="math inline">\(d\)</span>.</p>
</div>
<p>The square or round brackets prevent ambiguity: any <span class="math inline">\(q\)</span>-ary <span class="math inline">\([n, k, d]\)</span> code is also a <span class="math inline">\(q\)</span>-ary <span class="math inline">\((n, q^k,d)\)</span> code, but not vice-versa. From now on, almost all codes will be linear, so I will write “code" for “linear code"</p>
</section>
<section id="sec:arraydecoding" class="level2" data-number="2.3">
<h2 data-number="2.3"><span class="header-section-number">2.3</span> Array Decoding</h2>
<p>The zero element 0 plays a very special role in <span class="math inline">\({\mathbb F}_q\)</span>, and so does the zero vector <span class="math inline">\({\bf 0}\)</span> in <span class="math inline">\({\mathbb F}_q^n\)</span>. We are also interested in how many entries of a general vector <span class="math inline">\({\bf x} \in {\mathbb F}_q^n\)</span> are (or are not) zero.</p>
<div class="definition">
<p>For <span class="math inline">\({\bf x} \in {\mathbb F}_q^n\)</span>, the <span><strong>weight</strong></span> of <span class="math inline">\({\bf x}\)</span>, written <span class="math inline">\(w({\bf x})\)</span>, is the number of non-zero entries in <span class="math inline">\({\bf x}\)</span>.</p>
</div>
<p>Weights are closely related to Hamming distances. To show this, we must first define the difference between two vectors, using several properties of our vector space. Notice that by axioms vi and iii any field has a <span class="math inline">\(-1\)</span>, the additive inverse of 1. (For <span class="math inline">\(q\)</span> prime we could also write this as <span class="math inline">\(q -1\)</span>.) Then since we can multiply vectors by scalars, we can write <span class="math inline">\(-{\bf y}\)</span> for <span class="math inline">\(-1 \cdot {\bf y}\)</span>, and <span class="math inline">\({\bf x}-{\bf y}\)</span> for <span class="math inline">\({\bf x}+ (-{\bf y})\)</span>.</p>
<div class="lemma">
<p>For <span class="math inline">\({\bf x}\)</span> and <span class="math inline">\({\bf y}\)</span> in <span class="math inline">\({\mathbb F}_q^n\)</span>, we have <span class="math inline">\(d({\bf x},{\bf y}) = w({\bf x}-{\bf y})\)</span>.</p>
</div>
<div class="proof">
<p>The vector <span class="math inline">\({\bf x}- {\bf y}\)</span> has non-zero entries exactly where <span class="math inline">\({\bf x}\)</span> and <span class="math inline">\({\bf y}\)</span> differ.</p>
</div>
<p>So any Hamming distance can be written as a weight. But also, since <span class="math inline">\(w({\bf x})= w({\bf x}- {\bf 0}) = d({\bf x},{\bf 0})\)</span>, any weight can be written as a Hamming distance. This allows us to prove the following useful fact:</p>
<div id="prop:mindminw" class="proposition">
<p>For the code <span class="math inline">\(C \subseteq {\mathbb F}_q^n\)</span>, <span class="math inline">\(d(C)\)</span> is the minimum weight of any non-zero codeword in <span class="math inline">\(C\)</span>.</p>
</div>
<div class="proof">
<p>First we define two sets of non-negative integers: <span class="math display">\[W = \{ w({\bf x}) \;|\; {\bf x}\in C, {\bf x}\neq {\bf 0}\}\;\;{\rm and}
\;\; D = \{ d({\bf x},{\bf y}) \;|\; {\bf x},{\bf y}\in C, {\bf x}\neq {\bf y}\}.\]</span> Then the proposition says that min<span class="math inline">\((D) =\)</span> min<span class="math inline">\((W)\)</span>. We can show more: that <span class="math inline">\(D = W\)</span>. For any <span class="math inline">\(w({\bf x})\in W\)</span>, we know that both <span class="math inline">\({\bf x}\)</span> and <span class="math inline">\({\bf 0}\)</span> are in <span class="math inline">\(C\)</span>, so <span class="math inline">\(w({\bf x})= d({\bf x},{\bf 0}) \in D\)</span>. Conversely, for any <span class="math inline">\(d({\bf x},{\bf y}) \in D\)</span>, we know <span class="math inline">\({\bf x}\)</span> and <span class="math inline">\({\bf y}\)</span> are both in <span class="math inline">\(C\)</span>. Because <span class="math inline">\(C\)</span> is a subspace, <span class="math inline">\({\bf x}- {\bf y}\)</span> must also be in <span class="math inline">\(C\)</span>, so <span class="math inline">\(d({\bf x},{\bf y}) = w({\bf x}-{\bf y}) \in W\)</span>.</p>
</div>
<p>This proposition means that to find <span class="math inline">\(d(C)\)</span> for a linear code with <span class="math inline">\(q^k\)</span> words, we need to consider only <span class="math inline">\(q^k\)</span> weights , rather than <span class="math inline">\(\binom{q^k}{2} = \frac{q^k(q^k-1)}{2}\)</span> distances.</p>
<div class="exampleqed">
<p>For code <span class="math inline">\(C_3\)</span> listed in Section 2.2, we can see that <span class="math inline">\(d(C) = 2\)</span>, without finding <span class="math inline">\(\binom{9}{2} = 36\)</span> distances. But note that <span class="math inline">\(C_3\)</span> can also be written as <span class="math inline">\(\langle\{(1,1,1,1),(1,2,0,1)\}\rangle\)</span>; <span class="math inline">\(d(C)\)</span> is not always obvious from a basis.</p>
</div>
<p>For linear codes we have a much better way to talk about errors.</p>
<div class="definition">
<p>Suppose that a codeword <span class="math inline">\({\bf c}\in C \subseteq {\mathbb F}_q^n\)</span> is sent, and <span class="math inline">\({\bf y}\in {\mathbb F}_q^n\)</span> is received. Then the <span><strong>error-vector</strong></span> is <span class="math inline">\({\bf e}= {\bf y}- {\bf c}\)</span>.</p>
</div>
<p>We can think of the channel as adding <span class="math inline">\({\bf e}\)</span> to <span class="math inline">\({\bf c}\)</span>, and the decoding process aims to subtract it again. But of course the receiver does not know which error-vector was added, and can only choose a <span><em>likely</em></span> error-vector to subtract. Which error-vectors are likely? We know that <span class="math inline">\(d({\bf y},{\bf c}) =  w({\bf e})\)</span>; this is the number of symbol-errors which <span class="math inline">\({\bf c}\)</span> has suffered. This allows us to re-write Propositions <a href="#prop:receivedgivensentprobability" data-reference-type="ref" data-reference="prop:receivedgivensentprobability">[prop:receivedgivensentprobability]</a> and <a href="#prop:nearestneighbourslikely" data-reference-type="ref" data-reference="prop:nearestneighbourslikely">[prop:nearestneighbourslikely]</a> for linear codes.</p>
<div class="proposition">
<p>Let the code <span class="math inline">\(C\subseteq {\mathbb F}_q^n\)</span>, be sent over a <span class="math inline">\(q\)</span>-ary symmetric channel with symbol-error probability <span class="math inline">\(p\)</span>. For any <span class="math inline">\({\bf c}\in C\)</span>, <span class="math inline">\({\bf y}\in {\mathbb F}_q^n\)</span> , and <span class="math inline">\({\bf e}= {\bf y}-{\bf c}\)</span>, <span class="math display">\[P( {\bf y}\; {\rm received}\; |\; {\bf c}\; {\rm sent}) = P( {\bf e}\;{\rm added \; in \; channel})  = \left( \frac{p}{q-1}\right)^{w({\bf e})}  (1-p)^{n-w({\bf e})}.\]</span></p>
<p>If also <span class="math inline">\(p &lt; (q-1)/q\)</span>, and each codeword <span class="math inline">\(c \in C\)</span> is equally likely to be sent, then for any given <span class="math inline">\({\bf y}\)</span> <span class="math inline">\(P({\bf c}\;{\rm sent}\;|\;{\bf y}\;{\rm received})\)</span> increases as <span class="math inline">\(w({\bf e})\)</span> decreases.</p>
</div>
<p>The most likely error-vectors are those of least weight, or in other words those involving the fewest symbol-errors. So we should still use nearest-neighbour decoding: for a linear code, given a received word <span class="math inline">\({\bf y}\)</span> we must find a codeword <span class="math inline">\({\bf c}\)</span> such that <span class="math inline">\(w({\bf e}) = d({\bf y},{\bf c})\)</span> is as small as possible; as before this will be one of the most likely codewords to have been sent. We could do this by calculating <span class="math inline">\({\bf e}_i = {\bf y}-{\bf c}_i\)</span> for each <span class="math inline">\(c_i \in C\)</span>, and then comparing all the <span class="math inline">\(w({\bf e}_i)\)</span>. But it is much more efficient to make an array, as follows. (This is sometimes called a ‘Slepian’ or ‘Standard’ array.)</p>
<p><span><strong>Algorithm: Array Decoding</strong></span>Let <span class="math inline">\(C\)</span> be a code of dimension <span class="math inline">\(k\)</span> in <span class="math inline">\({\mathbb F}_q^n\)</span>. We construct an array as follows:</p>
<ol>
<li><p>Write the <span class="math inline">\(q^k\)</span> codewords as the top row, with <span class="math inline">\({\bf 0}\)</span> in the first column.</p></li>
<li><p>Consider the vectors of <span class="math inline">\({\mathbb F}_q^n\)</span> which are not yet in the array, and choose one of lowest available weight, <span class="math inline">\({\bf e}\)</span>.</p></li>
<li><p>Write <span class="math inline">\({\bf e}\)</span> into the first column, and then complete this new row by adding <span class="math inline">\({\bf e}\)</span> to each codeword in the top row.</p></li>
<li><p>If the array has <span class="math inline">\(q^{n-k}\)</span> rows, then STOP. Otherwise, go to 2.</p></li>
</ol>
<p>Now, decode any received word <span class="math inline">\({\bf y}\)</span> to the codeword at the top of its column.</p>
<div class="exampleqed">
<p>Let <span class="math inline">\(C\)</span> be the <span class="math inline">\([4, 2,2]\)</span> code <span class="math inline">\(\langle{(1,1,0,0),(0,0,1,1)}\rangle \subseteq {\mathbb F}_2^4\)</span>. Then one possible array is: <span class="math display">\[\begin{array}{c|ccc}
 (0,0,0,0) &amp; (1,1,0,0) &amp; (0,0,1,1) &amp; (1,1,1,1) \\ \hline
 (1,0,0,0) &amp; (0,1,0,0) &amp; (1,0,1,1) &amp; (0,1,1,1)  \\
 (0,0,1,0) &amp; (1,1,1,0) &amp; (0,0,0,1) &amp; (1,1,0,1)  \\
 (1,0,1,0) &amp; (0,1,1,0) &amp; (1,0,0,1) &amp; (0,1,0,1)  \\ 
\end{array}\]</span></p>
<p>This array decodes (0,0,0,1) to (0,0,1,1), and (0,1,1,0) to (1,1,0,0). In each case the word is decoded to a nearest neighbour, though this nearest neighbour is not unique.</p>
</div>
<p>For this method to be well defined, we require that every possible vector in <span class="math inline">\({\mathbb F}_q^n\)</span> appears exactly once in the array. (See Q22) We should also prove the following:</p>
<div id="prop:arraydecodingnearestneighbour" class="proposition">
<p> Array decoding is nearest-neighbour decoding.</p>
</div>
<div class="proof">
<p>Suppose that our received word <span class="math inline">\({\bf y}\)</span> is in the same row as <span class="math inline">\({\bf e}_1\)</span> in the first column, and in the same column as codeword <span class="math inline">\({\bf c}_1\)</span> in the top row. So we decode <span class="math inline">\({\bf y}\)</span> to <span class="math inline">\({\bf c}_1\)</span>; that is, we assume that error-vector <span class="math inline">\({\bf e}_1\)</span> was added in the channel, and now subtract it.</p>
<p><span class="math inline">\(\begin{array}{c|cccc}
{\bf 0} &amp;  &amp;  &amp; {\bf c}_1 &amp;  \\ \hline
   &amp;  &amp;  &amp;       &amp;   \\
 {\bf e}_1 &amp;   &amp;  &amp; {\bf y}&amp;  \\
    &amp;    &amp;   &amp;    &amp;   \\ 
\end{array}\)</span></p>
<p>We can show by contradiction that <span class="math inline">\({\bf c}_1\)</span> is a nearest neighbour of <span class="math inline">\({\bf y}\)</span>. Suppose not, that is, there is some <span class="math inline">\({\bf c}_2\)</span> such that <span class="math inline">\({\bf y}= {\bf c}_2 + {\bf e}_2\)</span>, with <span class="math inline">\(w({\bf e}_2) &lt; w({\bf e}_1)\)</span>. Then we have <span class="math inline">\({\bf c}_2 + {\bf e}_2 = {\bf y}={\bf c}_1 + {\bf e}_1\)</span>, so <span class="math inline">\({\bf e}_2 = {\bf e}_1 + ({\bf c}_1 -{\bf c}_2)\)</span>. Since <span class="math inline">\({\bf c}_1 -{\bf c}_2\)</span> must be a codeword in the top row, <span class="math inline">\({\bf e}_2\)</span> is in the same row as <span class="math inline">\({\bf e}_1\)</span>, so it is not in any row higher up. Thus when <span class="math inline">\({\bf e}_1\)</span> was picked by step 2. of the algorithm, <span class="math inline">\({\bf e}_2\)</span> was not yet in the array, it was available, so <span class="math inline">\({\bf e}_1\)</span> did not have least possible weight. Contradiction.</p>
</div>
<p>As we know, nearest-neighbour decoding does not always find the right codeword. If we use an array, what is the probability that, after transmission and array decoding, the receivers will have the correct word, the one that was sent? Effectively, decoding with an array subtracts one of the vectors <span class="math inline">\({\bf e}\)</span> in the first column from the received word <span class="math inline">\(y\)</span>. Thus decoding will be successful if and only if the channel added one of these vectors.</p>
<div class="proposition">
<p>Let <span class="math inline">\(C\)</span> be a code <span class="math inline">\(\subseteq {\mathbb F}_q^n\)</span>, sent over a <span class="math inline">\(q\)</span>-ary symmetric channel with symbol-error probability <span class="math inline">\(p\)</span>. Suppose the decoding array has <span class="math inline">\(\alpha_i\)</span> vectors of weight <span class="math inline">\(i\)</span> in its first column. Then for any codeword <span class="math inline">\(c\)</span> sent, the chance that it is successfully decoded is <span class="math display">\[\sum_{i = 0}^n\alpha_i\left( \frac{p}{q-1}\right)^i  (1-p)^{n-i}.\]</span></p>
</div>
<div class="exampleqed">
<p>For the array above, with <span class="math inline">\(q = 2\)</span>, we have <span class="math inline">\(\alpha_0 = 1,\;\alpha_1 = 2, \;\alpha_2 = 1, \;\alpha_3 = 0,\;\alpha_4 = 0\)</span>. So the chance of successful decoding is <span class="math inline">\((1-p)^4 +2 p(1-p)^3 + p^2((1-p)^2\)</span>.</p>
</div>
<div class="proof">
<p>The chance of successful decoding is the chance that one of the error-vectors in the first column occurred; since these are disjoint possibilities, we add their individual probabilities. (We include the zero error-vector - that is, the possibility that the codeword is received correctly.)</p>
</div>
<p>Steps 1 and 2 of the algorithm involve choice, so that many different arrays could be made for the same code. In general, some of these arrays would decode some received words differently. However, for a perfect code, all arrays will perform identical decoding. These ideas are explored in more detail in the homework (Q25-27).</p>
</section>
</section>

<script>
function doNumbering() {
	// The syntax to read the structured data from the yaml is horrible, template literals fix the problem but probably aren't widely supported enough. Escaping line breaks is browser dependant. I don't know if there's a better way?
	// Note that the data from the yaml file is manipulated into an array, and then parsed back into strings later, but I didn't want to deal with the pandoc templating syntax longer than necessary.
	var supportedEnvsArrayString = ' .definition;;; .theorem;;; .lemma;;; .proposition;;; .remark;;; .corollary;;; .exercise;;; .question';
	var supportedEnvsArray = supportedEnvsArrayString.split("|||");
	supportedEnvsArray = supportedEnvsArray.map(inner => inner.split(";;;"));
	var numberWithin = '1';
	var counterOffset = '0';
	var subcounterOffset = '';
	var problemCounter = '0';
	const partLabels = 'abcdefghijklmnopqrstuvwxyz'.split('');
	
	// counterOffset may be negative, and by default if specified on the command line this gets string concatenated with the default given in the yaml config and this then causes a problem. Can be fixed by removing the default in the config file and converting to an int, but this causes a NaN error if no value is suplied on the command line, so if NaN set to 0.
	counterOffset = parseInt(counterOffset);
	if (isNaN(counterOffset)) {
		counterOffset = 0;
	}
	
	subcounterOffset = parseInt(subcounterOffset);
	if (isNaN(subcounterOffset)) {
		subcounterOffset = 0;
	}
	
	problemCounter = parseInt(problemCounter);
	if (isNaN(problemCounter)) {
		problemCounter = 1;
	}
	
	function sanitiseSelector(selector) {
		// tex labels often have colons in which need escaping. There may be other escaping needed here. Unfortunately neither encodeURI nor encodeURIComponent do what I need, so use regex to do the escaping manually.
		var sanitised = selector.replace(/\:/g,"\\\:");
		sanitised = sanitised.replace(/(^[\d])/,"\\3$1 ");
		sanitised = sanitised.replace(/\//g,"\\\/");
		return sanitised
	}
	
	function labelLinks() {
		var refs = document.querySelectorAll("a[data-reference-type=ref]")
		for (ref of refs) {
			// Escape colons (or other) from the link title.
			var ref_label = sanitiseSelector(ref.getAttribute("data-reference"));
			// Hopefully ref is a reference to a div or a section, which should have the associated id. If so, we just need the data-number from the relevant DOM item.
			var ref_to = document.querySelector("#"+ref_label);
			if (ref_to !== null) {
				var ref_number = ref_to.getAttribute("data-number");
			} else {
				// If ref is being used for an equation, then we need to try to parse the mathjax divs. This is fragile, but try to find the span which corresponds to the equation number we need.
				try {
					var mathjax_ref = "#mjx-eqn-"+ref_label;
					ref_to = document.querySelector(mathjax_ref);
					// Since this is a ref, we don't want the parens to be returned, so find the equation number and strip the parens.
					var ref_number = ref_to.querySelector(".mjx-char").innerHTML.replace(/[()]/g,"");
					ref.setAttribute("href",mathjax_ref);
				}
				// If we can't find a place to link to, just indicate a missing link.
				catch (err){
					var ref_number = "???"
				}
			}
			ref.innerHTML = ref_number;
		};
	}
	
	function numberEnvs() {
		for (var levelSpec = 0; levelSpec <= numberWithin; levelSpec++) {
			var reqLevels = document.querySelectorAll(".level"+levelSpec);
			for (var level of reqLevels) {
				levelCount = level.getAttribute("data-number");
				levelCount = String(parseFloat(levelCount)+(counterOffset));
				levelCount = levelCount+(("."+subcounterOffset).repeat(numberWithin-levelSpec));
				for (var counter of supportedEnvsArray) {
					var envCount = 1;
					var envs = level.querySelectorAll(counter.join(", "));
					for (var env of envs) {
						env.setAttribute("data-number",levelCount+"."+envCount);
						envCount += 1;
					}
				}
			}
		}
		var allLevels = document.querySelectorAll('[class^="level"]');
		console.log(allLevels);
		for (var level of allLevels) {
			levelCount = level.getAttribute("data-number");
			levelCount = String(parseFloat(levelCount)+(counterOffset));
			level.setAttribute("data-number",levelCount);
		} 
	}
	
	function numberFigs() {
		// Figures should either be in a figure environment, or a table with image class imageTable thanks to the tableCaps filter.
		figs = document.querySelectorAll("figure, .imageTable");
		var fig_no = 1
		for (var fig of figs) {
			var cap
			// For figures, we want to move the id to the figure, and set the data-number on both the figure and the figcaption
			if (fig.nodeName == "FIGURE") {
				cap = fig.querySelector("figcaption");
				var img = fig.querySelector("img, embed")
				if (img) {
					var img_id = img.getAttribute("id");
					fig.setAttribute("id",img_id);
					img.removeAttribute("id");
				}
			// for tables (which must be .imageTable due to the querySelector above), we want to set the data-number on the table and the caption
			} else if (fig.nodeName == "TABLE") {
				cap = fig.querySelector("caption");
			}
			cap.setAttribute("data-number",fig_no);
			fig.setAttribute("data-number",fig_no);
			fig_no += 1;
		}
	}
	
	function numberGlobals() {
		// This function numbers any environments that just use a global counter, such as a problem number on a problems sheet, where there are no sections to number with respect to.
		probsols = document.querySelectorAll(".problem, .solution");
		var prob_no = problemCounter;
		var partNo = 0;
		for (var probsol of probsols) {
			if (probsol.className == "problem"){
				prob_no +=1;
				partNo = 0;
				probsol.setAttribute("data-number",prob_no);
			}
			else {
				if (probsol.parentNode.nodeName == "LI") {
					var partLabel = partLabels[partNo];
					probsol.setAttribute("data-number",prob_no.toString()+partLabel);
					partNo +=1;
				}
				else{
					probsol.setAttribute("data-number",prob_no);
				}
			}
			
		}
		// sols = document.querySelectorAll(".solution");
// 		var sol_no = problemCounter;
// 		for (var sol of sols) {
// 			sol.setAttribute("data-number",sol_no);
// 			sol_no +=1
// 		}
		egs = document.querySelectorAll(".example, .exampleqed");
		var eg_no = problemCounter;
		for (var eg of egs) {
			eg.setAttribute("data-number",eg_no);
			eg_no +=1
		}
	}
	
	// labelLinks() should occur last, so that the data-numbers have been correctly set first.
	numberEnvs();
	numberFigs();
	numberGlobals();
	labelLinks();
}
</script><script>
	var imageDir = ''
	imgs = document.querySelectorAll("img");
	for (var img of imgs) {
		imgsrc = img.getAttribute("src");
		img.setAttribute("src",imageDir.concat(imgsrc));
	}
</script></body>
</html>
