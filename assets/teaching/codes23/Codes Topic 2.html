<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Sam Fearn Department of Mathematical Sciences, Durham University The notes for this term were originally written by Dr. Sophy Darwin and are based on a previous course developed by Rob de Jeu, Sophy Darwin, Fredrik Strömberg, and Emilie Dufresne Please send questions, comments or corrections to s.m.fearn@durham.ac.uk" />
  <title>MATH3401 Error-correcting Codes Epiphany term 2022/23</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
  </style>
  <link rel="stylesheet" href="https://samfearn.github.io/latex.min.css" />
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML" type="text/javascript"></script>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
  <script type="text/x-mathjax-config">
  	MathJax.Hub.Config({ TeX: { equationNumbers: {autoNumber: "ams"} } });
  	// I need to wait until MathJax has finished before running the numbering script
  	MathJax.Hub.Register.StartupHook("End",function(){doNumbering()});
  </script>
</head>
<body>
<header id="title-block-header">
<h1 class="title"><span>MATH3401</span><br />
<span>Error-correcting Codes</span><br />
<span>Epiphany term 2022/23</span></h1>
<p class="author">Sam Fearn<br />
<span>Department of Mathematical Sciences, Durham University</span><br />
<span>The notes for this term were originally written by Dr. Sophy Darwin</span><br />
<span>and are based on a previous course developed by</span><br />
Rob de Jeu, Sophy Darwin, Fredrik Strömberg, and Emilie Dufresne<br />
<span>Please send questions, comments or corrections to</span><br />
<code>s.m.fearn@durham.ac.uk</code></p>
</header>
<nav id="TOC" role="doc-toc">
<ul>
<li><a href="#cha:linearcodes"><span class="toc-section-number">2</span> Linear Codes</a>
<ul>
<li><a href="#sec:finitefields"><span class="toc-section-number">2.1</span> Finite Fields</a></li>
<li><a href="#finite-vector-spaces"><span class="toc-section-number">2.2</span> Finite Vector Spaces</a></li>
<li><a href="#array-decoding"><span class="toc-section-number">2.3</span> Array Decoding</a></li>
</ul></li>
</ul>
</nav>
<section id="cha:linearcodes" class="level1" data-number="1">
<h1 data-number="2"><span class="header-section-number">2</span> Linear Codes</h1>
<p>In Chapter 1, we used <span class="math inline">\(0, 1, 2, \ldots\)</span> purely as symbols in an alphabet <span class="math inline">\(A\)</span>, and our code could be any subset of <span class="math inline">\(A^n\)</span>. To make progress we now want to do arithmetic with our symbols, so our alphabet must be a field <span class="math inline">\(F\)</span>. Then we can regard our words in <span class="math inline">\(A^n\)</span> as vectors in <span class="math inline">\(F^n\)</span>, which is a vector space over <span class="math inline">\(F\)</span>. Moreover, we shall require that our code <span class="math inline">\(C\)</span> is a subspace of <span class="math inline">\(F^n\)</span>.</p>
<section id="sec:finitefields" class="level2" data-number="1.1">
<h2 data-number="2.1"><span class="header-section-number">2.1</span> Finite Fields</h2>
<p>A field is a set with two binary operations, which obey the standard rules of arithmetic.</p>
<div class="definition">
<p>A non-empty set <span class="math inline">\(F\)</span> with addition <span class="math inline">\(F \times F \rightarrow F\)</span>, mapping <span class="math inline">\((a,b)\)</span> to <span class="math inline">\(a+b\)</span>, and multiplication <span class="math inline">\(F \times F \rightarrow F\)</span>, mapping <span class="math inline">\((a,b)\)</span> to <span class="math inline">\(ab\)</span>, is called a <span><strong>field</strong></span> if the following axioms hold.</p>
<ul>
<li><p>Associativity of addition: For every <span class="math inline">\(a\)</span>, <span class="math inline">\(b\)</span>, and <span class="math inline">\(c\)</span> in <span class="math inline">\(F\)</span>, <span class="math inline">\((a+b)+c = a+(b+c)\)</span></p></li>
<li><p>Additive identity: There exists 0 in <span class="math inline">\(F\)</span> such that for every <span class="math inline">\(a \in F\)</span>, <span class="math inline">\(a+0 = a = 0+a\)</span></p></li>
<li><p>Additive inverse: For every <span class="math inline">\(a \in F\)</span>, there exists <span class="math inline">\(b \in F\)</span> such that <span class="math inline">\(a+b = 0 = b+a\)</span></p></li>
<li><p>Commutative addition: For every <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span> in <span class="math inline">\(F\)</span>, <span class="math inline">\(a+b = b+a\)</span></p></li>
<li><p>Associativity of multiplication: For every <span class="math inline">\(a\)</span>, <span class="math inline">\(b\)</span>, and <span class="math inline">\(c\)</span> in <span class="math inline">\(F\)</span>, <span class="math inline">\((a\cdot b)\cdot c = a\cdot (b\cdot c)\)</span></p></li>
<li><p>Multiplicative identity: There exists 1 in <span class="math inline">\(F\)</span> such that, for every <span class="math inline">\(a \in F\)</span>, <span class="math inline">\(1\cdot a = a = a \cdot 1\)</span></p></li>
<li><p>Multiplicative inverse: For every <span class="math inline">\(a \in F\)</span>, <span class="math inline">\(a \neq 0\)</span>, there exists <span class="math inline">\(b \in F\)</span> such that <span class="math inline">\(a\cdot b = 1 = b \cdot a\)</span></p></li>
<li><p>Commutative multiplication: For every <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span> in <span class="math inline">\(F\)</span>, <span class="math inline">\(a \cdot b =b \cdot a\)</span></p></li>
<li><p>Distributivity: For every <span class="math inline">\(a\)</span>, <span class="math inline">\(b\)</span>, and <span class="math inline">\(c\)</span> in <span class="math inline">\(F\)</span>, <span class="math inline">\((a+b)\cdot c = a\cdot c + b\cdot c\)</span> and <span class="math inline">\(a\cdot (b+c) = a\cdot b + a\cdot c\)</span></p></li>
<li><p>Multiplicative and additive inverses are different: <span class="math inline">\(0 \neq 1\)</span></p></li>
</ul>
</div>
<p>Axioms i - iv make <span class="math inline">\((F, +)\)</span> into an abelian (or commutative) group; axioms v - viii make <span class="math inline">\((F-\{0\}, \cdot)\)</span> into another abelian group; axioms i - vi &amp; ix make <span class="math inline">\((F,+,\cdot)\)</span> a ring. Note that the definitions of addition and multiplication as maps <span class="math inline">\(F \times F \rightarrow F\)</span> imply that these operations are closed. It is easy to show that the identities 0 and 1 are unique, and that for each <span class="math inline">\(a \in F\)</span>, the additive inverse <span class="math inline">\(-a\)</span> and the multiplicative inverse <span class="math inline">\(a^{-1}\)</span> are unique. We also have some convenient notations: for <span class="math inline">\(m\)</span> a non-negative integer, we write <span class="math inline">\(m\cdot a\)</span> for adding, and <span class="math inline">\(a^m\)</span> for multiplying, <span class="math inline">\(m\)</span> copies of <span class="math inline">\(a\)</span>. It’s all very familiar.</p>
<p>However, the fields you know best are the reals <span class="math inline">\({\mathbb R}\)</span>, the complex numbers <span class="math inline">\({\mathbb C}\)</span>, and the rationals <span class="math inline">\({\mathbb Q}\)</span>, and these are no good as alphabets, because they are infinite.</p>
<p>To find finite fields, we start from arithmetic modulo <span class="math inline">\(n\)</span>. Here the set <span class="math inline">\({\mathbb Z}/n\)</span> (or <span class="math inline">\({\mathbb Z}_n\)</span>, or <span class="math inline">\({\mathbb Z}/n{\mathbb Z}\)</span>) is the congruence classes <span class="math inline">\(\{[0]_n, [1]_n,\ldots,[n-1]_n\}\)</span> (or <span class="math inline">\(\{\overline{0}, \overline{1},\ldots,\overline{n-1}\}\)</span>), and we add or multiply by using any representative of that class. It is easy to check that every axiom except for vii will hold for any <span class="math inline">\(n\)</span>. But vii holds (that is, <span class="math inline">\({\mathbb Z}/n\)</span> has multiplicative inverses for all non-zero elements) if and only if <span class="math inline">\(n\)</span> is prime.</p>
<p>For <span class="math inline">\(n\)</span> prime we have a field, and to make this clear (and also to be able to use <span class="math inline">\(n\)</span> for block-length, as in Chapter 1) we shall write <span class="math inline">\({\mathbb F}_p\)</span> instead of <span class="math inline">\({\mathbb Z}/n\)</span>. Once we have specified <span class="math inline">\(p\)</span>, we can write simply <span class="math inline">\(0, 1, 2,\ldots p-1\)</span> rather than <span class="math inline">\([0]_p, [1]_p,\ldots,[p-1]_p\)</span> (or <span class="math inline">\(\overline{0}, \overline{1},\ldots,\overline{p-1}\)</span>).</p>
<p>Are there finite fields with a non-prime number <span class="math inline">\(q\)</span> of elements? The answer is yes if and only if <span class="math inline">\(q\)</span> is a prime power, <span class="math inline">\(q = p^r, r \in {\mathbb Z}_+\)</span>. But of course <span class="math inline">\({\mathbb F}_{3^2} = {\mathbb F}_9 \neq {\mathbb Z}/9\)</span>, because <span class="math inline">\({\mathbb Z}/9\)</span> is not a field. We shall construct and use such non-prime fields <span class="math inline">\({\mathbb F}_q\)</span> in Chapter 6.</p>
<p>The notation <span class="math inline">\({\mathbb F}_q\)</span> is justified, because it can be shown that any two fields with the same number of elements are isomorphic. For general statements we shall call our field <span class="math inline">\({\mathbb F}_q\)</span>, but <span><em>until we reach Chapter 6 <span class="math inline">\(q\)</span> will always be prime</em></span> (that is, <span class="math inline">\(r = 1\)</span>). This allows us to keep ‘<span class="math inline">\(p\)</span>’ for the symbol-error probability.</p>
</section>
<section id="finite-vector-spaces" class="level2" data-number="1.2">
<h2 data-number="2.2"><span class="header-section-number">2.2</span> Finite Vector Spaces</h2>
<p>Just as <span class="math inline">\({\mathbb R}^n\)</span> is a vector space over <span class="math inline">\({\mathbb R}\)</span>, <span class="math inline">\({\mathbb F}_q^n =({\mathbb F}_q)^n\)</span> is a vector space over <span class="math inline">\({\mathbb F}_q\)</span>. Everything you have learned about vector spaces (and most of your ideas about <span class="math inline">\({\mathbb R}^n\)</span>) will still work. These notes gives only a quick, informal reminder of the main definitions and ideas from linear algebra which we shall use. Formal definitions, results and examples will be written in terms of finite fields, and spaces and codes over them. The main difference is that we can now count the vectors in a space: to start with, <span class="math inline">\(|{\mathbb F}_q^n|= q^n\)</span>. We can even write a complete list of them.</p>
<p>We shall still sometimes call our vectors ‘words’, and some of them will be our codewords. Because words (in English) are horizontal, we will usually write vectors as rows (rather than columns): <span class="math inline">\({\bf x} = (x_1, x_2, \ldots,x_n) \in {\mathbb F}_q^n\)</span>, where the <span class="math inline">\(x_i\)</span> are in <span class="math inline">\({\mathbb F}_q\)</span>. You need to know which field <span class="math inline">\({\mathbb F}_q\)</span> you are working over, because all arithmetic must be done mod <span class="math inline">\(q\)</span>.</p>
<div class="exampleqed">
<p>The vectors <span class="math inline">\({\bf x} = (0,1,2,0)\)</span> and <span class="math inline">\({\bf y} = (1,1,1,1)\)</span> could be vectors in <span class="math inline">\({\mathbb F}_3^4\)</span>, but they could also be vectors in <span class="math inline">\({\mathbb F}_7^4\)</span>. In <span class="math inline">\({\mathbb F}_3^4\)</span>, we would have <span class="math inline">\({\bf x} + {\bf y} = (1, 2, 0, 1)\)</span>, and <span class="math inline">\(2{\bf x} = (0,2,1,0)\)</span>. But in <span class="math inline">\({\mathbb F}_7^4\)</span>, it would be <span class="math inline">\({\bf x} + {\bf y} = (1, 2, 3, 1)\)</span>, <span class="math inline">\(2{\bf x} = (0,2,4,0)\)</span> and <span class="math inline">\(4{\bf x} = (0,4,1,0)\)</span>.</p>
</div>
<p>In Chapter 1, a code could be any subset of <span class="math inline">\(A^n\)</span>. But we now make a more restrictive definition.</p>
<div class="definition">
<p>A <span><strong>linear code</strong></span> is a subspace of the vector space <span class="math inline">\({\mathbb F}_q^n\)</span>, for some finite field <span class="math inline">\({\mathbb F}_q\)</span> and non-negative integer <span class="math inline">\(n\)</span>.</p>
</div>
<p>Recall that a <span><strong>subspace</strong></span> of a vector space is a subset which is closed under vector addition and scalar multiplication. Thus, if we are given a subset of <span class="math inline">\({\mathbb F}_q^n\)</span> as a list, it is straightforward (if tedious) to check whether it is a linear code or not.</p>
<div class="exampleqed">
<p>Let <span class="math inline">\({\bf x} = (0,1,2,0)\)</span>, and <span class="math inline">\({\bf y} = (1,1,1,1,)\)</span>, <span class="math inline">\({\bf z} = (0,2,1,0)\)</span> and <span class="math inline">\({\bf 0} = (0,0,0,0)\)</span> be vectors in <span class="math inline">\({\mathbb F}_3^4\)</span>. Then <span class="math inline">\(C_1 = \{{\bf x},{\bf y}\}\)</span> is not a linear code since <span class="math inline">\({\bf x}+{\bf y} = (1,2,0,1)\not\in C_1\)</span>. But <span class="math inline">\(C_2 = \{{\bf x},{\bf z},{\bf 0}\}\)</span> is a linear code, as adding any combination of these vectors (which also includes multiplying them by 0, 1 or 2) gives one of them.</p>
</div>
<p>If the subset S is not closed, we can keep adding in vectors as necessary until it is. The resulting space is the <span><strong>span</strong></span> of the set, written <span class="math inline">\(\langle S \rangle\)</span>, and is by construction a linear code.</p>
<div class="exampleqed">
<p>The span of <span class="math inline">\(C_1\)</span> is the linear code <span class="math inline">\(C_3 =\langle C_1 \rangle 
= \langle\{{\bf x},{\bf y}\}\rangle =\)</span> <span class="math display">\[\{(0,0,0,0), (0,1,2,0),  (0,2,1,0),
  (1,1,1,1),  (1,2,0,1), (1,0,2,1), 
  (2,2,2,2),  (2,0,1,2), (2,1,0,2) \}.\]</span></p>
<p>We could also notice that <span class="math inline">\(C_2 = \{0{\bf x},1{\bf x},2{\bf x}\} = \langle\{{\bf x}\}\rangle\)</span>, so in fact <span class="math inline">\(\langle C_2 \rangle = C_2\)</span>.</p>
</div>
<p>If <span class="math inline">\(\langle S \rangle = C\)</span> then we say <span class="math inline">\(S\)</span> is a <span><strong>spanning set</strong></span> for <span class="math inline">\(C\)</span>. There are usually many possible spanning set for a subspace.</p>
<p>A set of vectors <span class="math inline">\(S = \{ {\bf x_1}, {\bf x_2}, \ldots {\bf x_k}\}\)</span> in <span class="math inline">\({\mathbb F}_q^n\)</span> is <span><strong>linearly independent</strong></span> if and only if no non-trivial linear combination of them equals the zero-vector <span class="math inline">\({\bf 0}\)</span>; that is, for <span class="math inline">\(\lambda_i \in {\mathbb F}_q\)</span>, iff:</p>
<p><span class="math display">\[\lambda_1{\bf x_1} +\lambda_2{\bf x_2} + \ldots +\lambda_k{\bf x_k} = {\bf 0} \;\; \Longrightarrow \;\; \lambda_1 =
\lambda_2 = \ldots =\lambda_k = 0.\]</span></p>
<p>A linearly independent spanning set for a linear code <span class="math inline">\(C\)</span> is a <span><strong>basis</strong></span> for <span class="math inline">\(C\)</span>. While there may still be many possible bases, these will all have the same number of vectors, and this number is the <span><strong>dimension</strong></span> of <span class="math inline">\(C\)</span>, written dim(<span class="math inline">\(C\)</span>).</p>
<div class="exampleqed">
<p>The spanning sets of the code listed above, <span class="math inline">\(C_3 \subseteq {\mathbb F}_3^4\)</span>, include <span class="math inline">\(S_1 =\{(0,1,2,0),(1,1,1,1)\}\)</span>, <span class="math inline">\(S_2 =\{(0,1,2,0),(2,2,2,2)\}\)</span>, and <span class="math inline">\(S_3 =\{(0,1,2,0),(1,1,1,1),(2,0,1,2)\}\)</span>.</p>
<p><span class="math inline">\(S_3\)</span> is not a basis, because <span class="math inline">\(1(0,1,2,0)+ 2(1,1,1,1)+ 2(2,0,1,2) = (6,3,6,6)=(0,0,0,0)\)</span>. But both <span class="math inline">\(S_1\)</span> and <span class="math inline">\(S_2\)</span> are linearly independent sets, and thus bases for <span class="math inline">\(C_3\)</span>. So dim<span class="math inline">\((C_3) =2\)</span>.</p>
<p>To prove the linear independence of <span class="math inline">\(S_1\)</span>, we can note that if <span class="math inline">\(\lambda_1(0,1,2,0)+ \lambda_2(1,1,1,1) = (0,0,0,0)\)</span>, then by the first position <span class="math inline">\(\lambda_2 = 0\)</span>, and so then by the second position <span class="math inline">\(\lambda_1 = 0\)</span> also.</p>
</div>
<div class="exampleqed">
<p>For the whole space <span class="math inline">\({\mathbb F}_q^n\)</span>, the ‘standard basis’ is <span class="math inline">\(B = \{ {\bf e_1}, {\bf e_2}, \ldots {\bf e_k}\}\)</span>, where <span class="math inline">\(e_i\)</span> has 1 in the <span class="math inline">\(i^{th}\)</span> position and 0 elsewhere.</p>
</div>
<p>A basis <span class="math inline">\(B\)</span> for a linear code <span class="math inline">\(C\)</span> is “just right" for making every vector <span class="math inline">\({\bf c} \in C\)</span> as a linear combination of vectors from <span class="math inline">\(B\)</span>: a spanning set can make each <span class="math inline">\({\bf c}\)</span> <span><em>at least</em></span> one way, a linearly independent set can make each <span class="math inline">\({\bf c}\)</span> <span><em>at most</em></span> one way, but a basis can make each <span class="math inline">\({\bf c}\)</span> <span><em>exactly</em></span> one way. We use this property to prove the following:</p>
<div id="prop:dimlincode" class="proposition">
<p> If a linear code <span class="math inline">\(C \subseteq {\mathbb F}_q^n\)</span> has dimension <span class="math inline">\(k\)</span>, then <span class="math inline">\(|C| = q^k\)</span>.</p>
</div>
<div class="proof">
<p>Let <span class="math inline">\(B = \{ {\bf x_1}, {\bf x_2}, \ldots {\bf x_k}\}\)</span> be any basis for <span class="math inline">\(C\)</span>. There is a one-to-one correspondence between codewords <span class="math inline">\({\bf c} \in C\)</span> and linear combinations <span class="math inline">\(\lambda_1{\bf x_1} +\lambda_2{\bf x_2} + \ldots +\lambda_k{\bf x_k}\)</span>, with <span class="math inline">\(\lambda_i \in {\mathbb F}_q\)</span>. Each <span class="math inline">\(\lambda_i\)</span> can take any of <span class="math inline">\(q\)</span> values.</p>
</div>
<div class="exampleqed">
<p>For <span class="math inline">\(C_3 \subseteq {\mathbb F}_3^4\)</span> listed above, dim<span class="math inline">\((C_3)=2\)</span>, and <span class="math inline">\(|C_3| = 9 = 3^2\)</span>.</p>
</div>
<p>We can now update our <span class="math inline">\((n, M, d)\)</span> notation for the parameters of a code:</p>
<div class="definition">
<p>A <span class="math inline">\(q\)</span>-ary <span class="math inline">\([n,k,d]\)</span> code is a linear code, a subspace of <span class="math inline">\({\mathbb F}_q^n\)</span> of dimension <span class="math inline">\(k\)</span> with minimum distance <span class="math inline">\(d\)</span>.</p>
</div>
<p>The square or round brackets prevent ambiguity: any <span class="math inline">\(q\)</span>-ary <span class="math inline">\([n, k, d]\)</span> code is also a <span class="math inline">\(q\)</span>-ary <span class="math inline">\((n, q^k,d)\)</span> code, but not vice-versa. From now on, almost all codes will be linear, so I will write “code" for “linear code"</p>
</section>
<section id="array-decoding" class="level2" data-number="1.3">
<h2 data-number="2.3"><span class="header-section-number">2.3</span> Array Decoding</h2>
<p>The zero element 0 plays a very special role in <span class="math inline">\({\mathbb F}_q\)</span>, and so does the zero vector <span class="math inline">\({\bf 0}\)</span> in <span class="math inline">\({\mathbb F}_q^n\)</span>. We are also interested in how many entries of a general vector <span class="math inline">\({\bf x} \in {\mathbb F}_q^n\)</span> are (or are not) zero.</p>
<div class="definition">
<p>For <span class="math inline">\({\bf x} \in {\mathbb F}_q^n\)</span>, the <span><strong>weight</strong></span> of <span class="math inline">\({\bf x}\)</span>, written <span class="math inline">\(w({\bf x})\)</span>, is the number of non-zero entries in <span class="math inline">\({\bf x}\)</span>.</p>
</div>
<p>Weights are closely related to Hamming distances. To show this, we must first define the difference between two vectors, using several properties of our vector space. Notice that by axioms vi and iii any field has a <span class="math inline">\(-1\)</span>, the additive inverse of 1. (For <span class="math inline">\(q\)</span> prime we could also write this as <span class="math inline">\(q -1\)</span>.) Then since we can multiply vectors by scalars, we can write <span class="math inline">\(-{\bf y}\)</span> for <span class="math inline">\(-1 \cdot {\bf y}\)</span>, and <span class="math inline">\({\bf x}-{\bf y}\)</span> for <span class="math inline">\({\bf x}+ (-{\bf y})\)</span>.</p>
<div class="lemma">
<p>For <span class="math inline">\({\bf x}\)</span> and <span class="math inline">\({\bf y}\)</span> in <span class="math inline">\({\mathbb F}_q^n\)</span>, we have <span class="math inline">\(d({\bf x},{\bf y}) = w({\bf x}-{\bf y})\)</span>.</p>
</div>
<div class="proof">
<p>The vector <span class="math inline">\({\bf x}- {\bf y}\)</span> has non-zero entries exactly where <span class="math inline">\({\bf x}\)</span> and <span class="math inline">\({\bf y}\)</span> differ.</p>
</div>
<p>So any Hamming distance can be written as a weight. But also, since <span class="math inline">\(w({\bf x})= w({\bf x}- {\bf 0}) = d({\bf x},{\bf 0})\)</span>, any weight can be written as a Hamming distance. This allows us to prove the following useful fact:</p>
<div class="proposition">
<p>For the code <span class="math inline">\(C \subseteq {\mathbb F}_q^n\)</span>, <span class="math inline">\(d(C)\)</span> is the minimum weight of any non-zero codeword in <span class="math inline">\(C\)</span>.</p>
</div>
<div class="proof">
<p>First we define two sets of non-negative integers: <span class="math display">\[W = \{ w({\bf x}) \;|\; {\bf x}\in C, {\bf x}\neq {\bf 0}\}\;\;{\rm and}
\;\; D = \{ d({\bf x},{\bf y}) \;|\; {\bf x},{\bf y}\in C, {\bf x}\neq {\bf y}\}.\]</span> Then the proposition says that min<span class="math inline">\((D) =\)</span> min<span class="math inline">\((W)\)</span>. We can show more: that <span class="math inline">\(D = W\)</span>. For any <span class="math inline">\(w({\bf x})\in W\)</span>, we know that both <span class="math inline">\({\bf x}\)</span> and <span class="math inline">\({\bf 0}\)</span> are in <span class="math inline">\(C\)</span>, so <span class="math inline">\(w({\bf x})= d({\bf x},{\bf 0}) \in D\)</span>. Conversely, for any <span class="math inline">\(d({\bf x},{\bf y}) \in D\)</span>, we know <span class="math inline">\({\bf x}\)</span> and <span class="math inline">\({\bf y}\)</span> are both in <span class="math inline">\(C\)</span>. Because <span class="math inline">\(C\)</span> is a subspace, <span class="math inline">\({\bf x}- {\bf y}\)</span> must also be in <span class="math inline">\(C\)</span>, so <span class="math inline">\(d({\bf x},{\bf y}) = w({\bf x}-{\bf y}) \in W\)</span>.</p>
</div>
<p>This proposition means that to find <span class="math inline">\(d(C)\)</span> for a linear code with <span class="math inline">\(q^k\)</span> words, we need to consider only <span class="math inline">\(q^k\)</span> weights , rather than <span class="math inline">\(\binom{q^k}{2} = \frac{q^k(q^k-1)}{2}\)</span> distances.</p>
<div class="exampleqed">
<p>For code <span class="math inline">\(C_3\)</span> listed in Section 2.2, we can see that <span class="math inline">\(d(C) = 2\)</span>, without finding <span class="math inline">\(\binom{9}{2} = 36\)</span> distances. But note that <span class="math inline">\(C_3\)</span> can also be written as <span class="math inline">\(\langle\{(1,1,1,1),(1,2,0,1)\}\rangle\)</span>; <span class="math inline">\(d(C)\)</span> is not always obvious from a basis.</p>
</div>
<p>For linear codes we have a much better way to talk about errors.</p>
<div class="definition">
<p>Suppose that a codeword <span class="math inline">\({\bf c}\in C \subseteq {\mathbb F}_q^n\)</span> is sent, and <span class="math inline">\({\bf y}\in {\mathbb F}_q^n\)</span> is received. Then the <span><strong>error-vector</strong></span> is <span class="math inline">\({\bf e}= {\bf y}- {\bf c}\)</span>.</p>
</div>
<p>We can think of the channel as adding <span class="math inline">\({\bf e}\)</span> to <span class="math inline">\({\bf c}\)</span>, and the decoding process aims to subtract it again. But of course the receiver does not know which error-vector was added, and can only choose a <span><em>likely</em></span> error-vector to subtract. Which error-vectors are likely? We know that <span class="math inline">\(d({\bf y},{\bf c}) =  w({\bf e})\)</span>; this is the number of symbol-errors which <span class="math inline">\({\bf c}\)</span> has suffered. This allows us to re-write Propositions <a href="#prop:receivedgivensentprobability" data-reference-type="ref" data-reference="prop:receivedgivensentprobability">[prop:receivedgivensentprobability]</a> and <a href="#prop:nearestneighbourslikely" data-reference-type="ref" data-reference="prop:nearestneighbourslikely">[prop:nearestneighbourslikely]</a> for linear codes.</p>
<div class="proposition">
<p>Let the code <span class="math inline">\(C\subseteq {\mathbb F}_q^n\)</span>, be sent over a <span class="math inline">\(q\)</span>-ary symmetric channel with symbol-error probability <span class="math inline">\(p\)</span>. For any <span class="math inline">\({\bf c}\in C\)</span>, <span class="math inline">\({\bf y}\in {\mathbb F}_q^n\)</span> , and <span class="math inline">\({\bf e}= {\bf y}-{\bf c}\)</span>, <span class="math display">\[P( {\bf y}\; {\rm received}\; |\; {\bf c}\; {\rm sent}) = P( {\bf e}\;{\rm added \; in \; channel})  = \left( \frac{p}{q-1}\right)^{w({\bf e})}  (1-p)^{n-w({\bf e})}.\]</span></p>
<p>If also <span class="math inline">\(p &lt; (q-1)/q\)</span>, and each codeword <span class="math inline">\(c \in C\)</span> is equally likely to be sent, then for any given <span class="math inline">\({\bf y}\)</span> <span class="math inline">\(P({\bf c}\;{\rm sent}\;|\;{\bf y}\;{\rm received})\)</span> increases as <span class="math inline">\(w({\bf e})\)</span> decreases.</p>
</div>
<p>The most likely error-vectors are those of least weight, or in other words those involving the fewest symbol-errors. So we should still use nearest-neighbour decoding: for a linear code, given a received word <span class="math inline">\({\bf y}\)</span> we must find a codeword <span class="math inline">\({\bf c}\)</span> such that <span class="math inline">\(w({\bf e}) = d({\bf y},{\bf c})\)</span> is as small as possible; as before this will be one of the most likely codewords to have been sent. We could do this by calculating <span class="math inline">\({\bf e}_i = {\bf y}-{\bf c}_i\)</span> for each <span class="math inline">\(c_i \in C\)</span>, and then comparing all the <span class="math inline">\(w({\bf e}_i)\)</span>. But it is much more efficient to make an array, as follows. (This is sometimes called a ‘Slepian’ or ‘Standard’ array.)</p>
<p><span><strong>Algorithm: Array Decoding</strong></span>Let <span class="math inline">\(C\)</span> be a code of dimension <span class="math inline">\(k\)</span> in <span class="math inline">\({\mathbb F}_q^n\)</span>. We construct an array as follows:</p>
<ol>
<li><p>Write the <span class="math inline">\(q^k\)</span> codewords as the top row, with <span class="math inline">\({\bf 0}\)</span> in the first column.</p></li>
<li><p>Consider the vectors of <span class="math inline">\({\mathbb F}_q^n\)</span> which are not yet in the array, and choose one of lowest available weight, <span class="math inline">\({\bf e}\)</span>.</p></li>
<li><p>Write <span class="math inline">\({\bf e}\)</span> into the first column, and then complete this new row by adding <span class="math inline">\({\bf e}\)</span> to each codeword in the top row.</p></li>
<li><p>If the array has <span class="math inline">\(q^{n-k}\)</span> rows, then STOP. Otherwise, go to 2.</p></li>
</ol>
<p>Now, decode any received word <span class="math inline">\({\bf y}\)</span> to the codeword at the top of its column.</p>
<div class="exampleqed">
<p>Let <span class="math inline">\(C\)</span> be the <span class="math inline">\([4, 2,2]\)</span> code <span class="math inline">\(\langle{(1,1,0,0),(0,0,1,1)}\rangle \subseteq {\mathbb F}_2^4\)</span>. Then one possible array is: <span class="math display">\[\begin{array}{c|ccc}
 (0,0,0,0) &amp; (1,1,0,0) &amp; (0,0,1,1)&amp; (1,1,1,1) \\ \hline
 (1,0,0,0) &amp; (0,1,0,0) &amp; (1,0,1,1) &amp; (0,1,1,1)  \\
 (0,0,1,0) &amp; (1,1,1,0) &amp; (0,0,0,1) &amp; (1,1,0,1)  \\
 (1,0,1,0) &amp; (0,1,1,0) &amp; (1,0,0,1) &amp; (0,1,0,1)  \\ 
\end{array}\]</span></p>
<p>This array decodes (0,0,0,1) to (0,0,1,1), and (0,1,1,0) to (1,1,0,0). In each case the word is decoded to a nearest neighbour, though this nearest neighbour is not unique.</p>
</div>
<p>For this method to be well defined, we require that every possible vector in <span class="math inline">\({\mathbb F}_q^n\)</span> appears exactly once in the array. (See Q22) We should also prove the following:</p>
<div class="proposition">
<p>Array decoding is nearest-neighbour decoding.</p>
</div>
<div class="proof">
<p>Suppose that our received word <span class="math inline">\({\bf y}\)</span> is in the same row as <span class="math inline">\({\bf e}_1\)</span> in the first column, and in the same column as codeword <span class="math inline">\({\bf c}_1\)</span> in the top row. So we decode <span class="math inline">\({\bf y}\)</span> to <span class="math inline">\({\bf c}_1\)</span>; that is, we assume that error-vector <span class="math inline">\({\bf e}_1\)</span> was added in the channel, and now subtract it.</p>
<p><span class="math inline">\(\begin{array}{c|cccc}
{\bf 0} &amp;  &amp;  &amp; {\bf c}_1 &amp;  \\ \hline
   &amp;  &amp;  &amp;       &amp;   \\
 {\bf e}_1 &amp;   &amp;  &amp; {\bf y}&amp;  \\
    &amp;    &amp;   &amp;    &amp;   \\ 
\end{array}\)</span></p>
<p>We can show by contradiction that <span class="math inline">\({\bf c}_1\)</span> is a nearest neighbour of <span class="math inline">\({\bf y}\)</span>. Suppose not, that is, there is some <span class="math inline">\({\bf c}_2\)</span> such that <span class="math inline">\({\bf y}= {\bf c}_2 + {\bf e}_2\)</span>, with <span class="math inline">\(w({\bf e}_2) &lt; w({\bf e}_1)\)</span>. Then we have <span class="math inline">\({\bf c}_2 + {\bf e}_2 = {\bf y}={\bf c}_1 + {\bf e}_1\)</span>, so <span class="math inline">\({\bf e}_2 = {\bf e}_1 + ({\bf c}_1 -{\bf c}_2)\)</span>. Since <span class="math inline">\({\bf c}_1 -{\bf c}_2\)</span> must be a codeword in the top row, <span class="math inline">\({\bf e}_2\)</span> is in the same row as <span class="math inline">\({\bf e}_1\)</span>, so it is not in any row higher up. Thus when <span class="math inline">\({\bf e}_1\)</span> was picked by step 2. of the algorithm, <span class="math inline">\({\bf e}_2\)</span> was not yet in the array, it was available, so <span class="math inline">\({\bf e}_1\)</span> did not have least possible weight. Contradiction.</p>
</div>
<p>As we know, nearest-neighbour decoding does not always find the right codeword. If we use an array, what is the probability that, after transmission and array decoding, the receivers will have the correct word, the one that was sent? Effectively, decoding with an array subtracts one of the vectors <span class="math inline">\({\bf e}\)</span> in the first column from the received word <span class="math inline">\(y\)</span>. Thus decoding will be successful if and only if the channel added one of these vectors.</p>
<div class="proposition">
<p>Let <span class="math inline">\(C\)</span> be a code <span class="math inline">\(\subseteq {\mathbb F}_q^n\)</span>, sent over a <span class="math inline">\(q\)</span>-ary symmetric channel with symbol-error probability <span class="math inline">\(p\)</span>. Suppose the decoding array has <span class="math inline">\(\alpha_i\)</span> vectors of weight <span class="math inline">\(i\)</span> in its first column. Then for any codeword <span class="math inline">\(c\)</span> sent, the chance that it is successfully decoded is <span class="math display">\[\sum_{i = 0}^n\alpha_i\left( \frac{p}{q-1}\right)^i  (1-p)^{n-i}.\]</span></p>
</div>
<div class="exampleqed">
<p>For the array above, with <span class="math inline">\(q = 2\)</span>, we have <span class="math inline">\(\alpha_0 = 1,\;\alpha_1 = 2, \;\alpha_2 = 1, \;\alpha_3 = 0,\;\alpha_4 = 0\)</span>. So the chance of successful decoding is <span class="math inline">\((1-p)^4 +2 p(1-p)^3 + p^2((1-p)^2\)</span>.</p>
</div>
<div class="proof">
<p>The chance of successful decoding is the chance that one of the error-vectors in the first column occurred; since these are disjoint possibilities, we add their individual probabilities. (We include the zero error-vector - that is, the possibility that the codeword is received correctly.)</p>
</div>
<p>Steps 1 and 2 of the algorithm involve choice, so that many different arrays could be made for the same code. In general, some of these arrays would decode some received words differently. However, for a perfect code, all arrays will perform identical decoding. These ideas are explored in more detail in the homework (Q25-27).</p>
</section>
</section>
<script>
function doNumbering() {
	// The syntax to read the structured data from the yaml is horrible, template literals fix the problem but probably aren't widely supported enough. Escaping line breaks is browser dependant. I don't know if there's a better way?
	// Note that the data from the yaml file is manipulated into an array, and then parsed back into strings later, but I didn't want to deal with the pandoc templating syntax longer than necessary.
	var supportedEnvsArrayString = ' .definition;;; .theorem;;; .lemma;;; .proposition;;; .remark;;; .corollary;;; .exercise;;; .question';
	var supportedEnvsArray = supportedEnvsArrayString.split("|||");
	supportedEnvsArray = supportedEnvsArray.map(inner => inner.split(";;;"));
	var numberWithin = '1';
	var counterOffset = '1';
	var subcounterOffset = '';
	var problemCounter = '15';
	const partLabels = 'abcdefghijklmnopqrstuvwxyz'.split('');
	
	// counterOffset may be negative, and by default if specified on the command line this gets string concatenated with the default given in the yaml config and this then causes a problem. Can be fixed by removing the default in the config file and converting to an int, but this causes a NaN error if no value is suplied on the command line, so if NaN set to 0.
	counterOffset = parseInt(counterOffset);
	if (isNaN(counterOffset)) {
		counterOffset = 0;
	}
	
	subcounterOffset = parseInt(subcounterOffset);
	if (isNaN(subcounterOffset)) {
		subcounterOffset = 0;
	}
	
	problemCounter = parseInt(problemCounter);
	if (isNaN(problemCounter)) {
		problemCounter = 1;
	}
	
	function sanitiseSelector(selector) {
		// tex labels often have colons in which need escaping. There may be other escaping needed here. Unfortunately neither encodeURI nor encodeURIComponent do what I need, so use regex to do the escaping manually.
		var sanitised = selector.replace(/\:/g,"\\\:");
		sanitised = sanitised.replace(/(^[\d])/,"\\3$1 ");
		sanitised = sanitised.replace(/\//g,"\\\/");
		return sanitised
	}
	
	function labelLinks() {
		var refs = document.querySelectorAll("a[data-reference-type=ref]")
		for (ref of refs) {
			// Escape colons (or other) from the link title.
			var ref_label = sanitiseSelector(ref.getAttribute("data-reference"));
			// Hopefully ref is a reference to a div or a section, which should have the associated id. If so, we just need the data-number from the relevant DOM item.
			var ref_to = document.querySelector("#"+ref_label);
			if (ref_to !== null) {
				var ref_number = ref_to.getAttribute("data-number");
			} else {
				// If ref is being used for an equation, then we need to try to parse the mathjax divs. This is fragile, but try to find the span which corresponds to the equation number we need.
				try {
					var mathjax_ref = "#mjx-eqn-"+ref_label;
					ref_to = document.querySelector(mathjax_ref);
					// Since this is a ref, we don't want the parens to be returned, so find the equation number and strip the parens.
					var ref_number = ref_to.querySelector(".mjx-char").innerHTML.replace(/[()]/g,"");
					ref.setAttribute("href",mathjax_ref);
				}
				// If we can't find a place to link to, just indicate a missing link.
				catch (err){
					var ref_number = "???"
				}
			}
			ref.innerHTML = ref_number;
		};
	}
	
	function numberEnvs() {
		for (var levelSpec = 0; levelSpec <= numberWithin; levelSpec++) {
			var reqLevels = document.querySelectorAll(".level"+levelSpec);
			for (var level of reqLevels) {
				levelCount = level.getAttribute("data-number");
				levelCount = String(parseFloat(levelCount)+(counterOffset));
				levelCount = levelCount+(("."+subcounterOffset).repeat(numberWithin-levelSpec));
				for (var counter of supportedEnvsArray) {
					var envCount = 1;
					var envs = level.querySelectorAll(counter.join(", "));
					for (var env of envs) {
						env.setAttribute("data-number",levelCount+"."+envCount);
						envCount += 1;
					}
				}
			}
		}
	}
	
	function numberFigs() {
		// Figures should either be in a figure environment, or a table with image class imageTable thanks to the tableCaps filter.
		figs = document.querySelectorAll("figure, .imageTable");
		var fig_no = 1
		for (var fig of figs) {
			var cap
			// For figures, we want to move the id to the figure, and set the data-number on both the figure and the figcaption
			if (fig.nodeName == "FIGURE") {
				cap = fig.querySelector("figcaption");
				var img = fig.querySelector("img, embed")
				if (img) {
					var img_id = img.getAttribute("id");
					fig.setAttribute("id",img_id);
					img.removeAttribute("id");
				}
			// for tables (which must be .imageTable due to the querySelector above), we want to set the data-number on the table and the caption
			} else if (fig.nodeName == "TABLE") {
				cap = fig.querySelector("caption");
			}
			cap.setAttribute("data-number",fig_no);
			fig.setAttribute("data-number",fig_no);
			fig_no += 1;
		}
	}
	
	function numberGlobals() {
		// This function numbers any environments that just use a global counter, such as a problem number on a problems sheet, where there are no sections to number with respect to.
		probsols = document.querySelectorAll(".problem, .solution");
		var prob_no = problemCounter;
		var partNo = 0;
		for (var probsol of probsols) {
			if (probsol.className == "problem"){
				prob_no +=1;
				partNo = 0;
				probsol.setAttribute("data-number",prob_no);
			}
			else {
				if (probsol.parentNode.nodeName == "LI") {
					var partLabel = partLabels[partNo];
					probsol.setAttribute("data-number",prob_no.toString()+partLabel);
					partNo +=1;
				}
				else{
					probsol.setAttribute("data-number",prob_no);
				}
			}
			
		}
		// sols = document.querySelectorAll(".solution");
// 		var sol_no = problemCounter;
// 		for (var sol of sols) {
// 			sol.setAttribute("data-number",sol_no);
// 			sol_no +=1
// 		}
		egs = document.querySelectorAll(".example, .exampleqed");
		var eg_no = problemCounter;
		for (var eg of egs) {
			eg.setAttribute("data-number",eg_no);
			eg_no +=1
		}
	}
	
	// labelLinks() should occur last, so that the data-numbers have been correctly set first.
	numberEnvs();
	numberFigs();
	numberGlobals();
	labelLinks();
}
</script><script>
	var imageDir = ''
	imgs = document.querySelectorAll("img");
	for (var img of imgs) {
		imgsrc = img.getAttribute("src");
		img.setAttribute("src",imageDir.concat(imgsrc));
	}
</script></body>
</html>
